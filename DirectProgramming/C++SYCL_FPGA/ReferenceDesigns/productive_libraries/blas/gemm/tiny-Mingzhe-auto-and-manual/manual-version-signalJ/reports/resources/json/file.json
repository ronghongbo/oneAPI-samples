[{"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/exception_handler.hpp", "name":"exception_handler.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/exception_handler.hpp", "content":"#ifndef __EXCEPTIONHANDLER_HPP__\u000A#define __EXCEPTIONHANDLER_HPP__\u000A#include <sycl/sycl.hpp>\u000A#include <exception>\u000A#include <iostream>\u000A\u000Anamespace fpga_tools {\u000A\u000Avoid exception_handler(sycl::exception_list exceptions) {\u000A  for (std::exception_ptr const &e : exceptions) {\u000A    try {\u000A      std::rethrow_exception(e);\u000A    } catch (sycl::exception const &e) {\u000A      std::cout << \"Caught asynchronous SYCL exception:\\n\"\u000A                << e.what() << std::endl;\u000A    }\u000A  }\u000A}\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif //__EXCEPTIONHANDLER_HPP__\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/tiny-Mingzhe-auto-and-manual/manual-version-signalJ/gemm.cpp", "name":"gemm.cpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/tiny-Mingzhe-auto-and-manual/manual-version-signalJ/gemm.cpp", "content":"#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <sycl/sycl.hpp>\u000A\u000A#include \"exception_handler.hpp\"\u000A#include \"gemm.tiny.h\"\u000A\u000Aint main(int argc, char *argv[]) {\u000A#if defined(FPGA_EMULATOR)\u000A    std::cout << \"USING FPGA EMULATOR\" << std::endl;\u000A    sycl::ext::intel::fpga_emulator_selector device_selector;\u000A#else\u000A    std::cout << \"USING FPGA HARDWARE\" << std::endl;\u000A    sycl::ext::intel::fpga_selector device_selector;\u000A#endif\u000A    sycl::queue q(device_selector, fpga_tools::exception_handler,\u000A                  sycl::property::queue::enable_profiling());\u000A    std::cout << \"Device name: \"\u000A              << q.get_device().get_info<sycl::info::device::name>().c_str()\u000A              << std::endl;\u000A\u000A//    constexpr size_t I = 4;\u000A    constexpr size_t J = 4;\u000A  //  constexpr size_t K = 4;\u000A    constexpr size_t TOTAL_I = III * II * I;\u000A    constexpr size_t TOTAL_J = JJJ * JJ * J;\u000A    constexpr size_t TOTAL_K = KKK * KK * K;\u000A    constexpr size_t num_elem_A = TOTAL_K * TOTAL_I;\u000A    constexpr size_t num_elem_B = TOTAL_J * TOTAL_K;\u000A    constexpr size_t num_elem_C = TOTAL_J * TOTAL_I;\u000A\u000A    float *A = (float *)malloc(num_elem_A * sizeof(float));\u000A    float *B = (float *)malloc(num_elem_B * sizeof(float));\u000A    float *C = (float *)malloc(num_elem_C * sizeof(float));\u000A    float *result = (float *)malloc(num_elem_C * sizeof(float));\u000A\u000A    // Generate the random input matrices\u000A    for (size_t i = 0; i < TOTAL_I; i++) {\u000A        for (size_t k = 0; k < TOTAL_K; k++) {\u000A            A[k + i * TOTAL_K] = random();\u000A        }\u000A    }\u000A    for (size_t j = 0; j < TOTAL_J; j++) {\u000A        for (size_t k = 0; k < TOTAL_K; k++) {\u000A            B[j + k * TOTAL_J] = A[k + j * TOTAL_K];\u000A        }\u000A    }\u000A\u000A    gemm(A, B, C, result, 1, 1, I, q);\u000A\u000A    bool passed = true;\u000A    // for (size_t i = 0; i < TOTAL_I; i++) {\u000A    //     for (size_t j = 0; j < TOTAL_J; j++) {\u000A    //         float golden = 0.0f;\u000A    //         for (size_t k = 0; k < TOTAL_K; k++) {\u000A    //             golden += A[k + i * TOTAL_K] * B[j + k * TOTAL_J];\u000A    //         }\u000A    //         passed &= fabs(golden - C[j + i * TOTAL_J]) < 0.005 *\u000A    //         fabs(golden);\u000A    //     }\u000A    // }\u000A\u000A    if (passed) {\u000A        printf(\"[PASSED]\\n\");\u000A    } else {\u000A        printf(\"[FAILED]\\n\");\u000A    }\u000A    free(A);\u000A    free(B);\u000A    free(C);\u000A}\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/tiny-Mingzhe-auto-and-manual/manual-version-signalJ/gemm.tiny.h", "name":"gemm.tiny.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/tiny-Mingzhe-auto-and-manual/manual-version-signalJ/gemm.tiny.h", "content":"#pragma once\u000A\u000A#include <iostream>\u000A#include <list>\u000A#include <stdlib.h>\u000A#include <vector>\u000A\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A#include <sycl/sycl.hpp>\u000A\u000A#ifdef FPGA_EMULATOR\u000A#define KKK 4\u000A#define JJJ 4\u000A#define III 4\u000A#define JJ 4\u000A#define II 4\u000A#define KK 4\u000A#define K 4\u000A//#define J 4\u000A#define I 4\u000A#else\u000A#define KKK 4\u000A#define JJJ 4\u000A#define III 4\u000A#define JJ 4\u000A#define II 4\u000A#define KK 4\u000A#define K 4\u000A//#define J 4\u000A#define I 4\u000A#endif\u000A\u000A#define ADD_INT64_T_SUFFIX(x) x##l\u000A#define ADD_UINT64_T_SUFFIX(x) x##ul\u000A\u000A#ifdef __SYCL_DEVICE_ONLY__\u000A#define CL_CONSTANT __attribute__((opencl_constant))\u000A#else\u000A#define CL_CONSTANT\u000A#endif\u000A\u000Ausing namespace sycl;\u000A\u000A#define PRINTF(format, ...)                                        \\\u000A    {                                                              \\\u000A        static const CL_CONSTANT char _format[] = format;          \\\u000A        ext::oneapi::experimental::printf(_format, ##__VA_ARGS__); \\\u000A    }\u000A/*\u000Aconstexpr size_t TOTAL_I = III * II * I;\u000Aconstexpr size_t TOTAL_J = JJJ * JJ * J;\u000Aconstexpr size_t TOTAL_K = KKK * KK * K;\u000Aconstexpr size_t num_elem_A = TOTAL_K * TOTAL_I;\u000Aconstexpr size_t num_elem_B = TOTAL_J * TOTAL_K;\u000Aconstexpr size_t num_elem_C = TOTAL_J * TOTAL_I;\u000A*/\u000Ausing aLoader_channel =\u000A    sycl::ext::intel::pipe<class _aLoader_channel_pipe, float4, 256>;\u000Atypedef struct {\u000A    float4 s[4];\u000A} aFeeder_channel_array_t;\u000Ausing aFeeder_channel = sycl::ext::intel::pipe<class _aFeeder_channel_pipe,\u000A                                               aFeeder_channel_array_t, 256>;\u000Ausing bLoader_channel =\u000A    sycl::ext::intel::pipe<class _bLoader_channel_pipe, float4, 256>;\u000Atypedef struct {\u000A    float4 s[4];\u000A} bFeeder_channel_array_t;\u000Ausing bFeeder_channel = sycl::ext::intel::pipe<class _bFeeder_channel_pipe,\u000A                                               bFeeder_channel_array_t, 256>;\u000Ausing SignalGenerator_channel = sycl::ext::intel::pipe<class _SignalGenerator_channel_pipe, bool, 256>;\u000Ausing Product_channel = sycl::ext::intel::pipe<class Product_channel_pipe, float4, 256>;\u000Ausing cLoader_channel = sycl::ext::intel::pipe<class cLoader_channel_pipe, float4, 256>;\u000Ausing Out_channel = sycl::ext::intel::pipe<class Out_channel_pipe, float4, 256>;\u000A\u000Avoid gemm(float *A, float *B, float *C, float *result, float p2, float p3, const size_t J, sycl::queue &q) {\u000A    std::vector<sycl::event> oneapi_kernel_events;\u000A\u000A    const size_t TOTAL_I = III * II * I;\u000A        const size_t TOTAL_J = JJJ * JJ * J;\u000A        const size_t TOTAL_K = KKK * KK * K;\u000A        const size_t num_elem_A = TOTAL_K * TOTAL_I;\u000A        const size_t num_elem_B = TOTAL_J * TOTAL_K;\u000A        const size_t num_elem_C = TOTAL_J * TOTAL_I;\u000A\u000A\u000A    float *serialized_A = (float *)malloc(num_elem_A * sizeof(float));\u000A    float *serialized_B = (float *)malloc(num_elem_B * sizeof(float));\u000A    float *serialized_C = (float *)malloc(num_elem_C * sizeof(float));\u000A    float *serialized_reuslt = (float *)malloc(num_elem_C * sizeof(float));\u000A    float *serialized_A_device = sycl::malloc_device<float>(num_elem_A, q);\u000A    float *serialized_B_device = sycl::malloc_device<float>(num_elem_B, q);\u000A    float *serialized_C_device = sycl::malloc_device<float>(num_elem_C, q);\u000A    float *serialized_reuslt_device = sycl::malloc_device<float>(num_elem_C, q);\u000A\u000A    // kernel_A_serializer\u000A    std::cout << \"kernel_A_serializer\" << std::endl;\u000A    size_t addr = 0;\u000A    for (int i = 0; i < I; i++)\u000A        for (int k = 0; k < K; k++)\u000A            for (int kk = 0; kk < KK; kk++)\u000A                for (int ii = 0; ii < II; ii++)\u000A                    for (int iii = 0; iii < III; iii++)\u000A                        for (int kkk = 0; kkk < KKK; kkk++) {\u000A                            int total_k = kkk + KKK * kk + KKK * KK * k;\u000A                            int total_i = iii + III * ii + III * II * i;\u000A                            serialized_A[addr++] =\u000A                                A[total_k + total_i * TOTAL_K];\u000A                        }\u000A\u000A    // kernel_B_serializer\u000A    std::cout << \"kernel_B_serializer\" << std::endl;\u000A    addr = 0;\u000A    for (int j = 0; j < J; j++)\u000A        for (int k = 0; k < K; k++)\u000A            for (int kk = 0; kk < KK; kk++)\u000A                for (int jj = 0; jj < JJ; jj++)\u000A                    for (int jjj = 0; jjj < JJJ; jjj++)\u000A                        for (int kkk = 0; kkk < KKK; kkk++) {\u000A                            int total_k = kkk + KKK * kk + KKK * KK * k;\u000A                            int total_j = jjj + JJJ * jj + JJJ * JJ * j;\u000A                            serialized_B[addr++] =\u000A                                B[total_j + total_k * TOTAL_J];\u000A                        }\u000A\u000A    // kernel_C_serializer\u000A    std::cout << \"kernel_C_serializer\" << std::endl;\u000A    addr = 0;\u000A    for (int i = 0; i < I; i++)\u000A        for (int j = 0; j < J; j++)\u000A            for (int iii = 0; iii < III; iii++)\u000A                for (int ii = 0; ii < II; ii++)\u000A                    for (int jj = 0; jj < JJ; jj++)\u000A                        for (int jjj = 0; jjj < JJJ; jjj++) {\u000A                            int total_i = iii + III * ii + III * II * i;\u000A                            int total_j = jjj + JJJ * jj + JJJ * JJ * j;\u000A                            serialized_C[addr++] =\u000A                                C[total_j + total_i * TOTAL_J];\u000A                        }\u000A\u000A    std::cout << \"memcpy matrix A host->device\" << std::endl;\u000A    q.memcpy(serialized_A_device, serialized_A, num_elem_A * sizeof(float))\u000A        .wait();\u000A\u000A    // kernel_aLoader\u000A    std::cout << \"kernel_aLoader\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_aLoader>(\u000A            [=]() [[intel::kernel_args_restrict]] {\u000A                device_ptr<float> serialized_A_d(serialized_A_device);\u000A                int addr_temp;\u000A                addr_temp = 0;\u000A                for (int i = 0; i < (TOTAL_I + 31) / 16; i++) {\u000A                    for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                        for (int k = 0; k < (TOTAL_K + 15) / 16; k++) {\u000A                            for (int kk_ii_iii = 0; kk_ii_iii < 64; kk_ii_iii++) {\u000A                                if (j == 0 && k == 0 || i < (TOTAL_I + 15) / 16) {\u000A                                    auto _D1 = (addr_temp / ((TOTAL_J + 15) / 16 * ((TOTAL_K + 15) / 16) * 64) * ((TOTAL_K + 15) / 16) * 64 + addr_temp % ((TOTAL_K + 15) / 16 * 64)) * 4;\u000A                                    aLoader_channel::write(i * 16 + (kk_ii_iii % 16 / 4 * 4 + kk_ii_iii % 4) < TOTAL_I && (kk_ii_iii / 16 + k * 4) * 4 < TOTAL_K && i < (TOTAL_I + 15) / 16 ? float4{\u000A                                                                                                                                                                                                  serialized_A_d[_D1 + 0],\u000A                                                                                                                                                                                                  serialized_A_d[_D1 + 1],\u000A                                                                                                                                                                                                  serialized_A_d[_D1 + 2],\u000A                                                                                                                                                                                                  serialized_A_d[_D1 + 3]}\u000A                                                                                                                                                                                            : float4{0.0f});\u000A                                }\u000A                                addr_temp = addr_temp + 1;\u000A                            }\u000A                        }\u000A                    }\u000A                }\u000A            });\u000A    }));\u000A\u000A    // kernel_aFeeder\u000A    std::cout << \"kernel_aFeeder\" << std::endl;\u000A    q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_aFeeder>([=]() {\u000A            aFeeder_channel_array_t aFeeder_channel_array;\u000A            float4 aFeeder_value_shreg;\u000A            uint32_t aFeeder_time_stamp_shreg;\u000A            float4 aFeeder_in_v;\u000A            uint aFeeder_cycle;\u000A            // OpenCL's __attribute__((memory, numbanks(4), singlepump, numwriteports(1), numreadports(1)))DB[2][4][4][4]\u000A            [[intel::fpga_memory(), intel::numbanks(4), intel::singlepump, intel::simple_dual_port]] float4 DB[2][4][4][4];\u000A#pragma unroll\u000A            for (int jjj_init = 0; jjj_init < 4; jjj_init++) {\u000A                if (jjj_init == 0) {\u000A                    aFeeder_cycle = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A                }\u000A            }\u000A            while (1) {\u000A                aFeeder_in_v = aLoader_channel::read();\u000A#pragma unroll\u000A                for (int buf = 0; buf < 4; buf++) {\u000A                    if (buf == 0) {\u000A                        aFeeder_value_shreg = aFeeder_in_v;\u000A                        aFeeder_time_stamp_shreg = aFeeder_cycle;\u000A                    } else {\u000A                        aFeeder_value_shreg = aFeeder_value_shreg;\u000A                        aFeeder_time_stamp_shreg = aFeeder_time_stamp_shreg;\u000A                    }\u000A                    aFeeder_value_shreg = float4{\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[0])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[1])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[2])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[3]))};\u000A                    aFeeder_time_stamp_shreg = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_time_stamp_shreg));\u000A                    if (buf == (int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(4)))) {\u000A                        DB[(bool)(aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf] = aFeeder_value_shreg;\u000A                    }\u000A                    if ((uint)(ADD_UINT64_T_SUFFIX(0)) < aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                        aFeeder_channel_array.s[buf] = DB[!(bool)(aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf];\u000A                    }\u000A                }\u000A                if ((uint)(ADD_UINT64_T_SUFFIX(0)) < aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                    aFeeder_channel::write(aFeeder_channel_array);\u000A                }\u000A                aFeeder_cycle = aFeeder_cycle + (uint)(ADD_UINT64_T_SUFFIX(1));\u000A            }\u000A        });\u000A    });\u000A\u000A    std::cout << \"memcpy matrix B host->device\" << std::endl;\u000A    q.memcpy(serialized_B_device, serialized_B, num_elem_B * sizeof(float))\u000A        .wait();\u000A    // kernel_bLoader\u000A    std::cout << \"kernel_bLoader\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_bLoader>(\u000A            [=]() [[intel::kernel_args_restrict]] {\u000A                device_ptr<float> serialized_B_d(serialized_B_device);\u000A                int addr_temp;\u000A                addr_temp = 0;\u000A                for (int i = 0; i < (TOTAL_I + 31) / 16; i++) {\u000A                    for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                        for (int k = 0; k < (TOTAL_K + 15) / 16; k++) {\u000A                            for (int kk_jj_jjj = 0; kk_jj_jjj < 64; kk_jj_jjj++) {\u000A                                if (j == 0 && k == 0 || i < (TOTAL_I + 15) / 16) {\u000A                                    auto _D3 = addr_temp % ((TOTAL_J + 15) / 16 * ((TOTAL_K + 15) / 16) * 64) * 4;\u000A                                    bLoader_channel::write((kk_jj_jjj / 16 + k * 4) * 4 < TOTAL_K && j * 16 + (kk_jj_jjj % 16 / 4 * 4 + kk_jj_jjj % 4) < TOTAL_J && i < (TOTAL_I + 15) / 16 ? float4{\u000A                                                                                                                                                                                                  serialized_B_d[_D3 + 0],\u000A                                                                                                                                                                                                  serialized_B_d[_D3 + 1],\u000A                                                                                                                                                                                                  serialized_B_d[_D3 + 2],\u000A                                                                                                                                                                                                  serialized_B_d[_D3 + 3]}\u000A                                                                                                                                                                                            : float4{0.0f});\u000A                                }\u000A                                addr_temp = addr_temp + 1;\u000A                            }\u000A                        }\u000A                    }\u000A                }\u000A            });\u000A    }));\u000A\u000A    // kernel_bFeeder\u000A    std::cout << \"kernel_bFeeder\" << std::endl;\u000A    q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_bFeeder>([=]() {\u000A            bFeeder_channel_array_t bFeeder_channel_array;\u000A            float4 bFeeder_value_shreg;\u000A            uint32_t bFeeder_time_stamp_shreg;\u000A            float4 bFeeder_in_v;\u000A            uint bFeeder_cycle;\u000A            // OpenCL's __attribute__((memory, numbanks(4), singlepump, numwriteports(1), numreadports(1)))DB[2][4][4][4]\u000A            [[intel::fpga_memory(), intel::numbanks(4), intel::singlepump, intel::simple_dual_port]] float4 DB[2][4][4][4];\u000A#pragma unroll\u000A            for (int iii_init = 0; iii_init < 4; iii_init++) {\u000A                if (iii_init == 0) {\u000A                    bFeeder_cycle = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A                }\u000A            }\u000A            while (1) {\u000A                bFeeder_in_v = bLoader_channel::read();\u000A#pragma unroll\u000A                for (int buf = 0; buf < 4; buf++) {\u000A                    if (buf == 0) {\u000A                        bFeeder_value_shreg = bFeeder_in_v;\u000A                        bFeeder_time_stamp_shreg = bFeeder_cycle;\u000A                    } else {\u000A                        bFeeder_value_shreg = bFeeder_value_shreg;\u000A                        bFeeder_time_stamp_shreg = bFeeder_time_stamp_shreg;\u000A                    }\u000A                    bFeeder_value_shreg = float4{\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[0])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[1])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[2])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[3]))};\u000A                    bFeeder_time_stamp_shreg = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_time_stamp_shreg));\u000A                    if (buf == (int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(4)))) {\u000A                        DB[(bool)(bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf] = bFeeder_value_shreg;\u000A                    }\u000A                    if ((uint)(ADD_UINT64_T_SUFFIX(0)) < bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                        bFeeder_channel_array.s[buf] = DB[!(bool)(bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) % 4][buf];\u000A                    }\u000A                }\u000A                if ((uint)(ADD_UINT64_T_SUFFIX(0)) < bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                    bFeeder_channel::write(bFeeder_channel_array);\u000A                }\u000A                bFeeder_cycle = bFeeder_cycle + (uint)(ADD_UINT64_T_SUFFIX(1));\u000A            }\u000A        });\u000A    });\u000A\u000A    // kernel_SignalGenerator\u000A    std::cout << \"kernel_SignalGenerator\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_SignalGenerator>([=]() {\u000A            for (int i = 0; i < (TOTAL_I + 31) / 16; i++) {\u000A                int j = 0;\u000A                while (1) {\u000A                    bool j_not_done = j < (TOTAL_J + 15) / 16;\u000A                    SignalGenerator_channel::write(j_not_done);\u000A                    if (!j_not_done) {\u000A                        break;\u000A                    }\u000A                    j++;\u000A                }\u000A            }\u000A        });\u000A    }));\u000A\u000A    // kernel_Product\u000A    std::cout << \"kernel_Product\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_Product>([=]() {\u000A            bFeeder_channel_array_t bFeeder_channel_array;\u000A            aFeeder_channel_array_t aFeeder_channel_array;\u000A            float Z_shreg[16][4][4];\u000A            float Z_pipe_shreg[4][49];\u000A            float4 Y_shreg[4];\u000A            float Z[4][4];\u000A            float4 X_shreg[4];\u000A            float Z_shreg_;\u000A            int Z_pipe_iter;\u000A            int Z_pipe_base;\u000A            Z_pipe_iter = 64;\u000A            Z_pipe_base = 0;\u000A            for (int i = 0; i < (TOTAL_I + 31) / 16; i++) {\u000A                //for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                while (SignalGenerator_channel::read()) {\u000A                    for (int k = 0; k < (TOTAL_K + 15) / 16; k++) {\u000A                        for (int kk_ii_jj = 0; kk_ii_jj < 64; kk_ii_jj++) {\u000A#pragma unroll\u000A                            for (int iii = 0; iii < 4; iii++) {\u000A#pragma unroll\u000A                                for (int jjj = 0; jjj < 4; jjj++) {\u000A                                    Z[jjj][iii] = Z_shreg[15][jjj][iii];\u000A#pragma unroll\u000A                                    for (int l1 = 0; l1 < 15; l1++) {\u000A                                        Z_shreg[15 - l1][jjj][iii] = Z_shreg[14 - l1][jjj][iii];\u000A                                    }\u000A                                    Z_shreg[0][jjj][iii] = Z[jjj][iii];\u000A                                }\u000A                            }\u000A                            if (i < (TOTAL_I + 15) / 16) {\u000A                                bFeeder_channel_array = bFeeder_channel::read();\u000A                                aFeeder_channel_array = aFeeder_channel::read();\u000A                            }\u000A#pragma unroll\u000A                            for (int iii = 0; iii < 4; iii++) {\u000A#pragma unroll\u000A                                for (int jjj = 0; jjj < 4; jjj++) {\u000A                                    X_shreg[iii] = jjj == 0 ? aFeeder_channel_array.s[iii] : X_shreg[iii];\u000A                                    X_shreg[iii] = float4{\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][0])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][1])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][2])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][3]))};\u000A                                    Y_shreg[jjj] = iii == 0 ? bFeeder_channel_array.s[jjj] : Y_shreg[jjj];\u000A                                    Y_shreg[jjj] = float4{\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][0])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][1])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][2])),\u000A                                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][3]))};\u000A                                    Z_shreg_ = k == 0 && kk_ii_jj / 16 == 0 ? 0.0f : sycl::ext::intel::fpga_reg(Z_shreg[0][jjj][iii]);\u000A#pragma unroll\u000A                                    for (int kkk = 0; kkk < 4; kkk++) {\u000A                                        Z_shreg_ = Z_shreg_ + X_shreg[iii][kkk] * Y_shreg[jjj][kkk];\u000A                                        if (kkk == 3) {\u000A                                            Z_shreg_ = sycl::ext::intel::fpga_reg(Z_shreg_);\u000A                                        }\u000A                                    }\u000A                                    Z_shreg[0][jjj][iii] = Z_shreg_;\u000A#pragma unroll\u000A                                    for (int kkk = 0; kkk < 4; kkk++) {\u000A                                        if (kkk == 3 && kk_ii_jj / 16 == 3 && k == (TOTAL_K + -1) / 16) {\u000A                                            Z_pipe_shreg[jjj][iii * 16] = Z_shreg[0][jjj][iii];\u000A                                        }\u000A                                    }\u000A                                }\u000A                            }\u000A                            if (kk_ii_jj % 4 == 0 && kk_ii_jj % 16 / 4 == 0 && k == (TOTAL_K + -1) / 16 && kk_ii_jj / 16 == 3 && i < (TOTAL_I + 15) / 16) {\u000A                                Z_pipe_base = Z_pipe_iter;\u000A                            }\u000A                            float4 Product_channel_;\u000A#pragma unroll\u000A                            for (int b_62 = 0; b_62 < 4; b_62++) {\u000A                                Product_channel_[b_62] = Z_pipe_shreg[b_62][0];\u000A#pragma unroll\u000A                                for (int b_62_dummy = 0; b_62_dummy < 4; b_62_dummy++) {\u000A                                    Product_channel_[b_62_dummy] = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Product_channel_[b_62_dummy]));\u000A                                }\u000A                            }\u000A                            if (Z_pipe_iter < Z_pipe_base + 64) {\u000A                                Product_channel::write(Product_channel_);\u000A                            }\u000A#pragma unroll\u000A                            for (int b_63 = 0; b_63 < 4; b_63++) {\u000A#pragma unroll\u000A                                for (int p_31 = 0; p_31 < 3; p_31++) {\u000A#pragma unroll\u000A                                    for (int l_31 = 0; l_31 < 15; l_31++) {\u000A                                        Z_pipe_shreg[b_63][p_31 * 16 + l_31] = Z_pipe_shreg[b_63][p_31 * 16 + l_31 + 1];\u000A                                    }\u000A                                    Z_pipe_shreg[b_63][p_31 * 16 + 15] = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Z_pipe_shreg[b_63][p_31 * 16 + 16]));\u000A                                }\u000A                            }\u000A                            Z_pipe_iter = Z_pipe_iter + 1;\u000A                        }\u000A                    }\u000A                }\u000A            }\u000A        });\u000A    }));\u000A\u000A    std::cout << \"memcpy matrix C host->device\" << std::endl;\u000A    q.memcpy(serialized_C_device, serialized_C, num_elem_C * sizeof(float))\u000A        .wait();\u000A    // kernel_cLoader\u000A    std::cout << \"kernel_cLoader\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_cLoader>([=]() [[intel::kernel_args_restrict]] {\u000A            device_ptr<float> serialized_C_d(serialized_C_device);\u000A            int addr_temp;\u000A            addr_temp = 0;\u000A            for (int i = 0; i < (TOTAL_I + 15) / 16; i++) {\u000A                for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                    for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                        if (p3 != 0.0f) {\u000A                            cLoader_channel::write(float4{\u000A                                serialized_C_d[addr_temp * 4 + 0],\u000A                                serialized_C_d[addr_temp * 4 + 1],\u000A                                serialized_C_d[addr_temp * 4 + 2],\u000A                                serialized_C_d[addr_temp * 4 + 3]});\u000A                        }\u000A                        addr_temp = addr_temp + 1;\u000A                    }\u000A                }\u000A            }\u000A        });\u000A    }));\u000A\u000A    // kernel_Out\u000A    std::cout << \"kernel_Out\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_Out>([=]() {\u000A            float Z[4][4];\u000A            float4 Add_shreg;\u000A            for (int i = 0; i < (TOTAL_I + 15) / 16; i++) {\u000A                for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                    for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                        Add_shreg = (p3 == 0.0f ? float4{0.0f} : cLoader_channel::read() * float4{p3}) + Product_channel::read() * float4{p2};\u000A                        Out_channel::write(Add_shreg);\u000A                    }\u000A                }\u000A            }\u000A        }); //  h.single_task kernel_Out_class\u000A    }));\u000A\u000A    // kernel_unloader\u000A    std::cout << \"kernel_unloader\" << std::endl;\u000A    oneapi_kernel_events.push_back(q.submit([&](sycl::handler &h) {\u000A        h.single_task<class kernel_unloader>(\u000A            [=]() [[intel::kernel_args_restrict]] {\u000A                device_ptr<float> serialized_reuslt_d(serialized_reuslt_device);\u000A                int addr_temp;\u000A                addr_temp = 0;\u000A                for (int i = 0; i < (TOTAL_I + 15) / 16; i++) {\u000A                    for (int j = 0; j < (TOTAL_J + 15) / 16; j++) {\u000A                        for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                            auto _D6 = Out_channel::read();\u000A                            serialized_reuslt_d[addr_temp * 4 + 0] = _D6[0];\u000A                            serialized_reuslt_d[addr_temp * 4 + 1] = _D6[1];\u000A                            serialized_reuslt_d[addr_temp * 4 + 2] = _D6[2];\u000A                            serialized_reuslt_d[addr_temp * 4 + 3] = _D6[3];\u000A                            addr_temp = addr_temp + 1;\u000A                        }\u000A                    }\u000A                }\u000A            });\u000A    }));\u000A\u000A    for (unsigned int i = 0; i < oneapi_kernel_events.size(); i++) {\u000A        oneapi_kernel_events.at(i).wait();\u000A        std::cout << i << \"finished\" << std::endl;\u000A    };\u000A\u000A    if (oneapi_kernel_events.size() > 0) {\u000A        double k_earliest_start_time =\u000A            oneapi_kernel_events.at(0)\u000A                .get_profiling_info<\u000A                    sycl::info::event_profiling::command_start>();\u000A        double k_latest_end_time =\u000A            oneapi_kernel_events.at(0)\u000A                .get_profiling_info<sycl::info::event_profiling::command_end>();\u000A        for (unsigned i = 1; i < oneapi_kernel_events.size(); i++) {\u000A            double tmp_start =\u000A                oneapi_kernel_events.at(i)\u000A                    .get_profiling_info<\u000A                        sycl::info::event_profiling::command_start>();\u000A            double tmp_end =\u000A                oneapi_kernel_events.at(i)\u000A                    .get_profiling_info<\u000A                        sycl::info::event_profiling::command_end>();\u000A            if (tmp_start < k_earliest_start_time) {\u000A                k_earliest_start_time = tmp_start;\u000A            }\u000A            if (tmp_end > k_latest_end_time) {\u000A                k_latest_end_time = tmp_end;\u000A            }\u000A        }\u000A        // Get time in ns\u000A        double events_time = (k_latest_end_time - k_earliest_start_time);\u000A        printf(\"  Time: %.5f ns\\n\", events_time);\u000A        printf(\"  Throughput: %.2f GFLOPS\\n\",\u000A               (double)2.0 * (TOTAL_K) * (double)(TOTAL_I) * (double)(TOTAL_J) /\u000A                   events_time);\u000A    }\u000A\u000A    std::cout << \"memcpy result device->host\" << std::endl;\u000A    q.memcpy(serialized_reuslt, serialized_reuslt_device, num_elem_C * sizeof(float))\u000A        .wait();\u000A\u000A    // kernel_C_deserializer\u000A    std::cout << \"kernel_C_deserializer\" << std::endl;\u000A    addr = 0;\u000A    for (size_t i = 0; i < I; i++)\u000A        for (size_t j = 0; j < J; j++)\u000A            for (size_t iii = 0; iii < III; iii++)\u000A                for (size_t ii = 0; ii < II; ii++)\u000A                    for (size_t jj = 0; jj < JJ; jj++)\u000A                        for (size_t jjj = 0; jjj < JJJ; jjj++) {\u000A                            size_t total_i = iii + III * ii + III * II * i;\u000A                            size_t total_j = jjj + JJJ * jj + JJJ * JJ * j;\u000A                            result[total_j + total_i * TOTAL_J] =\u000A                                serialized_reuslt[addr++];\u000A                        }\u000A\u000A    free(serialized_A);\u000A    free(serialized_B);\u000A    free(serialized_C);\u000A    free(serialized_reuslt);\u000A    sycl::free(serialized_A_device, q);\u000A    sycl::free(serialized_B_device, q);\u000A    sycl::free(serialized_C_device, q);\u000A    sycl::free(serialized_reuslt_device, q);\u000A}\u000A"}]