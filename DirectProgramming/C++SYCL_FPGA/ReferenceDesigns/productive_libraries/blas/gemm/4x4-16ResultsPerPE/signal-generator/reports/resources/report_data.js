var areaJSON={"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[38.1236, 24.5336, 15.8785, 23.6638, 5.59947], "total":[198435, 271332, 642, 85, 559], "name":"Kernel System", "max_resources":[854400, 1708800, 2713, 1518, 42720], "children":[{"name":"Static Partition", "type":"partition", "children":[{"name":"Board interface", "type":"resource", "data":[134500, 172452, 397, 0, 0], "details":[{"type":"text", "text":"Platform interface logic."}]}]}, {"name":"Global interconnect", "type":"resource", "data":[12524, 15522, 104, 0, 0], "details":[{"type":"text", "text":"Global interconnect for 3 global loads and 1 global store. Reduce number of global loads and stores to simplify global interconnect."}, {"type":"brief", "text":"For 3 global loads and 1 global store."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Global Memory Interconnect", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}]}]}, {"name":"System description ROM", "type":"resource", "data":[0, 67, 2, 0, 0], "details":[{"type":"text", "text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program."}, {"type":"brief", "text":"Contains information for the host."}]}, {"name":"Pipe resources", "type":"group", "children":[{"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Out_channel_pipe, sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 390, 4, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 128 bits wide by 256 deep."}, {"type":"brief", "text":"128b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Product_channel_pipe, sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 390, 4, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 128 bits wide by 256 deep."}, {"type":"brief", "text":"128b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 1542, 13, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 512 bits wide by 256 deep."}, {"type":"brief", "text":"512b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aLoader_channel_pipe, sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 390, 4, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 128 bits wide by 256 deep."}, {"type":"brief", "text":"128b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 1542, 13, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 512 bits wide by 256 deep."}, {"type":"brief", "text":"512b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bLoader_channel_pipe, sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 390, 4, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 128 bits wide by 256 deep."}, {"type":"brief", "text":"128b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::cLoader_channel_pipe, sycl::_V1::vec<float, 4>)", "type":"resource", "data":[11, 390, 4, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 128 bits wide by 256 deep."}, {"type":"brief", "text":"128b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}, {"name":"Pipe (sycl::_V1::ext::intel::pipe<t2sp::sgemm::_SignalGenerator_channel_pipe, t2sp::sgemm::signals_t, 256>)", "type":"resource", "data":[11, 102, 1, 0, 0], "details":[{"type":"text", "text":"Pipe is implemented 32 bits wide by 256 deep."}, {"type":"brief", "text":"32b wide by 256 deep."}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"name":"kernel_bFeeder_class", "compute_units":1, "type":"function", "total_percent":[0.908732, 0.604869, 0.36312, 0, 0], "total_kernel_resources":[3388, 6205, 0, 0, 89], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1072, 2225, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Coalesced Private Variables: \\n - \'bFeeder_time_stamp_shreg\' (sgemm.sycl.h:544)\\n - \'bFeeder_cycle\' (sgemm.sycl.h:546)", "type":"resource", "data":[7, 36, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":544}], [{"filename":"sgemm.sycl.h", "line":546}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'bFeeder_channel_array\' (sgemm.sycl.h:542)", "type":"resource", "data":[299, 1291, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":542}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"16 registers of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n16 regs, 32 width by 1 depth"}]}, {"name":"sgemm.sycl.h:549 (DB)", "type":"resource", "data":[0, 0, 0, 0, 28], "debug":[[{"filename":"sgemm.sycl.h", "line":549}]], "details":[{"type":"table", "Private memory":"Stall-free", "Requested size":"2048 bytes", "Implemented size":"2048 bytes", "Memory Usage":"28 MLABs", "Number of banks":"4 (banked on bits 4, 5)", "Bank width":"128 bits", "Bank depth":"32 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Requested size 2048 bytes, implemented size 2048 bytes, stall-free, 4 reads and 4 writes. "}, {"type":"text", "text":"Banked on bits 4, 5 into 4 separate banks."}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}, {"type":"text", "text":"Private memory implemented in on-chip block RAM."}], "Reference":[{"type":"text", "text":"See %L for more information.", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}, {"type":"brief", "text":"Stall-free,\\n2048B requested,\\n2048B implemented."}]}, {"name":"kernel_bFeeder_class.B0", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[13, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:548", "type":"resource", "data":[8, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":548}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:555", "type":"resource", "data":[5, 5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":555}]]}]}]}, {"name":"kernel_bFeeder_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[223, 340, 0, 0, 24], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[223, 340, 0, 0, 24]}]}, {"name":"Feedback", "type":"resource", "data":[24, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:542", "type":"resource", "data":[11, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":542}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:546", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":546}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:576", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 12, 0, 0, 27], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[386, 770, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.fanout", "type":"resource", "count":2, "data":[2, 2, 0, 0, 0]}, {"name":"llvm.fpga.reg", "type":"resource", "count":24, "data":[384, 768, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:556 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":556}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:565 > types.hpp:789", "type":"resource", "data":[256, 512, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":565}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp", "line":789}]], "children":[{"name":"llvm.fpga.reg", "type":"resource", "count":16, "data":[256, 512, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:572", "type":"resource", "data":[4, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":572}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[4, 3, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:573", "type":"resource", "data":[136, 96, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":573}]], "children":[{"name":"Store", "type":"resource", "count":4, "data":[136, 96, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"sgemm.sycl.h", "line":"549"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:575", "type":"resource", "data":[140, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":575}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[140, 4, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:576", "type":"resource", "data":[808, 900, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":557}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[512, 352, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":4, "data":[296, 548, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"sgemm.sycl.h", "line":"549"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:580 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":580}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"kernel_SignalGenerator", "compute_units":1, "type":"function", "total_percent":[0.533205, 0.352528, 0.214888, 0, 0], "total_kernel_resources":[2672, 3672, 0, 0, 17], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"text", "text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:", "details":[{"type":"text", "text":"%L with depth 4", "links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"595"}]}]}, {"type":"brief", "text":"1 compute unit.\\n1 loop nested 3 levels deep or more."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:592)", "type":"resource", "data":[14, 73, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":592}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:593)", "type":"resource", "data":[11, 72, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":593}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:594)", "type":"resource", "data":[22, 142, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":594}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'kk_ii_jj\' (sgemm.sycl.h:595)", "type":"resource", "data":[14, 47, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":595}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"kernel_SignalGenerator.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[195, 487, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[195, 385, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[0, 100.833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[0, 0.833333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[0, 0.333333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[269.833, 4.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.5, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":5, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":5, "data":[140, 4, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":4, "data":[97, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[71.8333, 1.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.5, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[71.3333, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_SignalGenerator.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[53, 100, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[53, 100, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[9, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[9, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[45, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:596", "type":"resource", "data":[71, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":596}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_SignalGenerator.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[4, 37, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[4, 37, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[33, 24, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[16, 12, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[5, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:596", "type":"resource", "data":[12, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":596}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[44.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_SignalGenerator.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[63, 115, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[63, 115, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[46, 32, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[20.6667, 14.6667, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[8.66667, 6.66667, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[4.66667, 2.66667, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:596", "type":"resource", "data":[12, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":596}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[44.3333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:597", "type":"resource", "data":[11, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":597}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:598", "type":"resource", "data":[82, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":598}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[46, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_SignalGenerator.B7", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[15, 25, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[15, 25, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[60, 46, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[16.75, 11.9167, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[8.75, 6.91667, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[4.75, 4.41667, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:595", "type":"resource", "data":[3.75, 1.75, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":595}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:596", "type":"resource", "data":[9, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":596}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:597", "type":"resource", "data":[8, 5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":597}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:598", "type":"resource", "data":[9, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":598}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 3], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:592", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:593", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:594", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:595", "type":"resource", "data":[2.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":595}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:597", "type":"resource", "data":[10, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":597}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[9, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:598", "type":"resource", "data":[10, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":598}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[9, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:599", "type":"resource", "data":[4, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":599}]], "children":[{"name":"1-bit Select", "type":"resource", "count":3, "data":[3, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:601 > \\npipes.hpp:82", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":601}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_SignalGenerator.B8", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}, {"name":"kernel_Product_class", "compute_units":1, "type":"function", "total_percent":[2.58366, 1.58263, 1.13735, 0, 4.21607], "total_kernel_resources":[11442, 19435, 0, 64, 104], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'Z_pipe_base\' (sgemm.sycl.h:621)", "type":"resource", "data":[7, 36, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":621}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'Z_pipe_iter\' (sgemm.sycl.h:620)", "type":"resource", "data":[7, 36, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":620}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth"}]}, {"name":"kernel_Product_class.B0", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[13, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:624", "type":"resource", "data":[13, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":624}]]}]}]}, {"name":"kernel_Product_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[2126, 4111, 0, 0, 30], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[2126, 4111, 0, 0, 30]}]}, {"name":"Feedback", "type":"resource", "data":[486, 1897, 0, 0, 56], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[0, 0, 0, 0, 56]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:616", "type":"resource", "data":[18, 72, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":616}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:617", "type":"resource", "data":[114.5, 450.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":617}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:618", "type":"resource", "data":[6.67949, 0.230769, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":618}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:619", "type":"resource", "data":[13.1795, 3.73077, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":619}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:620", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":620}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:621", "type":"resource", "data":[1.33333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":621}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:644", "type":"resource", "data":[88, 346, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":644}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:644 > \\npipe_wrapper.hpp:33 > pipes.hpp:74", "type":"resource", "data":[90, 418, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":644}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":74}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:645 > \\npipe_wrapper.hpp:33 > pipes.hpp:74", "type":"resource", "data":[98.5, 450.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":645}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":74}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:664 > \\nfpga_reg.hpp:23", "type":"resource", "data":[4.61538, 2.07692, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":664}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":23}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:665 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:668 > fpga_reg.hpp:25", "type":"resource", "data":[10.3718, 3.69231, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":665}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":668}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":25}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:672 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:673", "type":"resource", "data":[28, 144, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":672}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":673}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:692 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:693 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:697 > \\nfpga_reg.hpp:25", "type":"resource", "data":[12.1538, 6.26923, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":692}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":693}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":697}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":25}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:700", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":700}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 12, 0, 0, 8], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[5257, 10505, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.fanout", "type":"resource", "count":9, "data":[9, 9, 0, 0, 0]}, {"name":"llvm.fpga.reg", "type":"resource", "count":328, "data":[5248, 10496, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:616", "type":"resource", "data":[64, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":616}]], "children":[{"name":"32-bit Select", "type":"resource", "count":4, "data":[64, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:617", "type":"resource", "data":[256, 80, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":617}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[256, 80, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:618", "type":"resource", "data":[0.153846, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":618}]], "children":[{"name":"5-bit Integer Subtract", "type":"resource", "count":1, "data":[0.128205, 0, 0, 0, 0]}, {"name":"5-bit Select", "type":"resource", "count":1, "data":[0.025641, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:619", "type":"resource", "data":[0.153846, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":619}]], "children":[{"name":"5-bit Integer Subtract", "type":"resource", "count":1, "data":[0.128205, 0, 0, 0, 0]}, {"name":"5-bit Select", "type":"resource", "count":1, "data":[0.025641, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:625 > \\npipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":625}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:629", "type":"resource", "data":[1, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":629}]], "children":[{"name":"8-bit Integer Compare", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:644", "type":"resource", "data":[192, 64, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":644}]], "children":[{"name":"32-bit Select", "type":"resource", "count":12, "data":[192, 64, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:644 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":644}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:644 > \\npipe_wrapper.hpp:33 > pipes.hpp:74", "type":"resource", "data":[256, 64, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":644}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":74}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[256, 64, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:645 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":645}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:645 > \\npipe_wrapper.hpp:33 > pipes.hpp:74", "type":"resource", "data":[256, 80, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":645}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":74}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[256, 80, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:664 > \\nfpga_reg.hpp:23", "type":"resource", "data":[1.38462, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":664}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":23}]], "children":[{"name":"5-bit Integer Subtract", "type":"resource", "count":9, "data":[1.15385, 0, 0, 0, 0]}, {"name":"5-bit Select", "type":"resource", "count":9, "data":[0.230769, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:664 > \\nfpga_reg.hpp:25", "type":"resource", "data":[512, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":664}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":25}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[512, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:665 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:666", "type":"resource", "data":[0, 0, 0, 64, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":665}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":666}]], "children":[{"name":"32-bit Floating-point Dot Product of Size 4", "type":"resource", "count":128, "data":[0, 0, 0, 64, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:665 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:668 > fpga_reg.hpp:25", "type":"resource", "data":[2.46154, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":665}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":668}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":25}]], "children":[{"name":"5-bit Integer Subtract", "type":"resource", "count":16, "data":[2.05128, 0, 0, 0, 0]}, {"name":"5-bit Select", "type":"resource", "count":16, "data":[0.410256, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:672 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:673", "type":"resource", "data":[416, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":647}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":648}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":672}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":673}]], "children":[{"name":"32-bit Select", "type":"resource", "count":13, "data":[416, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:679", "type":"resource", "data":[32, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":679}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:683 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:685 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:686", "type":"resource", "data":[160, 128, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":683}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":685}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":686}]], "children":[{"name":"32-bit Select", "type":"resource", "count":3, "data":[96, 0, 0, 0, 0]}, {"name":"llvm.fpga.reg", "type":"resource", "count":4, "data":[64, 128, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:689", "type":"resource", "data":[35, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":689}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:690 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":690}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:692 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:693 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:697 > \\nfpga_reg.hpp:25", "type":"resource", "data":[1.84615, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":692}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":693}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":697}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp", "line":25}]], "children":[{"name":"5-bit Integer Subtract", "type":"resource", "count":12, "data":[1.53846, 0, 0, 0, 0]}, {"name":"5-bit Select", "type":"resource", "count":12, "data":[0.307692, 0, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"kernel_cLoader_class", "compute_units":1, "type":"function", "total_percent":[0.661317, 0.370201, 0.317825, 0.589753, 0], "total_kernel_resources":[2703, 5431, 16, 0, 23], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:851)", "type":"resource", "data":[25, 142, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":851}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:853)", "type":"resource", "data":[7, 37, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":853}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:855)", "type":"resource", "data":[7, 11, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":855}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:854)", "type":"resource", "data":[11, 72, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":854}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 2 depth"}]}, {"name":"kernel_cLoader_class.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[131, 353, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[131, 258, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[0, 67, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[0, 27, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:856", "type":"resource", "data":[0, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":856}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[137, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":3, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":2, "data":[35, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[137, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":3, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":2, "data":[35, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:856", "type":"resource", "data":[30, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":856}]], "children":[{"name":"32-bit Floating-point Compare", "type":"resource", "count":1, "data":[30, 3, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_cLoader_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[4, 37, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[4, 37, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[9, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:851", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":851}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:851", "type":"resource", "data":[49, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":851}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[12.5, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[1.5, 0.5, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[0.5, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:855", "type":"resource", "data":[48, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_cLoader_class.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[20, 69, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[20, 69, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[34, 24, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:851", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":851}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[22, 16, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[10, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 4], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:851", "type":"resource", "data":[33, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":851}]], "children":[{"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[11.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_cLoader_class.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[69, 104, 1, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[69, 104, 1, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[33, 22, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:851", "type":"resource", "data":[1.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":851}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[18.3333, 12.3333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[10.3333, 7.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:855", "type":"resource", "data":[2.33333, 2.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:864", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":864}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 6], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:853", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:854", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:855", "type":"resource", "data":[2.33333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:857 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":857}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:858", "type":"resource", "data":[127, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":858}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:859", "type":"resource", "data":[126, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":859}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:860", "type":"resource", "data":[126, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":860}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:861", "type":"resource", "data":[126, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":861}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"kernel_cLoader_class.B6", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}, {"name":"kernel_Out_class", "compute_units":1, "type":"function", "total_percent":[0.511193, 0.343282, 0.201955, 0, 0.527009], "total_kernel_resources":[2333, 3451, 0, 8, 30], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:877)", "type":"resource", "data":[7, 37, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":877}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:879)", "type":"resource", "data":[7, 11, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":879}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:878)", "type":"resource", "data":[11, 72, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":878}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 2 depth"}]}, {"name":"kernel_Out_class.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[131, 327, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[131, 258, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[0, 67.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[0, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:881", "type":"resource", "data":[0, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":881}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[203.5, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[105, 3, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":3, "data":[66, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[71.5, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:881", "type":"resource", "data":[30, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":881}]], "children":[{"name":"32-bit Floating-point Compare", "type":"resource", "count":1, "data":[30, 3, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_Out_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 1, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 1, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[8, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[45, 33, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 33, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_Out_class.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[3, 36, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 36, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[21, 16, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[16, 12, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[5, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[44.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_Out_class.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[197, 338, 0, 0, 9], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[197, 338, 0, 0, 9]}]}, {"name":"Feedback", "type":"resource", "data":[24, 17, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[14.3333, 9.83333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[6.33333, 4.83333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:879", "type":"resource", "data":[3.33333, 2.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":879}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 12, 0, 0, 8], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:877", "type":"resource", "data":[1.33333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[1.33333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:878", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:879", "type":"resource", "data":[2.33333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":879}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":881}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":2, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\ntypes.hpp:1051", "type":"resource", "data":[0, 0, 0, 2, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":881}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp", "line":1051}]], "children":[{"name":"32-bit Floating-point Multiply-Add", "type":"resource", "count":4, "data":[0, 0, 0, 2, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\ntypes.hpp:1053", "type":"resource", "data":[128, 96, 0, 6, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":881}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp", "line":1053}]], "children":[{"name":"32-bit Floating-point Multiply", "type":"resource", "count":4, "data":[0, 0, 0, 4, 0]}, {"name":"32-bit Floating-point Multiply-Add", "type":"resource", "count":4, "data":[0, 0, 0, 2, 0]}, {"name":"32-bit Select", "type":"resource", "count":4, "data":[128, 96, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:882 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":882}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_Out_class.B6", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}, {"name":"kernel_unloader_class", "compute_units":1, "type":"function", "total_percent":[0.721318, 0.427317, 0.328652, 0, 0], "total_kernel_resources":[2531, 5616, 0, 0, 56], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:973)", "type":"resource", "data":[25, 142, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":973}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:975)", "type":"resource", "data":[7, 37, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":975}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:977)", "type":"resource", "data":[7, 11, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":977}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:976)", "type":"resource", "data":[11, 72, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":976}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 33 width by 2 depth"}]}, {"name":"kernel_unloader_class.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[131, 352, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[131, 258, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[0, 67, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[0, 27, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[137, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":3, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":2, "data":[35, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[137, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":3, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":2, "data":[35, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_unloader_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[4, 37, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[4, 37, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[9, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:973", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":973}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:973", "type":"resource", "data":[49, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":973}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[12.5, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[1.5, 0.5, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[0.5, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:977", "type":"resource", "data":[48, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_unloader_class.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[20, 69, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[20, 69, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[34, 24, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:973", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":973}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[22, 16, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[10, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 4], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:973", "type":"resource", "data":[33, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":973}]], "children":[{"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[11.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_unloader_class.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[72, 127, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[72, 127, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[33, 22, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:973", "type":"resource", "data":[1.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":973}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[18.3333, 12.3333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[10.3333, 7.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:977", "type":"resource", "data":[2.33333, 2.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:983", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":983}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 12, 0, 0, 8], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:975", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:976", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:977", "type":"resource", "data":[2.33333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:978 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":978}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:979", "type":"resource", "data":[88.75, 565, 0, 0, 7.75], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":979}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[88.75, 565, 0, 0, 7.75], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:980", "type":"resource", "data":[88.75, 565, 0, 0, 7.75], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":980}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[88.75, 565, 0, 0, 7.75], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:981", "type":"resource", "data":[88.75, 565, 0, 0, 7.75], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":981}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[88.75, 565, 0, 0, 7.75], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:982", "type":"resource", "data":[88.75, 565, 0, 0, 7.75], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":982}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[88.75, 565, 0, 0, 7.75], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"kernel_unloader_class.B6", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}, {"name":"kernel_aLoader_class", "compute_units":1, "type":"function", "total_percent":[2.32861, 1.63179, 0.86786, 1.5481, 0.724638], "total_kernel_resources":[12302, 14830, 42, 11, 82], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"text", "text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:", "details":[{"type":"text", "text":"%L with depth 4", "links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"294"}]}]}, {"type":"brief", "text":"1 compute unit.\\n1 loop nested 3 levels deep or more."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:289)", "type":"resource", "data":[67, 347, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":289}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"2 registers of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 32 bits and depth 4", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n2 regs, 32 width by 1 depth,\\n1 reg, 32 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:291)", "type":"resource", "data":[14, 73, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":291}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:292)", "type":"resource", "data":[22, 142, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":292}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:293)", "type":"resource", "data":[14, 73, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":293}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 33 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'kk_ii_iii\' (sgemm.sycl.h:294)", "type":"resource", "data":[14, 47, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":294}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"kernel_aLoader_class.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[130, 384, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[130, 290, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[0, 67.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[0, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:296", "type":"resource", "data":[0, 26, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":296}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[203.5, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[105, 3, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":3, "data":[66, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[71.5, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_aLoader_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[71, 135, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[71, 135, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[32, 40, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[24, 33, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[33, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]], "children":[{"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[71, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_aLoader_class.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[173, 316, 0, 0, 4], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[173, 316, 0, 0, 4]}]}, {"name":"Feedback", "type":"resource", "data":[71, 172, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[14, 70, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[28, 20, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[5, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[12, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:297", "type":"resource", "data":[12, 70, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":297}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 15], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[49, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[0.833333, 0.333333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.333333, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[77.8333, 1.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.333333, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[31, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:293", "type":"resource", "data":[71.3333, 1.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0.333333, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:294", "type":"resource", "data":[42, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[26, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[11, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:296", "type":"resource", "data":[32, 0, 0, 2, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":296}]], "children":[{"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[32, 0, 0, 2, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_aLoader_class.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[156, 301, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[156, 301, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[98, 217, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[14, 54, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[25, 16.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[9, 6.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:293", "type":"resource", "data":[14, 40, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:294", "type":"resource", "data":[4, 18, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[16, 10, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:296", "type":"resource", "data":[8, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":296}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:297", "type":"resource", "data":[8, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":297}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 27], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[11, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:293", "type":"resource", "data":[11.3333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_aLoader_class.B7", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[4057, 7392, 12, 0, 23], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[4057, 7392, 12, 0, 23]}]}, {"name":"Feedback", "type":"resource", "data":[129, 284, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[13.5, 54, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[30.25, 27.0833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[12.25, 11.0833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:293", "type":"resource", "data":[15.75, 43.0833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:294", "type":"resource", "data":[6.75, 19.75, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[26, 21, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:296", "type":"resource", "data":[8, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":296}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:297", "type":"resource", "data":[16, 72, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":297}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:304", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":304}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[12, 10, 11, 0, 0], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit Select", "type":"resource", "count":2, "data":[2, 1, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:289", "type":"resource", "data":[32, 32, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":289}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 32, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:291", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:292", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:293", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:294", "type":"resource", "data":[2.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:295", "type":"resource", "data":[2, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":295}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:296", "type":"resource", "data":[4351, 275, 4, 9, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":296}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[30, 0, 0, 0, 0]}, {"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[32, 0, 0, 2, 0]}, {"name":"32-bit Signed Integer Divide", "type":"resource", "count":1, "data":[1240, 212, 4, 7, 0]}, {"name":"32-bit Signed Integer Remainder", "type":"resource", "count":1, "data":[3049, 63, 0, 0, 0], "details":[{"type":"text", "text":"Implemented using inlined soft-IP."}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:297", "type":"resource", "data":[133, 35, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":297}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[30, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Or", "type":"resource", "count":1, "data":[32, 32, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:297 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":297}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:298", "type":"resource", "data":[160, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":298}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:299", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":299}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:300", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":300}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:301", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":301}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"kernel_aLoader_class.B8", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}, {"name":"kernel_aFeeder_class", "compute_units":1, "type":"function", "total_percent":[0.9122, 0.604401, 0.366632, 0, 0], "total_kernel_resources":[3384, 6265, 0, 0, 89], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1072, 2225, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Coalesced Private Variables: \\n - \'aFeeder_time_stamp_shreg\' (sgemm.sycl.h:319)\\n - \'aFeeder_cycle\' (sgemm.sycl.h:321)", "type":"resource", "data":[7, 36, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":319}], [{"filename":"sgemm.sycl.h", "line":321}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'aFeeder_channel_array\' (sgemm.sycl.h:317)", "type":"resource", "data":[316, 1356, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":317}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"16 registers of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n16 regs, 32 width by 1 depth"}]}, {"name":"sgemm.sycl.h:324 (DB)", "type":"resource", "data":[0, 0, 0, 0, 28], "debug":[[{"filename":"sgemm.sycl.h", "line":324}]], "details":[{"type":"table", "Private memory":"Stall-free", "Requested size":"2048 bytes", "Implemented size":"2048 bytes", "Memory Usage":"28 MLABs", "Number of banks":"4 (banked on bits 4, 5)", "Bank width":"128 bits", "Bank depth":"32 words", "Number of replicates":"1", "Number of private copies":"1", "Additional information":[{"type":"text", "text":"Requested size 2048 bytes, implemented size 2048 bytes, stall-free, 4 reads and 4 writes. "}, {"type":"text", "text":"Banked on bits 4, 5 into 4 separate banks."}, {"type":"text", "text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance."}, {"type":"text", "text":"Private memory implemented in on-chip block RAM."}], "Reference":[{"type":"text", "text":"See %L for more information.", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}, {"type":"brief", "text":"Stall-free,\\n2048B requested,\\n2048B implemented."}]}, {"name":"kernel_aFeeder_class.B0", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[13, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:323", "type":"resource", "data":[8, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":323}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:330", "type":"resource", "data":[5, 5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":330}]]}]}]}, {"name":"kernel_aFeeder_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[202, 302, 0, 0, 24], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[202, 302, 0, 0, 24]}]}, {"name":"Feedback", "type":"resource", "data":[24, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:317", "type":"resource", "data":[11, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":317}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:321", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":321}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:351", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 12, 0, 0, 27], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[386, 770, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.fanout", "type":"resource", "count":2, "data":[2, 2, 0, 0, 0]}, {"name":"llvm.fpga.reg", "type":"resource", "count":24, "data":[384, 768, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:331 > \\npipe_wrapper.hpp:33 > pipes.hpp:67", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":331}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":33}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "children":[{"name":"Pipe Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:340 > types.hpp:789", "type":"resource", "data":[256, 512, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":340}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp", "line":789}]], "children":[{"name":"llvm.fpga.reg", "type":"resource", "count":16, "data":[256, 512, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:347", "type":"resource", "data":[4, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":347}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[4, 4, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:348", "type":"resource", "data":[136, 96, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":348}]], "children":[{"name":"Store", "type":"resource", "count":4, "data":[136, 96, 0, 0, 0], "details":[{"type":"text", "text":"Store uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free write to memory declared on %L.", "links":[{"filename":"sgemm.sycl.h", "line":"324"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:350", "type":"resource", "data":[140, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":350}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[140, 4, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:351", "type":"resource", "data":[808, 932, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":332}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":74}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp", "line":56}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]], "children":[{"name":"32-bit Select", "type":"resource", "count":16, "data":[512, 384, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":4, "data":[296, 548, 0, 0, 0], "details":[{"type":"text", "text":"Load uses a Pipelined never-stall LSU"}, {"type":"brief", "text":"Pipelined never-stall LSU"}, {"type":"text", "text":"Stall-free read from memory declared on %L.", "links":[{"filename":"sgemm.sycl.h", "line":"324"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:355 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":355}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"kernel_bLoader_class", "compute_units":1, "type":"function", "total_percent":[2.0304, 1.39841, 0.775398, 1.25323, 0.131752], "total_kernel_resources":[10568, 13250, 34, 2, 69], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"text", "text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:", "details":[{"type":"text", "text":"%L with depth 4", "links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"519"}]}]}, {"type":"brief", "text":"1 compute unit.\\n1 loop nested 3 levels deep or more."}], "children":[{"name":"Function overhead", "type":"resource", "data":[1338, 2411, 0, 0, 10], "details":[{"type":"text", "text":"Kernel dispatch logic."}, {"type":"brief", "text":"Kernel dispatch logic."}]}, {"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:514)", "type":"resource", "data":[67, 347, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":514}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"2 registers of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 32 bits and depth 4", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n2 regs, 32 width by 1 depth,\\n1 reg, 32 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:516)", "type":"resource", "data":[14, 73, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":516}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 1", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:517)", "type":"resource", "data":[22, 142, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":517}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"text", "text":"1 register of width 33 bits and depth 2", "details":[{"type":"text", "text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2."}]}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth"}]}, {"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:518)", "type":"resource", "data":[14, 73, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":518}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"text", "text":"1 register of width 33 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth"}]}, {"name":"Private Variable: \\n - \'kk_jj_jjj\' (sgemm.sycl.h:519)", "type":"resource", "data":[14, 47, 0, 0, 0], "debug":[[{"filename":"sgemm.sycl.h", "line":519}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 7 bits and depth 1"}, {"type":"text", "text":"1 register of width 32 bits and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth"}]}, {"name":"kernel_bLoader_class.B0", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[130, 384, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[130, 290, 0, 0, 0]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[0, 67.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[0, 0.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:521", "type":"resource", "data":[0, 26, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":521}]]}]}, {"name":"Feedback", "type":"resource", "data":[7, 2, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[7, 2, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[203.5, 3, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":4, "data":[105, 3, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":3, "data":[66, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[71.5, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.5, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_bLoader_class.B1", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[55, 103, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[55, 103, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[32, 40, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[24, 33, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[33, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]], "children":[{"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[71, 1, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_bLoader_class.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[151, 281, 0, 0, 2], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[151, 281, 0, 0, 2]}]}, {"name":"Feedback", "type":"resource", "data":[59, 102, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[14, 70, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[28, 20, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[5, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[12, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 12], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[49, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"33-bit Select", "type":"resource", "count":1, "data":[33, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[0.833333, 0.333333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.333333, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[77.8333, 1.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[0.833333, 0.333333, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[31, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:518", "type":"resource", "data":[71.3333, 1.33333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0.333333, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[32, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[35, 1, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:519", "type":"resource", "data":[42, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[26, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[11, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:521", "type":"resource", "data":[32, 0, 0, 2, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":521}]], "children":[{"name":"32-bit Integer Multiply", "type":"resource", "count":1, "data":[32, 0, 0, 2, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_bLoader_class.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[124, 237, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[124, 237, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[90, 181, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[14, 54, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[25, 16.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[9, 6.5, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:518", "type":"resource", "data":[6, 4, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:519", "type":"resource", "data":[4, 18, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[16, 10, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:521", "type":"resource", "data":[8, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":521}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:522", "type":"resource", "data":[8, 36, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":522}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[8, 6, 0, 0, 22], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[11, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"32-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:518", "type":"resource", "data":[11.3333, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"33-bit Integer Compare", "type":"resource", "count":1, "data":[11, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"kernel_bLoader_class.B7", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[3496, 6236, 10, 0, 21], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3496, 6236, 10, 0, 21]}]}, {"name":"Feedback", "type":"resource", "data":[136, 307, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[13.5, 54, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[29.9167, 26.0833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[11.9167, 10.0833, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:518", "type":"resource", "data":[7.41667, 6.08333, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:519", "type":"resource", "data":[6.75, 19.75, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[25, 18, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:521", "type":"resource", "data":[25, 101, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":521}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:522", "type":"resource", "data":[16, 72, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":522}]]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:529", "type":"resource", "data":[0.5, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":529}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[12, 10, 9, 0, 0], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit Select", "type":"resource", "count":2, "data":[2, 1, 0, 0, 0]}]}, {"name":"handler.hpp:1166 > sgemm.sycl.h:514", "type":"resource", "data":[32, 32, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":514}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 32, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:516", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:517", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:518", "type":"resource", "data":[0.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:519", "type":"resource", "data":[2.25, 0, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.25, 0, 0, 0, 0]}, {"name":"7-bit Integer Compare", "type":"resource", "count":1, "data":[2, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:520", "type":"resource", "data":[2, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":520}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:521", "type":"resource", "data":[3261, 63, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":521}]], "children":[{"name":"32-bit Signed Integer Remainder", "type":"resource", "count":1, "data":[3261, 63, 0, 0, 0], "details":[{"type":"text", "text":"Implemented using inlined soft-IP."}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:522", "type":"resource", "data":[133, 35, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":522}]], "children":[{"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[30, 0, 0, 0, 0]}, {"name":"32-bit Integer Compare", "type":"resource", "count":2, "data":[70, 2, 0, 0, 0]}, {"name":"32-bit Or", "type":"resource", "count":1, "data":[32, 32, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:522 > \\npipe_wrapper.hpp:39 > pipes.hpp:82", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":522}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":39}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "children":[{"name":"Pipe Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:523", "type":"resource", "data":[160, 525.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":523}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Select", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:524", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":524}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:525", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":525}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}, {"name":"handler.hpp:1166 > sgemm.sycl.h:526", "type":"resource", "data":[158, 524.5, 3.75, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1166}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":526}]], "children":[{"name":"32-bit Select", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":1, "data":[126, 524.5, 3.75, 0, 0], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"kernel_bLoader_class.B8", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"handler.hpp:1170", "type":"resource", "data":[5, 8, 0, 0, 0], "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":1170}]]}]}]}]}]};
var area_srcJSON={"children":[{"children":[{"data":[134500,172452,397,0,0],"details":[{"text":"Platform interface logic.","type":"text"}],"name":"Board interface","type":"resource"}],"name":"Static Partition","type":"partition"},{"data":[12524,15522,104,0,0],"details":[{"text":"Global interconnect for 3 global loads and 1 global store. Reduce number of global loads and stores to simplify global interconnect.","type":"text"},{"text":"For 3 global loads and 1 global store.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Global Memory Interconnect","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/hnj1476724450050.html"}],"text":"See %L for more information","type":"text"}],"name":"Global interconnect","type":"resource"},{"data":[0,67,2,0,0],"details":[{"text":"This read-only memory contains information for the host about the system and about each kernel in the system, including kernel names, arguments, and attributes. The system description ROM ensures that the binary image on the FPGA is compatible with the host program.","type":"text"},{"text":"Contains information for the host.","type":"brief"}],"name":"System description ROM","type":"resource"},{"children":[{"data":[11,390,4,0,0],"details":[{"text":"Pipe is implemented 128 bits wide by 256 deep.","type":"text"},{"text":"128b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Out_channel_pipe, sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,390,4,0,0],"details":[{"text":"Pipe is implemented 128 bits wide by 256 deep.","type":"text"},{"text":"128b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Product_channel_pipe, sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,1542,13,0,0],"details":[{"text":"Pipe is implemented 512 bits wide by 256 deep.","type":"text"},{"text":"512b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,390,4,0,0],"details":[{"text":"Pipe is implemented 128 bits wide by 256 deep.","type":"text"},{"text":"128b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aLoader_channel_pipe, sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,1542,13,0,0],"details":[{"text":"Pipe is implemented 512 bits wide by 256 deep.","type":"text"},{"text":"512b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,390,4,0,0],"details":[{"text":"Pipe is implemented 128 bits wide by 256 deep.","type":"text"},{"text":"128b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bLoader_channel_pipe, sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,390,4,0,0],"details":[{"text":"Pipe is implemented 128 bits wide by 256 deep.","type":"text"},{"text":"128b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::cLoader_channel_pipe, sycl::_V1::vec<float, 4>)","type":"resource"},{"data":[11,102,1,0,0],"details":[{"text":"Pipe is implemented 32 bits wide by 256 deep.","type":"text"},{"text":"32b wide by 256 deep.","type":"brief"},{"links":[{"guide":"Best Practices Guide : Channels","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}],"text":"See %L for more information","type":"text"}],"name":"Pipe (sycl::_V1::ext::intel::pipe<t2sp::sgemm::_SignalGenerator_channel_pipe, t2sp::sgemm::signals_t, 256>)","type":"resource"}],"data":[88,5136,47,0,0],"name":"Pipe resources","type":"group"},{"children":[{"data":[53,26,0,0,27],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1072,2225,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[7,36,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Coalesced Private Variables: \\n - \'bFeeder_time_stamp_shreg\' (sgemm.sycl.h:544)\\n - \'bFeeder_cycle\' (sgemm.sycl.h:546)","type":"resource"},{"data":[299,1291,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"16 registers of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n16 regs, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'bFeeder_channel_array\' (sgemm.sycl.h:542)","type":"resource"},{"data":[0,0,0,0,28],"details":[{"Additional information":[{"text":"Requested size 2048 bytes, implemented size 2048 bytes, stall-free, 4 reads and 4 writes. ","type":"text"},{"text":"Banked on bits 4, 5 into 4 separate banks.","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"},{"text":"Private memory implemented in on-chip block RAM.","type":"text"}],"Bank depth":"32 words","Bank width":"128 bits","Implemented size":"2048 bytes","Memory Usage":"28 MLABs","Number of banks":"4 (banked on bits 4, 5)","Number of private copies":"1","Number of replicates":"1","Private memory":"Stall-free","Reference":[{"links":[{"guide":"Best Practices Guide : Local Memory","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}],"text":"See %L for more information.","type":"text"}],"Requested size":"2048 bytes","type":"table"},{"text":"Stall-free,\\n2048B requested,\\n2048B implemented.","type":"brief"}],"name":"sgemm.sycl.h:549 (DB)","type":"resource"},{"children":[{"count":"1","data":[223,340,0,0,24],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,2,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.fanout","type":"resource"},{"count":24,"data":[384,768,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[609,1110,0,0,24],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":556},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:556 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[256,512,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[256,512,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":557},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":565},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp","line":789}]],"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:565 > types.hpp:789","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[4,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[4,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":557},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":572}]],"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:572","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[136,96,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[136,96,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":557},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":573}]],"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:573","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[140,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[140,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":557},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":575}]],"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:575","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[512,352,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":4,"data":[296,548,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[808,900,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":557},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":576}]],"name":"handler.hpp:1166 > sgemm.sycl.h:557 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:576","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":580},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:580 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"}],"data":[1348,1517,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","replace_name":"true","type":"resource"}],"compute_units":1,"data":[3388,6205,0,0,89],"debug":[[{"filename":"sgemm.sycl.h","line":542}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_bFeeder_class","total_kernel_resources":[3388,6205,0,0,89],"total_percent":[0.908732,0.604869,0.36312,0,0],"type":"function"},{"children":[{"data":[200,149,0,0,7],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[14,73,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:592)","type":"resource"},{"data":[11,72,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:593)","type":"resource"},{"data":[22,142,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:594)","type":"resource"},{"data":[14,47,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'kk_ii_jj\' (sgemm.sycl.h:595)","type":"resource"},{"children":[{"count":5,"data":[330,662,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[330,662,0,0,0],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,100.833,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":6,"data":[2.916666,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":5,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":5,"data":[140,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":4,"data":[97,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"},{"count":1,"data":[33,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[315.916666,105.333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":592}]],"name":"handler.hpp:1166 > sgemm.sycl.h:592","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,0.833333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":5,"data":[1.916666,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"},{"count":1,"data":[33,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[116.916666,2.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":593}]],"name":"handler.hpp:1166 > sgemm.sycl.h:593","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":3,"data":[0.916666,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"},{"count":1,"data":[33,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[115.916666,1.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":594}]],"name":"handler.hpp:1166 > sgemm.sycl.h:594","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[71,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":596}]],"name":"handler.hpp:1166 > sgemm.sycl.h:596","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[20,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"}],"data":[21,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":597}]],"name":"handler.hpp:1166 > sgemm.sycl.h:597","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[55,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"}],"data":[92,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":598}]],"name":"handler.hpp:1166 > sgemm.sycl.h:598","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[2.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":595}]],"name":"handler.hpp:1166 > sgemm.sycl.h:595","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[3,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[4,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":599}]],"name":"handler.hpp:1166 > sgemm.sycl.h:599","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":601},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:601 > \\npipes.hpp:82","replace_name":true,"type":"resource"}],"data":[742.999566,115.999666,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[2671.999566,3671.999666,0,0,17],"debug":[[{"filename":"sgemm.sycl.h","line":592}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"details":[{"links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":"595"}],"text":"%L with depth 4","type":"text"}],"text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:","type":"text"},{"text":"1 compute unit.\\n1 loop nested 3 levels deep or more.","type":"brief"}],"name":"kernel_SignalGenerator","total_kernel_resources":[2672,3672,0,0,17],"total_percent":[0.533205,0.352528,0.214888,0,0],"type":"function"},{"children":[{"data":[515,1916,0,0,64],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[7,36,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'Z_pipe_base\' (sgemm.sycl.h:621)","type":"resource"},{"data":[7,36,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'Z_pipe_iter\' (sgemm.sycl.h:620)","type":"resource"},{"children":[{"count":"1","data":[2126,4111,0,0,30],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":9,"data":[9,9,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.fanout","type":"resource"},{"count":328,"data":[5248,10496,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[7383,14616,0,0,30],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":4,"data":[64,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[64,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":616}]],"name":"handler.hpp:1166 > sgemm.sycl.h:616","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[256,80,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[256,80,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":617}]],"name":"handler.hpp:1166 > sgemm.sycl.h:617","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.128205,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Integer Subtract","type":"resource"},{"count":1,"data":[0.025641,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Select","type":"resource"}],"data":[0.153846,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":618}]],"name":"handler.hpp:1166 > sgemm.sycl.h:618","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.128205,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Integer Subtract","type":"resource"},{"count":1,"data":[0.025641,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Select","type":"resource"}],"data":[0.153846,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":619}]],"name":"handler.hpp:1166 > sgemm.sycl.h:619","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":625},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:625 > \\npipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"8-bit Integer Compare","type":"resource"}],"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":629}]],"name":"handler.hpp:1166 > sgemm.sycl.h:629","replace_name":true,"type":"resource"},{"children":[{"count":12,"data":[192,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[192,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":644}]],"name":"handler.hpp:1166 > sgemm.sycl.h:644","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":644},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:644 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[256,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[256,64,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":644},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":74}]],"name":"handler.hpp:1166 > sgemm.sycl.h:644 > \\npipe_wrapper.hpp:33 > pipes.hpp:74","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":645},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:645 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[256,80,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[256,80,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":645},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":74}]],"name":"handler.hpp:1166 > sgemm.sycl.h:645 > \\npipe_wrapper.hpp:33 > pipes.hpp:74","replace_name":true,"type":"resource"},{"children":[{"count":9,"data":[1.15385,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Integer Subtract","type":"resource"},{"count":9,"data":[0.230769,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Select","type":"resource"}],"data":[1.38462,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":647},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":648},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":664},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp","line":23}]],"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:664 > \\nfpga_reg.hpp:23","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[512,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[512,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":647},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":648},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":664},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp","line":25}]],"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:664 > \\nfpga_reg.hpp:25","replace_name":true,"type":"resource"},{"children":[{"count":128,"data":[0,0,0,64,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Dot Product of Size 4","type":"resource"}],"data":[0,0,0,64,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":647},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":648},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":665},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":666}]],"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:665 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:666","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[2.05128,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Integer Subtract","type":"resource"},{"count":16,"data":[0.410256,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Select","type":"resource"}],"data":[2.46154,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":647},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":648},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":665},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":668},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp","line":25}]],"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:665 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:668 > fpga_reg.hpp:25","replace_name":true,"type":"resource"},{"children":[{"count":13,"data":[416,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[416,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":647},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":648},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":672},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":673}]],"name":"handler.hpp:1166 > sgemm.sycl.h:647 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:648 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:672 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:673","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":679}]],"name":"handler.hpp:1166 > sgemm.sycl.h:679","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[96,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":4,"data":[64,128,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[160,128,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":683},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":685},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":686}]],"name":"handler.hpp:1166 > sgemm.sycl.h:683 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:685 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:686","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":689}]],"name":"handler.hpp:1166 > sgemm.sycl.h:689","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":690},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:690 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"},{"children":[{"count":12,"data":[1.53846,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Integer Subtract","type":"resource"},{"count":12,"data":[0.307692,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"5-bit Select","type":"resource"}],"data":[1.84615,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":692},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":693},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":697},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/fpga_reg.hpp","line":25}]],"name":"handler.hpp:1166 > sgemm.sycl.h:692 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:693 > unrolled_loop.hpp:74 > \\nunrolled_loop.hpp:56 > sgemm.sycl.h:697 > \\nfpga_reg.hpp:25","replace_name":true,"type":"resource"}],"data":[2192.000002,420,0,64,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","replace_name":"true","type":"resource"}],"compute_units":1,"data":[11442.000002,19435,0,64,104],"debug":[[{"filename":"sgemm.sycl.h","line":620}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_Product_class","total_kernel_resources":[11442,19435,0,64,104],"total_percent":[2.58366,1.58263,1.13735,0,4.21607],"type":"function"},{"children":[{"data":[120,87,0,0,13],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[25,142,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:851)","type":"resource"},{"data":[7,37,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:853)","type":"resource"},{"data":[7,11,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:855)","type":"resource"},{"data":[11,72,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:854)","type":"resource"},{"children":[{"count":4,"data":[224,468,1,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[224,468,1,0,0],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,67,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":4,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":4,"data":[2.333333,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[150.333333,69.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":853}]],"name":"handler.hpp:1166 > sgemm.sycl.h:853","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,27,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":3,"data":[1.333333,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[149.333333,29.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":854}]],"name":"handler.hpp:1166 > sgemm.sycl.h:854","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":1,"data":[30,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Compare","type":"resource"}],"data":[30,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":856}]],"name":"handler.hpp:1166 > sgemm.sycl.h:856","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[82,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":851}]],"name":"handler.hpp:1166 > sgemm.sycl.h:851","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[0.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[50.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":855}]],"name":"handler.hpp:1166 > sgemm.sycl.h:855","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":857},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:857 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[127,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":858}]],"name":"handler.hpp:1166 > sgemm.sycl.h:858","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":859}]],"name":"handler.hpp:1166 > sgemm.sycl.h:859","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":860}]],"name":"handler.hpp:1166 > sgemm.sycl.h:860","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":861}]],"name":"handler.hpp:1166 > sgemm.sycl.h:861","replace_name":true,"type":"resource"}],"data":[970.999996,2203,15,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[2702.999996,5431,16,0,23],"debug":[[{"filename":"sgemm.sycl.h","line":851}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_cLoader_class","total_kernel_resources":[2703,5431,16,0,23],"total_percent":[0.661317,0.370201,0.317825,0.589753,0],"type":"function"},{"children":[{"data":[105,80,0,0,11],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[7,37,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:877)","type":"resource"},{"data":[7,11,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:879)","type":"resource"},{"data":[11,72,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:878)","type":"resource"},{"children":[{"count":4,"data":[332,633,0,0,9],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[332,633,0,0,9],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,67.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":5,"data":[3.33333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":4,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":4,"data":[105,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":3,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"},{"count":1,"data":[33,33,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[250.33333,103.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":877}]],"name":"handler.hpp:1166 > sgemm.sycl.h:877","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":3,"data":[1.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"},{"count":1,"data":[33,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[116.333333,1.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":878}]],"name":"handler.hpp:1166 > sgemm.sycl.h:878","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":1,"data":[30,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Compare","type":"resource"}],"data":[30,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":881}]],"name":"handler.hpp:1166 > sgemm.sycl.h:881","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[2.33333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":879}]],"name":"handler.hpp:1166 > sgemm.sycl.h:879","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":881},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[0,0,0,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Multiply-Add","type":"resource"}],"data":[0,0,0,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":881},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp","line":1051}]],"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\ntypes.hpp:1051","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[0,0,0,4,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Multiply","type":"resource"},{"count":4,"data":[0,0,0,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Floating-point Multiply-Add","type":"resource"},{"count":4,"data":[128,96,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[128,96,0,6,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":881},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp","line":1053}]],"name":"handler.hpp:1166 > sgemm.sycl.h:881 > \\ntypes.hpp:1053","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":882},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:882 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"}],"data":[532.999993,207,0,8,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[2332.999993,3451,0,8,30],"debug":[[{"filename":"sgemm.sycl.h","line":877}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_Out_class","total_kernel_resources":[2333,3451,0,8,30],"total_percent":[0.511193,0.343282,0.201955,0,0.527009],"type":"function"},{"children":[{"data":[128,93,0,0,15],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[25,142,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:973)","type":"resource"},{"data":[7,37,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:975)","type":"resource"},{"data":[7,11,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'iii_ii_jj\' (sgemm.sycl.h:977)","type":"resource"},{"data":[11,72,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:976)","type":"resource"},{"children":[{"count":4,"data":[227,491,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"}],"data":[227,491,0,0,0],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,67,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":4,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":4,"data":[2.333333,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[150.333333,69.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":975}]],"name":"handler.hpp:1166 > sgemm.sycl.h:975","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,27,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":3,"data":[1.333333,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[149.333333,29.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":976}]],"name":"handler.hpp:1166 > sgemm.sycl.h:976","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"}],"data":[82,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":973}]],"name":"handler.hpp:1166 > sgemm.sycl.h:973","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[0.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[50.333333,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":977}]],"name":"handler.hpp:1166 > sgemm.sycl.h:977","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":978},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:978 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":979}]],"name":"handler.hpp:1166 > sgemm.sycl.h:979","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":980}]],"name":"handler.hpp:1166 > sgemm.sycl.h:980","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":981}]],"name":"handler.hpp:1166 > sgemm.sycl.h:981","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[88.75,565,0,0,7.75],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":982}]],"name":"handler.hpp:1166 > sgemm.sycl.h:982","replace_name":true,"type":"resource"}],"data":[787.999996,2359,0,0,31],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[2530.999996,5616,0,0,56],"debug":[[{"filename":"sgemm.sycl.h","line":973}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_unloader_class","total_kernel_resources":[2531,5616,0,0,56],"total_percent":[0.721318,0.427317,0.328652,0,0],"type":"function"},{"children":[{"data":[386,757,11,0,45],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[67,347,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"2 registers of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 4","type":"text"},{"text":"Register,\\n2 regs, 32 width by 1 depth,\\n1 reg, 32 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:289)","type":"resource"},{"data":[14,73,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:291)","type":"resource"},{"data":[22,142,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:292)","type":"resource"},{"data":[14,73,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:293)","type":"resource"},{"data":[14,47,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'kk_ii_iii\' (sgemm.sycl.h:294)","type":"resource"},{"children":[{"count":5,"data":[4587,8434,12,0,27],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Select","type":"resource"}],"data":[4600,8435,12,0,27],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,67.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":6,"data":[2.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":4,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":4,"data":[105,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":3,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[216.916666,70.833333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":291}]],"name":"handler.hpp:1166 > sgemm.sycl.h:291","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":5,"data":[1.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[149.916666,2.833333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":292}]],"name":"handler.hpp:1166 > sgemm.sycl.h:292","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,26,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":2,"data":[64,0,0,4,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Multiply","type":"resource"},{"count":1,"data":[30,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[1240,212,4,7,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Signed Integer Divide","type":"resource"},{"count":1,"data":[3049,63,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Signed Integer Remainder","type":"resource"}],"data":[4383,301,4,11,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":296}]],"name":"handler.hpp:1166 > sgemm.sycl.h:296","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"},{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[32,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[114,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":289}]],"name":"handler.hpp:1166 > sgemm.sycl.h:289","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[46,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"}],"data":[85,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":295}]],"name":"handler.hpp:1166 > sgemm.sycl.h:295","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[0.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[82.916633,1.33333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":293}]],"name":"handler.hpp:1166 > sgemm.sycl.h:293","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[26,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[0.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[44.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":294}]],"name":"handler.hpp:1166 > sgemm.sycl.h:294","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[30,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[32,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Or","type":"resource"}],"data":[133,35,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":297}]],"name":"handler.hpp:1166 > sgemm.sycl.h:297","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":297},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:297 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[160,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":298}]],"name":"handler.hpp:1166 > sgemm.sycl.h:298","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":299}]],"name":"handler.hpp:1166 > sgemm.sycl.h:299","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":300}]],"name":"handler.hpp:1166 > sgemm.sycl.h:300","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":301}]],"name":"handler.hpp:1166 > sgemm.sycl.h:301","replace_name":true,"type":"resource"}],"data":[5846.999899,2544.999993,19,11,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[12301.999899,14829.999993,42,11,82],"debug":[[{"filename":"sgemm.sycl.h","line":289}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"details":[{"links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":"294"}],"text":"%L with depth 4","type":"text"}],"text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:","type":"text"},{"text":"1 compute unit.\\n1 loop nested 3 levels deep or more.","type":"brief"}],"name":"kernel_aLoader_class","total_kernel_resources":[12302,14830,42,11,82],"total_percent":[2.32861,1.63179,0.86786,1.5481,0.724638],"type":"function"},{"children":[{"data":[53,26,0,0,27],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1072,2225,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[7,36,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Coalesced Private Variables: \\n - \'aFeeder_time_stamp_shreg\' (sgemm.sycl.h:319)\\n - \'aFeeder_cycle\' (sgemm.sycl.h:321)","type":"resource"},{"data":[316,1356,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"16 registers of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n16 regs, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'aFeeder_channel_array\' (sgemm.sycl.h:317)","type":"resource"},{"data":[0,0,0,0,28],"details":[{"Additional information":[{"text":"Requested size 2048 bytes, implemented size 2048 bytes, stall-free, 4 reads and 4 writes. ","type":"text"},{"text":"Banked on bits 4, 5 into 4 separate banks.","type":"text"},{"text":"Reducing accesses to exactly one read and one write for all on-chip memory systems may increase overall system performance.","type":"text"},{"text":"Private memory implemented in on-chip block RAM.","type":"text"}],"Bank depth":"32 words","Bank width":"128 bits","Implemented size":"2048 bytes","Memory Usage":"28 MLABs","Number of banks":"4 (banked on bits 4, 5)","Number of private copies":"1","Number of replicates":"1","Private memory":"Stall-free","Reference":[{"links":[{"guide":"Best Practices Guide : Local Memory","link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}],"text":"See %L for more information.","type":"text"}],"Requested size":"2048 bytes","type":"table"},{"text":"Stall-free,\\n2048B requested,\\n2048B implemented.","type":"brief"}],"name":"sgemm.sycl.h:324 (DB)","type":"resource"},{"children":[{"count":"1","data":[202,302,0,0,24],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,2,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.fanout","type":"resource"},{"count":24,"data":[384,768,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[588,1072,0,0,24],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":331},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":33},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":67}]],"name":"handler.hpp:1166 > sgemm.sycl.h:331 > \\npipe_wrapper.hpp:33 > pipes.hpp:67","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[256,512,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"llvm.fpga.reg","type":"resource"}],"data":[256,512,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":332},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":340},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/types.hpp","line":789}]],"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:340 > types.hpp:789","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[4,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[4,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":332},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":347}]],"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:347","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[136,96,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Store","type":"resource"}],"data":[136,96,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":332},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":348}]],"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:348","replace_name":true,"type":"resource"},{"children":[{"count":4,"data":[140,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"}],"data":[140,4,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":332},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":350}]],"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:350","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[512,384,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":4,"data":[296,548,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[808,932,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":332},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":74},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../../../../../include/unrolled_loop.hpp","line":56},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":351}]],"name":"handler.hpp:1166 > sgemm.sycl.h:332 > \\nunrolled_loop.hpp:74 > unrolled_loop.hpp:56 > \\nsgemm.sycl.h:351","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":355},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:355 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"}],"data":[1348,1550,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","replace_name":"true","type":"resource"}],"compute_units":1,"data":[3384,6265,0,0,89],"debug":[[{"filename":"sgemm.sycl.h","line":317}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"kernel_aFeeder_class","total_kernel_resources":[3384,6265,0,0,89],"total_percent":[0.9122,0.604401,0.366632,0,0],"type":"function"},{"children":[{"data":[373,674,9,0,36],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[1338,2411,0,0,10],"details":[{"text":"Kernel dispatch logic.","type":"text"},{"text":"Kernel dispatch logic.","type":"brief"}],"name":"Function overhead","type":"resource"},{"data":[67,347,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"2 registers of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 4","type":"text"},{"text":"Register,\\n2 regs, 32 width by 1 depth,\\n1 reg, 32 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'addr_temp\' (sgemm.sycl.h:514)","type":"resource"},{"data":[14,73,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 1","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'i\' (sgemm.sycl.h:516)","type":"resource"},{"data":[22,142,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 32 bits and depth 2","type":"text"},{"details":[{"text":" Depth was increased by a factor of 2 due to a loop initiation interval of 2.","type":"text"}],"text":"1 register of width 33 bits and depth 2","type":"text"},{"text":"Register,\\n1 reg, 32 width by 2 depth,\\n1 reg, 33 width by 2 depth","type":"brief"}],"name":"Private Variable: \\n - \'j\' (sgemm.sycl.h:517)","type":"resource"},{"data":[14,73,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"1 register of width 33 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 32 width by 1 depth,\\n1 reg, 33 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'k\' (sgemm.sycl.h:518)","type":"resource"},{"data":[14,47,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 7 bits and depth 1","type":"text"},{"text":"1 register of width 32 bits and depth 1","type":"text"},{"text":"Register,\\n1 reg, 7 width by 1 depth,\\n1 reg, 32 width by 1 depth","type":"brief"}],"name":"Private Variable: \\n - \'kk_jj_jjj\' (sgemm.sycl.h:519)","type":"resource"},{"children":[{"count":5,"data":[3956,7147,10,0,23],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Select","type":"resource"}],"data":[3969,7148,10,0,23],"name":"No Source Line","type":"resource"},{"children":[{"children":[{"count":"1","data":[0,67.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":6,"data":[2.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":4,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":4,"data":[105,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":3,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[216.916666,70.833333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":516}]],"name":"handler.hpp:1166 > sgemm.sycl.h:516","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,0.5,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":5,"data":[1.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":2,"data":[35,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[149.916666,2.833333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":517}]],"name":"handler.hpp:1166 > sgemm.sycl.h:517","replace_name":true,"type":"resource"},{"children":[{"count":"1","data":[0,26,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"State","type":"resource"},{"count":1,"data":[32,0,0,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Multiply","type":"resource"},{"count":1,"data":[3261,63,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Signed Integer Remainder","type":"resource"}],"data":[3293,89,0,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":521}]],"name":"handler.hpp:1166 > sgemm.sycl.h:521","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[66,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Select","type":"resource"},{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[32,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"}],"data":[114,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":514}]],"name":"handler.hpp:1166 > sgemm.sycl.h:514","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":3,"data":[46,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"}],"data":[85,3,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":520}]],"name":"handler.hpp:1166 > sgemm.sycl.h:520","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[0.916666,0.333333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":2,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[35,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[11,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"33-bit Integer Compare","type":"resource"}],"data":[82.916633,1.33333,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":518}]],"name":"handler.hpp:1166 > sgemm.sycl.h:518","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[26,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[0.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[2,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"7-bit Integer Compare","type":"resource"}],"data":[44.25,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":519}]],"name":"handler.hpp:1166 > sgemm.sycl.h:519","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[30,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Add","type":"resource"},{"count":2,"data":[70,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Integer Compare","type":"resource"},{"count":1,"data":[32,32,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Or","type":"resource"}],"data":[133,35,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":522}]],"name":"handler.hpp:1166 > sgemm.sycl.h:522","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Pipe Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":522},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp","line":39},{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp","line":82}]],"name":"handler.hpp:1166 > sgemm.sycl.h:522 > \\npipe_wrapper.hpp:39 > pipes.hpp:82","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"1-bit Select","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[160,525.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":523}]],"name":"handler.hpp:1166 > sgemm.sycl.h:523","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":524}]],"name":"handler.hpp:1166 > sgemm.sycl.h:524","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":525}]],"name":"handler.hpp:1166 > sgemm.sycl.h:525","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"32-bit Select","type":"resource"},{"count":1,"data":[126,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":"1166"}]],"name":"Load","type":"resource"}],"data":[158,524.5,3.75,0,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166},{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":526}]],"name":"handler.hpp:1166 > sgemm.sycl.h:526","replace_name":true,"type":"resource"}],"data":[4756.999899,2334.999993,15,2,0],"debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp","line":1166}]],"name":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp:1166","type":"resource"}],"compute_units":1,"data":[10567.999899,13249.999993,34,2,69],"debug":[[{"filename":"sgemm.sycl.h","line":514}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"details":[{"links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h","line":"519"}],"text":"%L with depth 4","type":"text"}],"text":"The following loop is nested at depth greater than 3. Reducing the depth of this nested loop will save area:","type":"text"},{"text":"1 compute unit.\\n1 loop nested 3 levels deep or more.","type":"brief"}],"name":"kernel_bLoader_class","total_kernel_resources":[10568,13250,34,2,69],"total_percent":[2.0304,1.39841,0.775398,1.25323,0.131752],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[63934.999351,98879.999652,245,85,559],"debug_enabled":"true","max_resources":[854400,1708800,2713,1518,42720],"name":"Kernel System","total":[198435,271332,642,85,559],"total_percent":[38.1236,24.5336,15.8785,23.6638,5.59947],"type":"module"};
var mavJSON={"nodes":[{"type":"kernel", "id":2, "name":"kernel_aLoader_class", "children":[{"type":"bb", "id":3, "name":"kernel_aLoader_class.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":4, "name":"kernel_aLoader_class.B1", "details":[{"type":"table", "Latency":"8", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"6"}]}, {"type":"bb", "id":5, "name":"kernel_aLoader_class.B2", "details":[{"type":"table", "Latency":"9", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"8"}]}, {"type":"bb", "id":6, "name":"kernel_aLoader_class.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":7, "name":"kernel_aLoader_class.B4", "details":[{"type":"table", "Latency":"5", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"9"}]}, {"type":"bb", "id":8, "name":"kernel_aLoader_class.B5", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":9, "name":"kernel_aLoader_class.B6", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":10, "name":"kernel_aLoader_class.B7", "children":[{"type":"inst", "id":12, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":298}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Start Cycle":"72", "Latency":"156", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":13, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"229", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":15, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"16"}]}, {"type":"inst", "id":16, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"229", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"229", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":11, "name":"kernel_aLoader_class.B8", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":17, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k0_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":18, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]]}, {"type":"interface", "id":19, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]]}, {"type":"interface", "id":20, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]]}, {"type":"interface", "id":21, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k0_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":22, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k0_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":23, "name":"arg_B_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k0_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":24, "name":"arg_A_serializer_mem_channel", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"k0_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler", "Alignment":"1024"}]}]}]}, {"type":"kernel", "id":26, "name":"kernel_aFeeder_class", "children":[{"type":"bb", "id":27, "name":"kernel_aFeeder_class.B0", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":28, "name":"kernel_aFeeder_class.B1", "children":[{"type":"inst", "id":29, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"4", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":30, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":348}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"9", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":31, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"10", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":32, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":348}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"11", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":33, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"12", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":34, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":348}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"13", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":35, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"14", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":36, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":348}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"15", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":37, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":351}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"16", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":38, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"23", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":40, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":330}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"41"}]}, {"type":"inst", "id":41, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"23", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"23", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"csr", "id":42, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k1_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":43, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":316}]]}, {"type":"interface", "id":44, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":316}]]}, {"type":"interface", "id":45, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":316}]]}]}, {"type":"memtype", "id":46, "name":"On-chip Memory", "children":[{"type":"memsys", "id":47, "name":"DB", "debug":[[{"filename":"sgemm.sycl.h", "line":324}]], "details":[{"type":"table", "Requested size":"2048 bytes", "Implemented size":"2048 bytes", "Number of banks":"4", "Bank width":"128 bits", "Bank depth":"32 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}]}]}]}, {"type":"kernel", "id":60, "name":"kernel_bLoader_class", "children":[{"type":"bb", "id":61, "name":"kernel_bLoader_class.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":62, "name":"kernel_bLoader_class.B1", "details":[{"type":"table", "Latency":"8", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"64"}]}, {"type":"bb", "id":63, "name":"kernel_bLoader_class.B2", "details":[{"type":"table", "Latency":"9", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"66"}]}, {"type":"bb", "id":64, "name":"kernel_bLoader_class.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":65, "name":"kernel_bLoader_class.B4", "details":[{"type":"table", "Latency":"5", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"67"}]}, {"type":"bb", "id":66, "name":"kernel_bLoader_class.B5", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":67, "name":"kernel_bLoader_class.B6", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":68, "name":"kernel_bLoader_class.B7", "children":[{"type":"inst", "id":70, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":523}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Start Cycle":"71", "Latency":"156", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":71, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"228", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":73, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"74"}]}, {"type":"inst", "id":74, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"228", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"228", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":69, "name":"kernel_bLoader_class.B8", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":75, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k2_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":76, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]]}, {"type":"interface", "id":77, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]]}, {"type":"interface", "id":78, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]]}, {"type":"interface", "id":79, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k2_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":80, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k2_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":81, "name":"arg_B_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k2_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":82, "name":"arg_B_serializer_mem_channel", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"k2_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler", "Alignment":"1024"}]}]}]}, {"type":"kernel", "id":83, "name":"kernel_bFeeder_class", "children":[{"type":"bb", "id":84, "name":"kernel_bFeeder_class.B0", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":85, "name":"kernel_bFeeder_class.B1", "children":[{"type":"inst", "id":86, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"4", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":87, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":573}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"9", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":88, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"10", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":89, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":573}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"11", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":90, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"12", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":91, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":573}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"13", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":92, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"14", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":93, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":573}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Stores to":"DB", "Start Cycle":"15", "Latency":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":94, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":576}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Pipelined never-stall", "Stall-free":"Yes", "Loads from":"DB", "Start Cycle":"16", "Latency":"3", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":95, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"23", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":97, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":555}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"98"}]}, {"type":"inst", "id":98, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"23", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"23", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"csr", "id":99, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k3_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":100, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":541}]]}, {"type":"interface", "id":101, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":541}]]}, {"type":"interface", "id":102, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":541}]]}]}, {"type":"memtype", "id":103, "name":"On-chip Memory", "children":[{"type":"memsys", "id":104, "name":"DB", "debug":[[{"filename":"sgemm.sycl.h", "line":549}]], "details":[{"type":"table", "Requested size":"2048 bytes", "Implemented size":"2048 bytes", "Number of banks":"4", "Bank width":"128 bits", "Bank depth":"32 words", "Number of replicates":"1", "Number of private copies":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Local Memory", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/chn1469549457114.html"}]}]}]}]}]}, {"type":"kernel", "id":117, "name":"kernel_SignalGenerator", "children":[{"type":"bb", "id":118, "name":"kernel_SignalGenerator.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":119, "name":"kernel_SignalGenerator.B1", "details":[{"type":"table", "Latency":"7", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"121"}]}, {"type":"bb", "id":120, "name":"kernel_SignalGenerator.B2", "details":[{"type":"table", "Latency":"5", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"123"}]}, {"type":"bb", "id":121, "name":"kernel_SignalGenerator.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":122, "name":"kernel_SignalGenerator.B4", "details":[{"type":"table", "Latency":"7", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"124"}]}, {"type":"bb", "id":123, "name":"kernel_SignalGenerator.B5", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":124, "name":"kernel_SignalGenerator.B6", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":125, "name":"kernel_SignalGenerator.B7", "children":[{"type":"inst", "id":127, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"6", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":129, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":595}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"130"}]}, {"type":"inst", "id":130, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"6", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"6", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":126, "name":"kernel_SignalGenerator.B8", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":131, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k4_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":132, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]]}, {"type":"interface", "id":133, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]]}, {"type":"interface", "id":134, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]]}, {"type":"interface", "id":135, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k4_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":136, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k4_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":137, "name":"arg_B_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k4_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}]}]}, {"type":"kernel", "id":138, "name":"kernel_Product_class", "children":[{"type":"bb", "id":139, "name":"kernel_Product_class.B0", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":140, "name":"kernel_Product_class.B1", "children":[{"type":"inst", "id":141, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"4", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":142, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"5", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":143, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"5", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":144, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"30", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":146, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":624}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"147"}]}, {"type":"inst", "id":147, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"30", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"30", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"csr", "id":148, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k5_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":149, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":615}]]}, {"type":"interface", "id":150, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":615}]]}, {"type":"interface", "id":151, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":615}]]}]}]}, {"type":"kernel", "id":152, "name":"kernel_cLoader_class", "children":[{"type":"bb", "id":153, "name":"kernel_cLoader_class.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":154, "name":"kernel_cLoader_class.B1", "details":[{"type":"table", "Latency":"6", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"156"}]}, {"type":"bb", "id":155, "name":"kernel_cLoader_class.B2", "details":[{"type":"table", "Latency":"5", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"157"}]}, {"type":"bb", "id":156, "name":"kernel_cLoader_class.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":157, "name":"kernel_cLoader_class.B4", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":158, "name":"kernel_cLoader_class.B5", "children":[{"type":"inst", "id":160, "name":"Load", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":858}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Start Cycle":"5", "Latency":"156", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":161, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"162", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":163, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"164"}]}, {"type":"inst", "id":164, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"162", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"162", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":159, "name":"kernel_cLoader_class.B6", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":165, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k6_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":166, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]]}, {"type":"interface", "id":167, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]]}, {"type":"interface", "id":168, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]]}, {"type":"interface", "id":169, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k6_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":170, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k6_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":171, "name":"arg_p3", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k6_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":172, "name":"arg_C_serializer_mem_channel", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"k6_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler", "Alignment":"1024"}]}]}]}, {"type":"kernel", "id":173, "name":"kernel_Out_class", "children":[{"type":"bb", "id":174, "name":"kernel_Out_class.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":175, "name":"kernel_Out_class.B1", "details":[{"type":"table", "Latency":"5", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"177"}]}, {"type":"bb", "id":176, "name":"kernel_Out_class.B2", "details":[{"type":"table", "Latency":"5", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"178"}]}, {"type":"bb", "id":177, "name":"kernel_Out_class.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":178, "name":"kernel_Out_class.B4", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":179, "name":"kernel_Out_class.B5", "children":[{"type":"inst", "id":181, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"5", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":182, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"5", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":183, "name":"Pipe Write", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":82}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"17", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":185, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":879}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"186"}]}, {"type":"inst", "id":186, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"17", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"17", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":180, "name":"kernel_Out_class.B6", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":187, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k7_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":188, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]]}, {"type":"interface", "id":189, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]]}, {"type":"interface", "id":190, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]]}, {"type":"interface", "id":191, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k7_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":192, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k7_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":193, "name":"arg_p3", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k7_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":194, "name":"arg_p2", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k7_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}]}]}, {"type":"kernel", "id":195, "name":"kernel_unloader_class", "children":[{"type":"bb", "id":196, "name":"kernel_unloader_class.B0", "details":[{"type":"table", "Latency":"9"}]}, {"type":"bb", "id":197, "name":"kernel_unloader_class.B1", "details":[{"type":"table", "Latency":"6", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"199"}]}, {"type":"bb", "id":198, "name":"kernel_unloader_class.B2", "details":[{"type":"table", "Latency":"5", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"200"}]}, {"type":"bb", "id":199, "name":"kernel_unloader_class.B3", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":200, "name":"kernel_unloader_class.B4", "details":[{"type":"table", "Latency":"0", "II":"2", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":201, "name":"kernel_unloader_class.B5", "children":[{"type":"inst", "id":203, "name":"Pipe Read", "debug":[[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":67}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/qah1476410829821.html"}]}]}]}, {"type":"inst", "id":204, "name":"Store", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":979}]], "details":[{"type":"table", "Width":"128 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Start Cycle":"9", "Latency":"2", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/yeo1491314105959.html"}]}]}]}, {"type":"inst", "id":205, "name":"Loop Input", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"206"}]}, {"type":"inst", "id":206, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"11", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"11", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":202, "name":"kernel_unloader_class.B6", "details":[{"type":"table", "Latency":"0"}]}, {"type":"csr", "id":207, "name":"Register Map", "debug":[[{"filename":"hardware_demo.prj/k8_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler_csr.hpp", "line":1}]], "children":[{"type":"interface", "id":208, "name":"start", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]]}, {"type":"interface", "id":209, "name":"done", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]]}, {"type":"interface", "id":210, "name":"busy", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]]}, {"type":"interface", "id":211, "name":"arg_A_extent_1", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k8_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":212, "name":"arg_B_extent_0", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]], "details":[{"type":"table", "Stable":"No", "Width":"32 bits", "Kernel":"k8_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler"}]}, {"type":"interface", "id":213, "name":"arg_unloader_mem_channel", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]], "details":[{"type":"table", "Stable":"No", "Width":"64 bits", "Kernel":"k8_ZTSZZN4t2sp5sgemm5sgemmEPFiRKN4sycl3_V16deviceEEbbffP15halide_buffer_tS9_S9_S9_ENKUlRNS2_7handler", "Alignment":"1024"}]}]}]}, {"type":"memtype", "id":1, "name":"Global Memory", "children":[{"type":"memsys", "id":25, "name":"DDR", "details":[{"type":"table", "Number of banks":"2"}]}]}, {"type":"pipe", "id":184, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Out_channel_pipe, sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256"}]}, {"type":"pipe", "id":145, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::Product_channel_pipe, sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":615}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256"}]}, {"type":"pipe", "id":39, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":316}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256"}]}, {"type":"pipe", "id":14, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::aLoader_channel_pipe, sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256"}]}, {"type":"pipe", "id":96, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bFeeder_channel_pipe, fpga_tools::Tuple<sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":541}]], "details":[{"type":"table", "Width":"512 bits", "Depth":"256"}]}, {"type":"pipe", "id":72, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::bLoader_channel_pipe, sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256"}]}, {"type":"pipe", "id":162, "name":"sycl::_V1::ext::intel::pipe<pipe_wrapper<t2sp::sgemm::cLoader_channel_pipe, sycl::_V1::vec<float, 4>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"256"}]}, {"type":"pipe", "id":128, "name":"sycl::_V1::ext::intel::pipe<t2sp::sgemm::_SignalGenerator_channel_pipe, t2sp::sgemm::signals_t, 256>", "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"256"}]}], "links":[{"from":13, "to":14}, {"from":18, "to":3}, {"from":11, "to":19}, {"from":3, "to":20, "reverse":2}, {"from":21, "to":4}, {"from":22, "to":3}, {"from":23, "to":15}, {"from":24, "to":15}, {"from":6, "to":4}, {"from":3, "to":4}, {"from":8, "to":5}, {"from":4, "to":5}, {"from":8, "to":6}, {"from":9, "to":7}, {"from":5, "to":7}, {"from":9, "to":8}, {"from":16, "to":9}, {"from":16, "to":15}, {"from":7, "to":15}, {"from":12, "to":16}, {"from":13, "to":16}, {"from":6, "to":11}, {"from":15, "to":12}, {"from":12, "to":13}, {"from":25, "to":12}, {"from":14, "to":29}, {"from":38, "to":39}, {"from":43, "to":27}, {"from":27, "to":45, "reverse":2}, {"from":47, "to":31}, {"from":47, "to":33}, {"from":47, "to":35}, {"from":47, "to":37}, {"from":30, "to":47}, {"from":32, "to":47}, {"from":34, "to":47}, {"from":36, "to":47}, {"from":41, "to":40}, {"from":27, "to":40}, {"from":29, "to":41}, {"from":30, "to":41}, {"from":31, "to":41}, {"from":32, "to":41}, {"from":33, "to":41}, {"from":34, "to":41}, {"from":35, "to":41}, {"from":36, "to":41}, {"from":37, "to":41}, {"from":38, "to":41}, {"from":40, "to":29}, {"from":29, "to":30}, {"from":29, "to":31}, {"from":29, "to":32}, {"from":29, "to":33}, {"from":29, "to":34}, {"from":29, "to":35}, {"from":29, "to":36}, {"from":29, "to":37}, {"from":30, "to":38}, {"from":31, "to":38}, {"from":32, "to":38}, {"from":33, "to":38}, {"from":34, "to":38}, {"from":35, "to":38}, {"from":36, "to":38}, {"from":37, "to":38}, {"from":71, "to":72}, {"from":76, "to":61}, {"from":69, "to":77}, {"from":61, "to":78, "reverse":2}, {"from":79, "to":62}, {"from":80, "to":73}, {"from":81, "to":73}, {"from":82, "to":73}, {"from":64, "to":62}, {"from":61, "to":62}, {"from":66, "to":63}, {"from":62, "to":63}, {"from":66, "to":64}, {"from":67, "to":65}, {"from":63, "to":65}, {"from":67, "to":66}, {"from":74, "to":67}, {"from":74, "to":73}, {"from":65, "to":73}, {"from":70, "to":74}, {"from":71, "to":74}, {"from":64, "to":69}, {"from":73, "to":70}, {"from":70, "to":71}, {"from":25, "to":70}, {"from":72, "to":86}, {"from":95, "to":96}, {"from":100, "to":84}, {"from":84, "to":102, "reverse":2}, {"from":104, "to":88}, {"from":104, "to":90}, {"from":104, "to":92}, {"from":104, "to":94}, {"from":87, "to":104}, {"from":89, "to":104}, {"from":91, "to":104}, {"from":93, "to":104}, {"from":98, "to":97}, {"from":84, "to":97}, {"from":86, "to":98}, {"from":87, "to":98}, {"from":88, "to":98}, {"from":89, "to":98}, {"from":90, "to":98}, {"from":91, "to":98}, {"from":92, "to":98}, {"from":93, "to":98}, {"from":94, "to":98}, {"from":95, "to":98}, {"from":97, "to":86}, {"from":86, "to":87}, {"from":86, "to":88}, {"from":86, "to":89}, {"from":86, "to":90}, {"from":86, "to":91}, {"from":86, "to":92}, {"from":86, "to":93}, {"from":86, "to":94}, {"from":87, "to":95}, {"from":88, "to":95}, {"from":89, "to":95}, {"from":90, "to":95}, {"from":91, "to":95}, {"from":92, "to":95}, {"from":93, "to":95}, {"from":94, "to":95}, {"from":127, "to":128}, {"from":132, "to":118}, {"from":126, "to":133}, {"from":118, "to":134, "reverse":2}, {"from":135, "to":119}, {"from":136, "to":118}, {"from":137, "to":122}, {"from":121, "to":119}, {"from":118, "to":119}, {"from":123, "to":120}, {"from":119, "to":120}, {"from":123, "to":121}, {"from":124, "to":122}, {"from":120, "to":122}, {"from":124, "to":123}, {"from":130, "to":124}, {"from":130, "to":129}, {"from":122, "to":129}, {"from":127, "to":130}, {"from":121, "to":126}, {"from":129, "to":127}, {"from":128, "to":141}, {"from":96, "to":142}, {"from":39, "to":143}, {"from":144, "to":145}, {"from":149, "to":139}, {"from":139, "to":151, "reverse":2}, {"from":147, "to":146}, {"from":139, "to":146}, {"from":141, "to":147}, {"from":142, "to":147}, {"from":143, "to":147}, {"from":144, "to":147}, {"from":146, "to":141}, {"from":141, "to":142}, {"from":141, "to":143}, {"from":141, "to":144}, {"from":142, "to":144}, {"from":143, "to":144}, {"from":161, "to":162}, {"from":166, "to":153}, {"from":159, "to":167}, {"from":153, "to":168, "reverse":2}, {"from":169, "to":153}, {"from":170, "to":153}, {"from":171, "to":153}, {"from":172, "to":163}, {"from":156, "to":154}, {"from":153, "to":154}, {"from":157, "to":155}, {"from":154, "to":155}, {"from":157, "to":156}, {"from":164, "to":157}, {"from":164, "to":163}, {"from":155, "to":163}, {"from":160, "to":164}, {"from":161, "to":164}, {"from":156, "to":159}, {"from":163, "to":160}, {"from":160, "to":161}, {"from":25, "to":160}, {"from":145, "to":181}, {"from":162, "to":182}, {"from":183, "to":184}, {"from":188, "to":174}, {"from":180, "to":189}, {"from":174, "to":190, "reverse":2}, {"from":191, "to":174}, {"from":192, "to":174}, {"from":193, "to":185}, {"from":194, "to":185}, {"from":177, "to":175}, {"from":174, "to":175}, {"from":178, "to":176}, {"from":175, "to":176}, {"from":178, "to":177}, {"from":186, "to":178}, {"from":186, "to":185}, {"from":176, "to":185}, {"from":181, "to":186}, {"from":182, "to":186}, {"from":183, "to":186}, {"from":177, "to":180}, {"from":185, "to":181}, {"from":185, "to":182}, {"from":181, "to":183}, {"from":182, "to":183}, {"from":184, "to":203}, {"from":208, "to":196}, {"from":202, "to":209}, {"from":196, "to":210, "reverse":2}, {"from":211, "to":196}, {"from":212, "to":196}, {"from":213, "to":205}, {"from":199, "to":197}, {"from":196, "to":197}, {"from":200, "to":198}, {"from":197, "to":198}, {"from":200, "to":199}, {"from":206, "to":200}, {"from":206, "to":205}, {"from":198, "to":205}, {"from":203, "to":206}, {"from":204, "to":206}, {"from":199, "to":202}, {"from":205, "to":203}, {"from":203, "to":204}, {"from":204, "to":25}]};
var loopsJSON={"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Kernel: kernel_aLoader_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":288}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_aLoader_class.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "details":[{"type":"brief", "text":"Serial exe: Data dependency and..."}, {"type":"text", "text":"Iteration executed serially across kernel_aLoader_class.B2. Only a single loop iteration will execute inside this region due to data dependency on variable(s):", "details":[{"type":"text", "text":"addr_temp (%L)", "links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"289"}]}]}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_aLoader_class.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_aLoader_class.B4", "data":["Yes", ">=1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_aLoader_class.B7", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Load Operation (%L > %L, %L, %L, %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"298"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"299"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"300"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"301"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"297"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}]}, {"name":"Kernel: kernel_aFeeder_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":316}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_aFeeder_class.B1", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":330}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"331"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"355"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}, {"name":"Kernel: kernel_bLoader_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":513}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_bLoader_class.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "details":[{"type":"brief", "text":"Serial exe: Data dependency and..."}, {"type":"text", "text":"Iteration executed serially across kernel_bLoader_class.B2. Only a single loop iteration will execute inside this region due to data dependency on variable(s):", "details":[{"type":"text", "text":"addr_temp (%L)", "links":[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"514"}]}]}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_bLoader_class.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_bLoader_class.B4", "data":["Yes", ">=1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_bLoader_class.B7", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Load Operation (%L > %L, %L, %L, %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"523"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"524"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"525"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"526"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"522"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}]}, {"name":"Kernel: kernel_bFeeder_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":541}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_bFeeder_class.B1", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":555}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"556"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"580"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}, {"name":"Kernel: kernel_SignalGenerator", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":591}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_SignalGenerator.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_SignalGenerator.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_SignalGenerator.B4", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_SignalGenerator.B7", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":595}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instruction:", "details":[{"type":"text", "text":"Pipe Write Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"601"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}]}, {"name":"Kernel: kernel_Product_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":615}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_Product_class.B1", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":624}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Pipe Read Operation (%L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"625"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"644"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"645"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"690"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}, {"name":"Kernel: kernel_cLoader_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":850}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_cLoader_class.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_cLoader_class.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_cLoader_class.B5", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Load Operation (%L > %L, %L, %L, %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"858"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"859"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"860"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"861"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"857"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}, {"name":"Kernel: kernel_Out_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":876}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_Out_class.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_Out_class.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_Out_class.B5", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":879}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"881"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"881"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Pipe Write Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"882"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"39"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"82"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}, {"name":"Kernel: kernel_unloader_class", "data":["", "", ""], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":972}]], "details":[{"type":"brief", "text":"Single work-item execution"}, {"type":"text", "text":"Single work-item execution"}, {"type":"text", "text":"fMAX bottleneck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Kernels", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/ipp1476408832230.html"}]}], "children":[{"name":"kernel_unloader_class.B1", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_unloader_class.B2", "data":["Yes", ">=2", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "details":[{"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Nested Loops", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/rfr1469543500580.html"}]}], "children":[{"name":"kernel_unloader_class.B5", "data":["Yes", "~1", "0"], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]], "details":[{"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Pipe Read Operation (%L > %L > %L > %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"978"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/../../include/pipe_wrapper.hpp", "line":"33"}, {"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/ext/intel/pipes.hpp", "line":"67"}]}, {"type":"text", "text":"Store Operation (%L > %L, %L, %L, %L)", "links":[{"filename":"/glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/bin-llvm/../include/sycl/handler.hpp", "line":"1166"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"979"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"980"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"981"}, {"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":"982"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"Average Trip count: 64 (exact)"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Loops in a Single Work-Item Kernel", "link":"file:////glob/development-tools/versions/oneapi/2023.1.1/oneapi/compiler/2023.1.0/linux/lib/oclfpga/aoc_help_pages/wfa1476380079940.html"}]}], "children":[]}]}]}]}]};
var loop_attrJSON={"name":"loop_attributes", "id":2279, "nodes":[{"name":"kernel_aLoader_class", "id":1, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_aLoader_class.B0", "id":10, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_aLoader_class.B1", "id":11, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"8.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":291}]], "type":"loop", "children":[{"name":"kernel_aLoader_class.B2", "id":12, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"9.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":292}]], "type":"loop", "children":[{"name":"kernel_aLoader_class.B4", "id":14, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":293}]], "type":"loop", "children":[{"name":"kernel_aLoader_class.B7", "id":17, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"4", "lt":"229.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":294}]], "type":"loop"}]}, {"name":"kernel_aLoader_class.B6", "id":16, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_aLoader_class.B5", "id":15, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_aLoader_class.B3", "id":13, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_aLoader_class.B8", "id":18, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_aFeeder_class", "id":2, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_aFeeder_class.B0", "id":19, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"2.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_aFeeder_class.B1", "id":20, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"23.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":330}]], "type":"loop"}]}, {"name":"kernel_bLoader_class", "id":3, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_bLoader_class.B0", "id":21, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_bLoader_class.B1", "id":22, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"8.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":516}]], "type":"loop", "children":[{"name":"kernel_bLoader_class.B2", "id":23, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"9.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":517}]], "type":"loop", "children":[{"name":"kernel_bLoader_class.B4", "id":25, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":518}]], "type":"loop", "children":[{"name":"kernel_bLoader_class.B7", "id":28, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"4", "lt":"228.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":519}]], "type":"loop"}]}, {"name":"kernel_bLoader_class.B6", "id":27, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_bLoader_class.B5", "id":26, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_bLoader_class.B3", "id":24, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_bLoader_class.B8", "id":29, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_bFeeder_class", "id":4, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_bFeeder_class.B0", "id":30, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"2.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_bFeeder_class.B1", "id":31, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"23.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":555}]], "type":"loop"}]}, {"name":"kernel_SignalGenerator", "id":5, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_SignalGenerator.B0", "id":32, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_SignalGenerator.B1", "id":33, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"7.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":592}]], "type":"loop", "children":[{"name":"kernel_SignalGenerator.B2", "id":34, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":593}]], "type":"loop", "children":[{"name":"kernel_SignalGenerator.B4", "id":36, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"3", "lt":"7.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":594}]], "type":"loop", "children":[{"name":"kernel_SignalGenerator.B7", "id":39, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"4", "lt":"6.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":595}]], "type":"loop"}]}, {"name":"kernel_SignalGenerator.B6", "id":38, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_SignalGenerator.B5", "id":37, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_SignalGenerator.B3", "id":35, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_SignalGenerator.B8", "id":40, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_Product_class", "id":6, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_Product_class.B0", "id":41, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"2.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_Product_class.B1", "id":42, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"31.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":624}]], "type":"loop"}]}, {"name":"kernel_cLoader_class", "id":7, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_cLoader_class.B0", "id":43, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_cLoader_class.B1", "id":44, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"6.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":853}]], "type":"loop", "children":[{"name":"kernel_cLoader_class.B2", "id":45, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":854}]], "type":"loop", "children":[{"name":"kernel_cLoader_class.B5", "id":48, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"162.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":855}]], "type":"loop"}]}, {"name":"kernel_cLoader_class.B4", "id":47, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_cLoader_class.B3", "id":46, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_cLoader_class.B6", "id":49, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_Out_class", "id":8, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_Out_class.B0", "id":50, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_Out_class.B1", "id":51, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":877}]], "type":"loop", "children":[{"name":"kernel_Out_class.B2", "id":52, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":878}]], "type":"loop", "children":[{"name":"kernel_Out_class.B5", "id":55, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"17.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":879}]], "type":"loop"}]}, {"name":"kernel_Out_class.B4", "id":54, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_Out_class.B3", "id":53, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_Out_class.B6", "id":56, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_unloader_class", "id":9, "clk":"Yes", "fmax":"360.00", "type":"kernel", "children":[{"name":"kernel_unloader_class.B0", "id":57, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"9.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_unloader_class.B1", "id":58, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"1", "lt":"6.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":975}]], "type":"loop", "children":[{"name":"kernel_unloader_class.B2", "id":59, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"2", "ll":"2", "lt":"5.000000", "mi":"1", "pl":"Yes", "tc":"0", "tn":"0", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":976}]], "type":"loop", "children":[{"name":"kernel_unloader_class.B5", "id":62, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"3", "lt":"11.000000", "mi":"1", "pl":"Yes", "tc":"64", "tn":"1", "details":[{"type":"text", "text":"Hyper-Optimized loop structure: n/a"}], "debug":[[{"filename":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/././sgemm.sycl.h", "line":977}]], "type":"loop"}]}, {"name":"kernel_unloader_class.B4", "id":61, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"2", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}, {"name":"kernel_unloader_class.B3", "id":60, "af":"360.00", "br":"1", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"0.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}, {"name":"kernel_unloader_class.B6", "id":63, "af":"360.00", "br":"0", "ci":"0", "fo":"Disabled", "ii":"1", "ll":"1", "lt":"1.000000", "mi":"n/a", "pl":"Yes", "tc":"0", "tn":"1", "type":"bb"}]}]};
var summaryJSON={"performanceSummary":{"name":"Kernel Summary", "columns":["Kernel Name", "Kernel Type", "Autorun", "Workgroup Size", "# Compute Units"], "children":[{"name":"kernel_bFeeder_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_SignalGenerator", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_Product_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_cLoader_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_Out_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_unloader_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_aLoader_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_aFeeder_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_bLoader_class", "data":["Single work-item", "No", [1, 1, 1], 1], "details":[{"type":"text", "text":"Kernel type: Single work-item"}, {"type":"text", "text":"Required workgroup size: (1, 1, 1)"}, {"type":"text", "text":"Maximum workgroup size: 1"}], "debug":[[{"filename":"", "line":0}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Kernel Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"kernel_bFeeder_class", "data":[3388, 6205, 0, 0, 89], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_SignalGenerator", "data":[2672, 3672, 0, 0, 17], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_Product_class", "data":[11442, 19435, 0, 64, 104], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_cLoader_class", "data":[2703, 5431, 16, 0, 23], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_Out_class", "data":[2333, 3451, 0, 8, 30], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_unloader_class", "data":[2531, 5616, 0, 0, 56], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_aLoader_class", "data":[12302, 14830, 42, 11, 82], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_aFeeder_class", "data":[3384, 6265, 0, 0, 89], "debug":[[{"filename":"", "line":0}]]}, {"name":"kernel_bLoader_class", "data":[10568, 13250, 34, 2, 69], "debug":[[{"filename":"", "line":0}]]}, {"name":"Kernel Subtotal", "classes":["summary-highlight", "nohover"], "data":[51323, 78155, 92, 85, 559]}, {"name":"Global Interconnect", "classes":["summary-highlight", "nohover"], "data":[12524, 15522, 104, 0, 0]}, {"name":"Board Interface", "classes":["summary-highlight", "nohover"], "data":[134500, 172452, 397, 0, 0]}, {"name":"System description ROM", "classes":["summary-highlight", "nohover"], "data":[0, 67, 2, 0, 0]}, {"name":"Pipe resources", "classes":["summary-highlight", "nohover"], "data":[88, 5136, 47, 0, 0]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[198435, 271332, 642, 85, 559], "data_percent":[23.2251, 15.8785, 23.6638, 5.59947]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[854400, 1708800, 2713, 1518, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}};
var warningsJSON={"nodes":[]};
var fileJSON=[{"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/tools/Halide/include/HalideBuffer.h", "name":"HalideBuffer.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/tools/Halide/include/HalideBuffer.h", "content":"/** \\file\u000A * Defines a Buffer type that wraps from buffer_t and adds\u000A * functionality, and methods for more conveniently iterating over the\u000A * samples in a buffer_t outside of Halide code. */\u000A\u000A#ifndef HALIDE_RUNTIME_BUFFER_H\u000A#define HALIDE_RUNTIME_BUFFER_H\u000A\u000A#include <algorithm>\u000A#include <atomic>\u000A#include <cassert>\u000A#include <limits>\u000A#include <memory>\u000A#include <stdint.h>\u000A#include <string.h>\u000A#include <vector>\u000A\u000A#if defined(__has_feature)\u000A#if __has_feature(memory_sanitizer)\u000A#include <sanitizer/msan_interface.h>\u000A#endif\u000A#endif\u000A\u000A#include \"HalideRuntime.h\"\u000A\u000A#ifdef _MSC_VER\u000A#define HALIDE_ALLOCA _alloca\u000A#else\u000A#define HALIDE_ALLOCA __builtin_alloca\u000A#endif\u000A\u000A// gcc 5.1 has a false positive warning on this code\u000A#if __GNUC__ == 5 && __GNUC_MINOR__ == 1\u000A#pragma GCC diagnostic ignored \"-Warray-bounds\"\u000A#endif\u000A\u000Anamespace Halide {\u000Anamespace Runtime {\u000A\u000A// Forward-declare our Buffer class\u000Atemplate<typename T, int D> class Buffer;\u000A\u000A// A helper to check if a parameter pack is entirely implicitly\u000A// int-convertible to use with std::enable_if\u000Atemplate<typename ...Args>\u000Astruct AllInts : std::false_type {};\u000A\u000Atemplate<>\u000Astruct AllInts<> : std::true_type {};\u000A\u000Atemplate<typename T, typename ...Args>\u000Astruct AllInts<T, Args...> {\u000A    static const bool value = std::is_convertible<T, int>::value && AllInts<Args...>::value;\u000A};\u000A\u000A// Floats and doubles are technically implicitly int-convertible, but\u000A// doing so produces a warning we treat as an error, so just disallow\u000A// it here.\u000Atemplate<typename ...Args>\u000Astruct AllInts<float, Args...> : std::false_type {};\u000A\u000Atemplate<typename ...Args>\u000Astruct AllInts<double, Args...> : std::false_type {};\u000A\u000A// A helper to detect if there are any zeros in a container\u000Anamespace Internal {\u000Atemplate<typename Container>\u000Abool any_zero(const Container &c) {\u000A    for (int i : c) {\u000A        if (i == 0) return true;\u000A    }\u000A    return false;\u000A}\u000A}\u000A\u000A/** A struct acting as a header for allocations owned by the Buffer\u000A * class itself. */\u000Astruct AllocationHeader {\u000A    void (*deallocate_fn)(void *);\u000A    std::atomic<int> ref_count;\u000A\u000A    // Note that ref_count always starts at 1\u000A    AllocationHeader(void (*deallocate_fn)(void *)) : deallocate_fn(deallocate_fn), ref_count(1) {}\u000A};\u000A\u000A/** This indicates how to deallocate the device for a Halide::Runtime::Buffer. */\u000Aenum struct BufferDeviceOwnership : int {\u000A    Allocated,     ///> halide_device_free will be called when device ref count goes to zero\u000A    WrappedNative, ///> halide_device_detach_native will be called when device ref count goes to zero\u000A    Unmanaged,     ///> No free routine will be called when device ref count goes to zero\u000A    AllocatedDeviceAndHost, ///> Call device_and_host_free when DevRefCount goes to zero.\u000A    Cropped,       ///> Call halide_device_release_crop when DevRefCount goes to zero.\u000A};\u000A\u000A/** A similar struct for managing device allocations. */\u000Astruct DeviceRefCount {\u000A    // This is only ever constructed when there's something to manage,\u000A    // so start at one.\u000A    std::atomic<int> count {1};\u000A    BufferDeviceOwnership ownership{BufferDeviceOwnership::Allocated};\u000A};\u000A\u000A/** A templated Buffer class that wraps halide_buffer_t and adds\u000A * functionality. When using Halide from C++, this is the preferred\u000A * way to create input and output buffers. The overhead of using this\u000A * class relative to a naked halide_buffer_t is minimal - it uses another\u000A * ~16 bytes on the stack, and does no dynamic allocations when using\u000A * it to represent existing memory of a known maximum dimensionality.\u000A *\u000A * The template parameter T is the element type. For buffers where the\u000A * element type is unknown, or may vary, use void or const void.\u000A *\u000A * D is the maximum number of dimensions that can be represented using\u000A * space inside the class itself. Set it to the maximum dimensionality\u000A * you expect this buffer to be. If the actual dimensionality exceeds\u000A * this, heap storage is allocated to track the shape of the buffer. D\u000A * defaults to 4, which should cover nearly all usage.\u000A *\u000A * The class optionally allocates and owns memory for the image using\u000A * a shared pointer allocated with the provided allocator. If they are\u000A * null, malloc and free are used.  Any device-side allocation is\u000A * considered as owned if and only if the host-side allocation is\u000A * owned. */\u000Atemplate<typename T = void, int D = 4>\u000Aclass Buffer {\u000A    /** The underlying buffer_t */\u000A    halide_buffer_t buf = {0};\u000A\u000A    /** Some in-class storage for shape of the dimensions. */\u000A    halide_dimension_t shape[D];\u000A\u000A    /** The allocation owned by this Buffer. NULL if the Buffer does not\u000A     * own the memory. */\u000A    AllocationHeader *alloc = nullptr;\u000A\u000A    /** A reference count for the device allocation owned by this\u000A     * buffer. */\u000A    mutable DeviceRefCount *dev_ref_count = nullptr;\u000A\u000A    /** True if T is of type void or const void */\u000A    static const bool T_is_void = std::is_same<typename std::remove_const<T>::type, void>::value;\u000A\u000A    /** A type function that adds a const qualifier if T is a const type. */\u000A    template<typename T2>\u000A    using add_const_if_T_is_const = typename std::conditional<std::is_const<T>::value, const T2, T2>::type;\u000A\u000A    /** T unless T is (const) void, in which case (const)\u000A     * uint8_t. Useful for providing return types for operator() */\u000A    using not_void_T = typename std::conditional<T_is_void,\u000A                                                 add_const_if_T_is_const<uint8_t>,\u000A                                                 T>::type;\u000A\u000A    /** T with constness removed. Useful for return type of copy(). */\u000A    using not_const_T = typename std::remove_const<T>::type;\u000A\u000A\u000A    /** The type the elements are stored as. Equal to not_void_T\u000A     * unless T is a pointer, in which case uint64_t. Halide stores\u000A     * all pointer types as uint64s internally, even on 32-bit\u000A     * systems. */\u000A    using storage_T = typename std::conditional<std::is_pointer<T>::value, uint64_t, not_void_T>::type;\u000A\u000Apublic:\u000A    /** True if the Halide type is not void (or const void). */\u000A    static constexpr bool has_static_halide_type = !T_is_void;\u000A\u000A    /** Get the Halide type of T. Callers should not use the result if\u000A     * has_static_halide_type is false. */\u000A    static halide_type_t static_halide_type() {\u000A        return halide_type_of<typename std::remove_cv<not_void_T>::type>();\u000A    }\u000A\u000A    /** Does this Buffer own the host memory it refers to? */\u000A    bool owns_host_memory() const {\u000A        return alloc != nullptr;\u000A    }\u000A\u000Aprivate:\u000A    /** Increment the reference count of any owned allocation */\u000A    void incref() const {\u000A        if (owns_host_memory()) {\u000A            alloc->ref_count++;\u000A        }\u000A        if (buf.device) {\u000A            if (!dev_ref_count) {\u000A                // I seem to have a non-zero dev field but no\u000A                // reference count for it. I must have been given a\u000A                // device allocation by a Halide pipeline, and have\u000A                // never been copied from since. Take sole ownership\u000A                // of it.\u000A                dev_ref_count = new DeviceRefCount;\u000A            }\u000A            dev_ref_count->count++;\u000A        }\u000A    }\u000A\u000A    // Note that this is called \"cropped\" but can also encompass a slice/embed\u000A    // operation as well.\u000A    struct DevRefCountCropped : DeviceRefCount {\u000A        Buffer<T, D> cropped_from;\u000A        DevRefCountCropped(const Buffer<T, D> &cropped_from) : cropped_from(cropped_from) {\u000A            ownership = BufferDeviceOwnership::Cropped;\u000A        }\u000A    };\u000A\u000A    /** Setup the device ref count for a buffer to indicate it is a crop (or slice, embed, etc) of cropped_from */\u000A    void crop_from(const Buffer<T, D> &cropped_from) {\u000A        assert(dev_ref_count == nullptr);\u000A        dev_ref_count = new DevRefCountCropped(cropped_from);\u000A    }\u000A\u000A    /** Decrement the reference count of any owned allocation and free host\u000A     * and device memory if it hits zero. Sets alloc to nullptr. */\u000A    void decref() {\u000A        if (owns_host_memory()) {\u000A            int new_count = --(alloc->ref_count);\u000A            if (new_count == 0) {\u000A                void (*fn)(void *) = alloc->deallocate_fn;\u000A                alloc->~AllocationHeader();\u000A                fn(alloc);\u000A            }\u000A            buf.host = nullptr;\u000A            alloc = nullptr;\u000A            set_host_dirty(false);\u000A        }\u000A        decref_dev();\u000A    }\u000A\u000A    void decref_dev() {\u000A        int new_count = 0;\u000A        if (dev_ref_count) {\u000A            new_count = --(dev_ref_count->count);\u000A        }\u000A        if (new_count == 0) {\u000A            if (buf.device) {\u000A                assert(!(alloc && device_dirty()) &&\u000A                       \"Implicitly freeing a dirty device allocation while a host allocation still lives. \"\u000A                       \"Call device_free explicitly if you want to drop dirty device-side data. \"\u000A                       \"Call copy_to_host explicitly if you want the data copied to the host allocation \"\u000A                       \"before the device allocation is freed.\");\u000A                if (dev_ref_count && dev_ref_count->ownership == BufferDeviceOwnership::WrappedNative) {\u000A                    buf.device_interface->detach_native(nullptr, &buf);\u000A                } else if (dev_ref_count && dev_ref_count->ownership == BufferDeviceOwnership::AllocatedDeviceAndHost) {\u000A                    buf.device_interface->device_and_host_free(nullptr, &buf);\u000A                } else if (dev_ref_count && dev_ref_count->ownership == BufferDeviceOwnership::Cropped) {\u000A                    buf.device_interface->device_release_crop(nullptr, &buf);\u000A                } else if (dev_ref_count == nullptr || dev_ref_count->ownership == BufferDeviceOwnership::Allocated) {\u000A                    buf.device_interface->device_free(nullptr, &buf);\u000A                }\u000A            }\u000A            if (dev_ref_count) {\u000A                if (dev_ref_count->ownership == BufferDeviceOwnership::Cropped) {\u000A                    delete (DevRefCountCropped *)dev_ref_count;\u000A                } else {\u000A                    delete dev_ref_count;\u000A                }\u000A            }\u000A        }\u000A        buf.device = 0;\u000A        buf.device_interface = nullptr;\u000A        dev_ref_count = nullptr;\u000A    }\u000A\u000A    void free_shape_storage() {\u000A        if (buf.dim != shape) {\u000A            delete[] buf.dim;\u000A            buf.dim = nullptr;\u000A        }\u000A    }\u000A\u000A    void make_shape_storage(const int dimensions) {\u000A        // This should usually be inlined, so if dimensions is statically known,\u000A        // we can skip the call to new\u000A        buf.dimensions = dimensions;\u000A        buf.dim = (dimensions <= D) ? shape : new halide_dimension_t[dimensions];\u000A    }\u000A\u000A    void copy_shape_from(const halide_buffer_t &other) {\u000A        // All callers of this ensure that buf.dimensions == other.dimensions.\u000A        make_shape_storage(other.dimensions);\u000A        std::copy(other.dim, other.dim + other.dimensions, buf.dim);\u000A    }\u000A\u000A    template<typename T2, int D2>\u000A    void move_shape_from(Buffer<T2, D2> &&other) {\u000A        if (other.shape == other.buf.dim) {\u000A            copy_shape_from(other.buf);\u000A        } else {\u000A            buf.dim = other.buf.dim;\u000A            other.buf.dim = nullptr;\u000A        }\u000A    }\u000A\u000A    /** Initialize the shape from a halide_buffer_t. */\u000A    void initialize_from_buffer(const halide_buffer_t &b,\u000A                                BufferDeviceOwnership ownership) {\u000A        memcpy(&buf, &b, sizeof(halide_buffer_t));\u000A        copy_shape_from(b);\u000A        if (b.device) {\u000A            dev_ref_count = new DeviceRefCount;\u000A            dev_ref_count->ownership = ownership;\u000A        }\u000A    }\u000A\u000A    /** Initialize the shape from an array of ints */\u000A    void initialize_shape(const int *sizes) {\u000A        for (int i = 0; i < buf.dimensions; i++) {\u000A            buf.dim[i].min = 0;\u000A            buf.dim[i].extent = sizes[i];\u000A            if (i == 0) {\u000A                buf.dim[i].stride = 1;\u000A            } else {\u000A                buf.dim[i].stride = buf.dim[i-1].stride * buf.dim[i-1].extent;\u000A            }\u000A        }\u000A    }\u000A\u000A    /** Initialize the shape from a vector of extents */\u000A    void initialize_shape(const std::vector<int> &sizes) {\u000A        assert(buf.dimensions == (int)sizes.size());\u000A        initialize_shape(sizes.data());\u000A    }\u000A\u000A    /** Initialize the shape from the static shape of an array */\u000A    template<typename Array, size_t N>\u000A    void initialize_shape_from_array_shape(int next, Array (&vals)[N]) {\u000A        buf.dim[next].min = 0;\u000A        buf.dim[next].extent = (int)N;\u000A        if (next == 0) {\u000A            buf.dim[next].stride = 1;\u000A        } else {\u000A            initialize_shape_from_array_shape(next - 1, vals[0]);\u000A            buf.dim[next].stride = buf.dim[next - 1].stride * buf.dim[next - 1].extent;\u000A        }\u000A    }\u000A\u000A    /** Base case for the template recursion above. */\u000A    template<typename T2>\u000A    void initialize_shape_from_array_shape(int, const T2 &) {\u000A    }\u000A\u000A    /** Get the dimensionality of a multi-dimensional C array */\u000A    template<typename Array, size_t N>\u000A    static int dimensionality_of_array(Array (&vals)[N]) {\u000A        return dimensionality_of_array(vals[0]) + 1;\u000A    }\u000A\u000A    template<typename T2>\u000A    static int dimensionality_of_array(const T2 &) {\u000A        return 0;\u000A    }\u000A\u000A    /** Get the underlying halide_type_t of an array's element type. */\u000A    template<typename Array, size_t N>\u000A    static halide_type_t scalar_type_of_array(Array (&vals)[N]) {\u000A        return scalar_type_of_array(vals[0]);\u000A    }\u000A\u000A    template<typename T2>\u000A    static halide_type_t scalar_type_of_array(const T2 &) {\u000A        return halide_type_of<typename std::remove_cv<T2>::type>();\u000A    }\u000A\u000A    /** Crop a single dimension without handling device allocation. */\u000A    void crop_host(int d, int min, int extent) {\u000A       assert(dim(d).min() <= min);\u000A       assert(dim(d).max() >= min + extent - 1);\u000A        int shift = min - dim(d).min();\u000A        if (buf.host != nullptr) {\u000A            buf.host += shift * dim(d).stride() * type().bytes();\u000A        }\u000A        buf.dim[d].min = min;\u000A        buf.dim[d].extent = extent;\u000A    }\u000A\u000A    /** Crop as many dimensions as are in rect, without handling device allocation. */\u000A    void crop_host(const std::vector<std::pair<int, int>> &rect) {\u000A        assert(rect.size() <= static_cast<decltype(rect.size())>(std::numeric_limits<int>::max()));\u000A        int limit = (int)rect.size();\u000A        assert(limit <= dimensions());\u000A        for (int i = 0; i < limit; i++) {\u000A            crop_host(i, rect[i].first, rect[i].second);\u000A        }\u000A    }\u000A\u000A    void complete_device_crop(Buffer<T, D> &result_host_cropped) const {\u000A        assert(buf.device_interface != nullptr);\u000A        if (buf.device_interface->device_crop(nullptr, &this->buf, &result_host_cropped.buf) == 0) {\u000A            const Buffer<T, D> *cropped_from = this;\u000A            // TODO: Figure out what to do if dev_ref_count is nullptr. Should incref logic run here?\u000A            // is it possible to get to this point without incref having run at least once since\u000A            // the device field was set? (I.e. in the internal logic of crop. incref might have been\u000A            // called.)\u000A            if (dev_ref_count != nullptr && dev_ref_count->ownership == BufferDeviceOwnership::Cropped) {\u000A                cropped_from = &((DevRefCountCropped *)dev_ref_count)->cropped_from;\u000A            }\u000A            result_host_cropped.crop_from(*cropped_from);\u000A        }\u000A    }\u000A\u000A    /** slice a single dimension without handling device allocation. */\u000A    void slice_host(int d, int pos) {\u000A        assert(d >= 0 && d < dimensions());\u000A        assert(pos >= dim(d).min() && pos <= dim(d).max());\u000A        buf.dimensions--;\u000A        int shift = pos - buf.dim[d].min;\u000A        if (buf.host != nullptr) {\u000A            buf.host += shift * buf.dim[d].stride * type().bytes();\u000A        }\u000A        for (int i = d; i < buf.dimensions; i++) {\u000A            buf.dim[i] = buf.dim[i+1];\u000A        }\u000A        buf.dim[buf.dimensions] = {0, 0, 0};\u000A    }\u000A\u000A    void complete_device_slice(Buffer<T, D> &result_host_sliced, int d, int pos) const {\u000A        assert(buf.device_interface != nullptr);\u000A        if (buf.device_interface->device_slice(nullptr, &this->buf, d, pos, &result_host_sliced.buf) == 0) {\u000A            const Buffer<T, D> *sliced_from = this;\u000A            // TODO: Figure out what to do if dev_ref_count is nullptr. Should incref logic run here?\u000A            // is it possible to get to this point without incref having run at least once since\u000A            // the device field was set? (I.e. in the internal logic of slice. incref might have been\u000A            // called.)\u000A            if (dev_ref_count != nullptr && dev_ref_count->ownership == BufferDeviceOwnership::Cropped) {\u000A                sliced_from = &((DevRefCountCropped *)dev_ref_count)->cropped_from;\u000A            }\u000A            // crop_from() is correct here, despite the fact that we are slicing.\u000A            result_host_sliced.crop_from(*sliced_from);\u000A        }\u000A    }\u000A\u000A    void init_from_legacy_buffer_t(const buffer_t &old_buf, halide_type_t t) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        assert(old_buf.elem_size == t.bytes());\u000A        buf.host = old_buf.host;\u000A        buf.type = t;\u000A        int d;\u000A        for (d = 0; d < 4 && old_buf.extent[d]; d++);\u000A        make_shape_storage(d);\u000A        for (int i = 0; i < d; i++) {\u000A            buf.dim[i].min = old_buf.min[i];\u000A            buf.dim[i].extent = old_buf.extent[i];\u000A            buf.dim[i].stride = old_buf.stride[i];\u000A        }\u000A        buf.set_host_dirty(old_buf.host_dirty);\u000A        assert(old_buf.dev == 0 && \"Cannot construct a Halide::Runtime::Buffer from a legacy buffer_t with a device allocation. Use halide_upgrade_buffer_t to upgrade it to a halide_buffer_t first.\");\u000A    }\u000A\u000Apublic:\u000A\u000A    typedef T ElemType;\u000A\u000A    /** Read-only access to the shape */\u000A    class Dimension {\u000A        const halide_dimension_t &d;\u000A    public:\u000A        /** The lowest coordinate in this dimension */\u000A        HALIDE_ALWAYS_INLINE int min() const {\u000A            return d.min;\u000A        }\u000A\u000A        /** The number of elements in memory you have to step over to\u000A         * increment this coordinate by one. */\u000A        HALIDE_ALWAYS_INLINE int stride() const {\u000A            return d.stride;\u000A        }\u000A\u000A        /** The extent of the image along this dimension */\u000A        HALIDE_ALWAYS_INLINE int extent() const {\u000A            return d.extent;\u000A        }\u000A\u000A        /** The highest coordinate in this dimension */\u000A        HALIDE_ALWAYS_INLINE int max() const {\u000A            return min() + extent() - 1;\u000A        }\u000A\u000A        /** An iterator class, so that you can iterate over\u000A         * coordinates in a dimensions using a range-based for loop. */\u000A        struct iterator {\u000A            int val;\u000A            int operator*() const {return val;}\u000A            bool operator!=(const iterator &other) const {return val != other.val;}\u000A            iterator &operator++() {val++; return *this;}\u000A        };\u000A\u000A        /** An iterator that points to the min coordinate */\u000A        HALIDE_ALWAYS_INLINE iterator begin() const {\u000A            return {min()};\u000A        }\u000A\u000A        /** An iterator that points to one past the max coordinate */\u000A        HALIDE_ALWAYS_INLINE iterator end() const {\u000A            return {min() + extent()};\u000A        }\u000A\u000A        Dimension(const halide_dimension_t &dim) : d(dim) {};\u000A    };\u000A\u000A    /** Access the shape of the buffer */\u000A    HALIDE_ALWAYS_INLINE Dimension dim(int i) const {\u000A        assert(i >= 0 && i < this->dimensions());\u000A        return Dimension(buf.dim[i]);\u000A    }\u000A\u000A    /** Access to the mins, strides, extents. Will be deprecated. Do not use. */\u000A    // @{\u000A    int min(int i) const { return dim(i).min(); }\u000A    int extent(int i) const { return dim(i).extent(); }\u000A    int stride(int i) const { return dim(i).stride(); }\u000A    // @}\u000A\u000A    /** The total number of elements this buffer represents. Equal to\u000A     * the product of the extents */\u000A    size_t number_of_elements() const {\u000A        size_t s = 1;\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            s *= dim(i).extent();\u000A        }\u000A        return s;\u000A    }\u000A\u000A    /** Get the dimensionality of the buffer. */\u000A    int dimensions() const {\u000A        return buf.dimensions;\u000A    }\u000A\u000A    /** Get the type of the elements. */\u000A    halide_type_t type() const {\u000A        return buf.type;\u000A    }\u000A\u000Aprivate:\u000A    /** Offset to the element with the lowest address. If all\u000A     * strides are positive, equal to zero. Offset is in elements, not bytes. */\u000A    ptrdiff_t begin_offset() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            if (dim(i).stride() < 0) {\u000A                index += dim(i).stride() * (dim(i).extent() - 1);\u000A            }\u000A        }\u000A        return index;\u000A    }\u000A\u000A    /** An offset to one beyond the element with the highest address.\u000A     * Offset is in elements, not bytes. */\u000A    ptrdiff_t end_offset() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            if (dim(i).stride() > 0) {\u000A                index += dim(i).stride() * (dim(i).extent() - 1);\u000A            }\u000A        }\u000A        index += 1;\u000A        return index;\u000A    }\u000A\u000Apublic:\u000A    /** A pointer to the element with the lowest address. If all\u000A     * strides are positive, equal to the host pointer. */\u000A    T *begin() const {\u000A        assert(buf.host != nullptr); // Cannot call begin() on an unallocated Buffer.\u000A        return (T *)(buf.host + begin_offset() * type().bytes());\u000A    }\u000A\u000A    /** A pointer to one beyond the element with the highest address. */\u000A    T *end() const {\u000A        assert(buf.host != nullptr); // Cannot call end() on an unallocated Buffer.\u000A        return (T *)(buf.host + end_offset() * type().bytes());\u000A    }\u000A\u000A    /** The total number of bytes spanned by the data in memory. */\u000A    size_t size_in_bytes() const {\u000A        return (size_t)(end_offset() - begin_offset()) * type().bytes();\u000A    }\u000A\u000A    /** Reset the Buffer to be equivalent to a default-constructed Buffer\u000A     * of the same static type (if any); Buffer<void> will have its runtime\u000A     * type reset to uint8. */\u000A    void reset() {\u000A        *this = Buffer();\u000A    }\u000A\u000A    Buffer() : shape() {\u000A        buf.type = static_halide_type();\u000A        make_shape_storage(0);\u000A    }\u000A\u000A    /** Make a Buffer from a halide_buffer_t */\u000A    explicit Buffer(const halide_buffer_t &buf,\u000A           BufferDeviceOwnership ownership = BufferDeviceOwnership::Unmanaged) {\u000A        assert(T_is_void || buf.type == static_halide_type());\u000A        initialize_from_buffer(buf, ownership);\u000A    }\u000A\u000A    /** Make a Buffer from a legacy buffer_t, with an explicit halide_type. */\u000A    explicit Buffer(const buffer_t &old_buf, halide_type_t t) {\u000A        init_from_legacy_buffer_t(old_buf, t);\u000A    }\u000A\u000A    /** Make a Buffer from a legacy buffer_t, which is assumed to match our static\u000A     * type. (Cannot use with Buffer<void>.) */\u000A    explicit Buffer(const buffer_t &old_buf) {\u000A        static_assert(!T_is_void, \"Cannot construct a Buffer<void> from a buffer_t without an explicit type.\");\u000A        init_from_legacy_buffer_t(old_buf, static_halide_type());\u000A    }\u000A\u000A    /** Populate the fields of a legacy buffer_t using this\u000A     * Buffer. Does not copy device metadata. */\u000A    buffer_t make_legacy_buffer_t() const {\u000A        buffer_t old_buf = {0};\u000A        assert(!has_device_allocation() && \"Cannot construct a legacy buffer_t from a Halide::Runtime::Buffer with a device allocation. Use halide_downgrade_buffer_t instead.\");\u000A        old_buf.host = buf.host;\u000A        old_buf.elem_size = buf.type.bytes();\u000A        assert(dimensions() <= 4 && \"Cannot construct a legacy buffer_t from a Halide::Runtime::Buffer with more than four dimensions.\");\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            old_buf.min[i] = dim(i).min();\u000A            old_buf.extent[i] = dim(i).extent();\u000A            old_buf.stride[i] = dim(i).stride();\u000A        }\u000A        return old_buf;\u000A    }\u000A\u000A    /** Give Buffers access to the members of Buffers of different dimensionalities and types. */\u000A    template<typename T2, int D2> friend class Buffer;\u000A\u000Aprivate:\u000A    template<typename T2, int D2>\u000A    static void static_assert_can_convert_from() {\u000A        static_assert((!std::is_const<T2>::value || std::is_const<T>::value),\u000A                      \"Can't convert from a Buffer<const T> to a Buffer<T>\");\u000A        static_assert(std::is_same<typename std::remove_const<T>::type,\u000A                                   typename std::remove_const<T2>::type>::value ||\u000A                      T_is_void || Buffer<T2, D2>::T_is_void,\u000A                      \"type mismatch constructing Buffer\");\u000A    }\u000A\u000Apublic:\u000A    /** Determine if if an Buffer<T, D> can be constructed from some other Buffer type.\u000A     * If this can be determined at compile time, fail with a static assert; otherwise\u000A     * return a boolean based on runtime typing. */\u000A    template<typename T2, int D2>\u000A    static bool can_convert_from(const Buffer<T2, D2> &other) {\u000A        static_assert_can_convert_from<T2, D2>();\u000A        if (Buffer<T2, D2>::T_is_void && !T_is_void) {\u000A            return other.type() == static_halide_type();\u000A        }\u000A        return true;\u000A    }\u000A\u000A    /** Fail an assertion at runtime or compile-time if an Buffer<T, D>\u000A     * cannot be constructed from some other Buffer type. */\u000A    template<typename T2, int D2>\u000A    static void assert_can_convert_from(const Buffer<T2, D2> &other) {\u000A        // Explicitly call static_assert_can_convert_from() here so\u000A        // that we always get compile-time checking, even if compiling with\u000A        // assertions disabled.\u000A        static_assert_can_convert_from<T2, D2>();\u000A        assert(can_convert_from(other));\u000A    }\u000A\u000A    /** Copy constructor. Does not copy underlying data. */\u000A    Buffer(const Buffer<T, D> &other) : buf(other.buf),\u000A                                        alloc(other.alloc) {\u000A        other.incref();\u000A        dev_ref_count = other.dev_ref_count;\u000A        copy_shape_from(other.buf);\u000A    }\u000A\u000A    /** Construct a Buffer from a Buffer of different dimensionality\u000A     * and type. Asserts that the type matches (at runtime, if one of\u000A     * the types is void). Note that this constructor is\u000A     * implicit. This, for example, lets you pass things like\u000A     * Buffer<T> or Buffer<const void> to functions expected\u000A     * Buffer<const T>. */\u000A    template<typename T2, int D2>\u000A    Buffer(const Buffer<T2, D2> &other) : buf(other.buf),\u000A                                          alloc(other.alloc) {\u000A        assert_can_convert_from(other);\u000A        other.incref();\u000A        dev_ref_count = other.dev_ref_count;\u000A        copy_shape_from(other.buf);\u000A    }\u000A\u000A    /** Move constructor */\u000A    Buffer(Buffer<T, D> &&other) : buf(other.buf),\u000A                                   alloc(other.alloc),\u000A                                   dev_ref_count(other.dev_ref_count) {\u000A        other.dev_ref_count = nullptr;\u000A        other.alloc = nullptr;\u000A        move_shape_from(std::forward<Buffer<T, D>>(other));\u000A        other.buf = halide_buffer_t();\u000A    }\u000A\u000A    /** Move-construct a Buffer from a Buffer of different\u000A     * dimensionality and type. Asserts that the types match (at\u000A     * runtime if one of the types is void). */\u000A    template<typename T2, int D2>\u000A    Buffer(Buffer<T2, D2> &&other) : buf(other.buf),\u000A                                     alloc(other.alloc),\u000A                                     dev_ref_count(other.dev_ref_count) {\u000A        assert_can_convert_from(other);\u000A        other.dev_ref_count = nullptr;\u000A        other.alloc = nullptr;\u000A        move_shape_from(std::forward<Buffer<T2, D2>>(other));\u000A        other.buf = halide_buffer_t();\u000A    }\u000A\u000A    /** Assign from another Buffer of possibly-different\u000A     * dimensionality and type. Asserts that the types match (at\u000A     * runtime if one of the types is void). */\u000A    template<typename T2, int D2>\u000A    Buffer<T, D> &operator=(const Buffer<T2, D2> &other) {\u000A        if ((const void *)this == (const void *)&other) {\u000A            return *this;\u000A        }\u000A        assert_can_convert_from(other);\u000A        other.incref();\u000A        decref();\u000A        dev_ref_count = other.dev_ref_count;\u000A        alloc = other.alloc;\u000A        free_shape_storage();\u000A        buf = other.buf;\u000A        copy_shape_from(other.buf);\u000A        return *this;\u000A    }\u000A\u000A    /** Standard assignment operator */\u000A    Buffer<T, D> &operator=(const Buffer<T, D> &other) {\u000A        if (this == &other) {\u000A            return *this;\u000A        }\u000A        other.incref();\u000A        decref();\u000A        dev_ref_count = other.dev_ref_count;\u000A        alloc = other.alloc;\u000A        free_shape_storage();\u000A        buf = other.buf;\u000A        copy_shape_from(other.buf);\u000A        return *this;\u000A    }\u000A\u000A    /** Move from another Buffer of possibly-different\u000A     * dimensionality and type. Asserts that the types match (at\u000A     * runtime if one of the types is void). */\u000A    template<typename T2, int D2>\u000A    Buffer<T, D> &operator=(Buffer<T2, D2> &&other) {\u000A        assert_can_convert_from(other);\u000A        decref();\u000A        alloc = other.alloc;\u000A        other.alloc = nullptr;\u000A        dev_ref_count = other.dev_ref_count;\u000A        other.dev_ref_count = nullptr;\u000A        free_shape_storage();\u000A        buf = other.buf;\u000A        move_shape_from(std::forward<Buffer<T2, D2>>(other));\u000A        other.buf = halide_buffer_t();\u000A        return *this;\u000A    }\u000A\u000A    /** Standard move-assignment operator */\u000A    Buffer<T, D> &operator=(Buffer<T, D> &&other) {\u000A        decref();\u000A        alloc = other.alloc;\u000A        other.alloc = nullptr;\u000A        dev_ref_count = other.dev_ref_count;\u000A        other.dev_ref_count = nullptr;\u000A        free_shape_storage();\u000A        buf = other.buf;\u000A        move_shape_from(std::forward<Buffer<T, D>>(other));\u000A        other.buf = halide_buffer_t();\u000A        return *this;\u000A    }\u000A\u000A    /** Check the product of the extents fits in memory. */\u000A    void check_overflow() {\u000A        size_t size = type().bytes();\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            size *= dim(i).extent();\u000A        }\u000A        // We allow 2^31 or 2^63 bytes, so drop the top bit.\u000A        size = (size << 1) >> 1;\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            size /= dim(i).extent();\u000A        }\u000A        assert(size == (size_t)type().bytes() && \"Error: Overflow computing total size of buffer.\");\u000A    }\u000A\u000A    /** Allocate memory for this Buffer. Drops the reference to any\u000A     * owned memory. */\u000A    void allocate(void *(*allocate_fn)(size_t) = nullptr,\u000A                  void (*deallocate_fn)(void *) = nullptr) {\u000A        if (!allocate_fn) {\u000A            allocate_fn = malloc;\u000A        }\u000A        if (!deallocate_fn) {\u000A            deallocate_fn = free;\u000A        }\u000A\u000A        // Drop any existing allocation\u000A        deallocate();\u000A\u000A        // Conservatively align images to 128 bytes. This is enough\u000A        // alignment for all the platforms we might use.\u000A        size_t size = size_in_bytes();\u000A        const size_t alignment = 128;\u000A        size = (size + alignment - 1) & ~(alignment - 1);\u000A        void *alloc_storage = allocate_fn(size + sizeof(AllocationHeader) + alignment - 1);\u000A        alloc = new (alloc_storage) AllocationHeader(deallocate_fn);\u000A        uint8_t *unaligned_ptr = ((uint8_t *)alloc) + sizeof(AllocationHeader);\u000A        buf.host = (uint8_t *)((uintptr_t)(unaligned_ptr + alignment - 1) & ~(alignment - 1));\u000A    }\u000A\u000A    /** Drop reference to any owned host or device memory, possibly\u000A     * freeing it, if this buffer held the last reference to\u000A     * it. Retains the shape of the buffer. Does nothing if this\u000A     * buffer did not allocate its own memory. */\u000A    void deallocate() {\u000A        decref();\u000A    }\u000A\u000A    /** Drop reference to any owned device memory, possibly freeing it\u000A     * if this buffer held the last reference to it. Asserts that\u000A     * device_dirty is false. */\u000A    void device_deallocate() {\u000A        decref_dev();\u000A    }\u000A\u000A    /** Allocate a new image of the given size with a runtime\u000A     * type. Only used when you do know what size you want but you\u000A     * don't know statically what type the elements are. Pass zeroes\u000A     * to make a buffer suitable for bounds query calls. */\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    Buffer(halide_type_t t, int first, Args... rest) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        int extents[] = {first, (int)rest...};\u000A        buf.type = t;\u000A        constexpr int buf_dimensions = 1 + (int)(sizeof...(rest));\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape(extents);\u000A        if (!Internal::any_zero(extents)) {\u000A            check_overflow();\u000A            allocate();\u000A        }\u000A    }\u000A\u000A\u000A    /** Allocate a new image of the given size. Pass zeroes to make a\u000A     * buffer suitable for bounds query calls. */\u000A    // @{\u000A\u000A    // The overload with one argument is 'explicit', so that\u000A    // (say) int is not implicitly convertable to Buffer<int>\u000A    explicit Buffer(int first) {\u000A        static_assert(!T_is_void,\u000A                      \"To construct an Buffer<void>, pass a halide_type_t as the first argument to the constructor\");\u000A        int extents[] = {first};\u000A        buf.type = static_halide_type();\u000A        constexpr int buf_dimensions = 1;\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape(extents);\u000A        if (first != 0) {\u000A            check_overflow();\u000A            allocate();\u000A        }\u000A    }\u000A\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    Buffer(int first, int second, Args... rest) {\u000A        static_assert(!T_is_void,\u000A                      \"To construct an Buffer<void>, pass a halide_type_t as the first argument to the constructor\");\u000A        int extents[] = {first, second, (int)rest...};\u000A        buf.type = static_halide_type();\u000A        constexpr int buf_dimensions = 2 + (int)(sizeof...(rest));\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape(extents);\u000A        if (!Internal::any_zero(extents)) {\u000A            check_overflow();\u000A            allocate();\u000A        }\u000A    }\u000A    // @}\u000A\u000A    /** Allocate a new image of unknown type using a vector of ints as the size. */\u000A    Buffer(halide_type_t t, const std::vector<int> &sizes) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        buf.type = t;\u000A        make_shape_storage((int)sizes.size());\u000A        initialize_shape(sizes);\u000A        if (!Internal::any_zero(sizes)) {\u000A            check_overflow();\u000A            allocate();\u000A        }\u000A    }\u000A\u000A    /** Allocate a new image of known type using a vector of ints as the size. */\u000A    explicit Buffer(const std::vector<int> &sizes) : Buffer(static_halide_type(), sizes) {}\u000A\u000Aprivate:\u000A    // Create a copy of the sizes vector, ordered as specified by order.\u000A    static std::vector<int> make_ordered_sizes(const std::vector<int> &sizes, const std::vector<int> &order) {\u000A        assert(order.size() == sizes.size());\u000A        std::vector<int> ordered_sizes(sizes.size());\u000A        for (size_t i = 0; i < sizes.size(); ++i) {\u000A            ordered_sizes[i] = sizes.at(order[i]);\u000A        }\u000A        return ordered_sizes;\u000A    }\u000A\u000Apublic:\u000A    /** Allocate a new image of unknown type using a vector of ints as the size and\u000A     * a vector of indices indicating the storage order for each dimension. The\u000A     * length of the sizes vector and the storage-order vector must match. For instance,\u000A     * to allocate an interleaved RGB buffer, you would pass {2, 0, 1} for storage_order. */\u000A    Buffer(halide_type_t t, const std::vector<int> &sizes, const std::vector<int> &storage_order)\u000A        : Buffer(t, make_ordered_sizes(sizes, storage_order)) {\u000A        transpose(storage_order);\u000A    }\u000A\u000A    Buffer(const std::vector<int> &sizes, const std::vector<int> &storage_order)\u000A        : Buffer(static_halide_type(), sizes, storage_order) {}\u000A\u000A    /** Make an Buffer that refers to a statically sized array. Does not\u000A     * take ownership of the data, and does not set the host_dirty flag. */\u000A    template<typename Array, size_t N>\u000A    explicit Buffer(Array (&vals)[N]) {\u000A        const int buf_dimensions = dimensionality_of_array(vals);\u000A        buf.type = scalar_type_of_array(vals);\u000A        buf.host = (uint8_t *)vals;\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape_from_array_shape(buf.dimensions - 1, vals);\u000A    }\u000A\u000A    /** Initialize an Buffer of runtime type from a pointer and some\u000A     * sizes. Assumes dense row-major packing and a min coordinate of\u000A     * zero. Does not take ownership of the data and does not set the\u000A     * host_dirty flag. */\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    explicit Buffer(halide_type_t t, add_const_if_T_is_const<void> *data, int first, Args&&... rest) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        int extents[] = {first, (int)rest...};\u000A        buf.type = t;\u000A        constexpr int buf_dimensions = 1 + (int)(sizeof...(rest));\u000A        buf.host = (uint8_t *) const_cast<void *>(data);\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape(extents);\u000A    }\u000A\u000A    /** Initialize an Buffer from a pointer and some sizes. Assumes\u000A     * dense row-major packing and a min coordinate of zero. Does not\u000A     * take ownership of the data and does not set the host_dirty flag. */\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    explicit Buffer(T *data, int first, Args&&... rest) {\u000A        int extents[] = {first, (int)rest...};\u000A        buf.type = static_halide_type();\u000A        constexpr int buf_dimensions = 1 + (int)(sizeof...(rest));\u000A        buf.host = (uint8_t *) const_cast<typename std::remove_const<T>::type *>(data);\u000A        make_shape_storage(buf_dimensions);\u000A        initialize_shape(extents);\u000A    }\u000A\u000A    /** Initialize an Buffer from a pointer and a vector of\u000A     * sizes. Assumes dense row-major packing and a min coordinate of\u000A     * zero. Does not take ownership of the data and does not set the\u000A     * host_dirty flag. */\u000A    explicit Buffer(T *data, const std::vector<int> &sizes) {\u000A        buf.type = static_halide_type();\u000A        buf.host = (uint8_t *) const_cast<typename std::remove_const<T>::type *>(data);\u000A        make_shape_storage((int)sizes.size());\u000A        initialize_shape(sizes);\u000A    }\u000A\u000A    /** Initialize an Buffer of runtime type from a pointer and a\u000A     * vector of sizes. Assumes dense row-major packing and a min\u000A     * coordinate of zero. Does not take ownership of the data and\u000A     * does not set the host_dirty flag. */\u000A    explicit Buffer(halide_type_t t, add_const_if_T_is_const<void> *data, const std::vector<int> &sizes) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        buf.type = t;\u000A        buf.host = (uint8_t *) const_cast<void *>(data);\u000A        make_shape_storage((int)sizes.size());\u000A        initialize_shape(sizes);\u000A    }\u000A\u000A    /** Initialize an Buffer from a pointer to the min coordinate and\u000A     * an array describing the shape.  Does not take ownership of the\u000A     * data, and does not set the host_dirty flag. */\u000A    explicit Buffer(halide_type_t t, add_const_if_T_is_const<void> *data, int d, const halide_dimension_t *shape) {\u000A        if (!T_is_void) {\u000A            assert(static_halide_type() == t);\u000A        }\u000A        buf.type = t;\u000A        buf.host = (uint8_t *) const_cast<void *>(data);\u000A        make_shape_storage(d);\u000A        for (int i = 0; i < d; i++) {\u000A            buf.dim[i] = shape[i];\u000A        }\u000A    }\u000A\u000A    /** Initialize a Buffer from a pointer to the min coordinate and\u000A     * a vector describing the shape.  Does not take ownership of the\u000A     * data, and does not set the host_dirty flag. */\u000A    explicit inline Buffer(halide_type_t t, add_const_if_T_is_const<void> *data,\u000A                           const std::vector<halide_dimension_t> &shape)\u000A        : Buffer(t, data, (int) shape.size(), shape.data()) {}\u000A\u000A    /** Initialize an Buffer from a pointer to the min coordinate and\u000A     * an array describing the shape.  Does not take ownership of the\u000A     * data and does not set the host_dirty flag. */\u000A    explicit Buffer(T *data, int d, const halide_dimension_t *shape) {\u000A        buf.type = static_halide_type();\u000A        buf.host = (uint8_t *) const_cast<typename std::remove_const<T>::type *>(data);\u000A        make_shape_storage(d);\u000A        for (int i = 0; i < d; i++) {\u000A            buf.dim[i] = shape[i];\u000A        }\u000A    }\u000A\u000A    /** Initialize a Buffer from a pointer to the min coordinate and\u000A     * a vector describing the shape.  Does not take ownership of the\u000A     * data, and does not set the host_dirty flag. */\u000A    explicit inline Buffer(T *data, const std::vector<halide_dimension_t> &shape)\u000A        : Buffer(data, (int) shape.size(), shape.data()) {}\u000A\u000A    /** Destructor. Will release any underlying owned allocation if\u000A     * this is the last reference to it. Will assert fail if there are\u000A     * weak references to this Buffer outstanding. */\u000A    ~Buffer() {\u000A        free_shape_storage();\u000A        decref();\u000A    }\u000A\u000A    /** Get a pointer to the raw halide_buffer_t this wraps. */\u000A    // @{\u000A    halide_buffer_t *raw_buffer() {\u000A        return &buf;\u000A    }\u000A\u000A    const halide_buffer_t *raw_buffer() const {\u000A        return &buf;\u000A    }\u000A    // @}\u000A\u000A    /** Provide a cast operator to halide_buffer_t *, so that\u000A     * instances can be passed directly to Halide filters. */\u000A    operator halide_buffer_t *() {\u000A        return &buf;\u000A    }\u000A\u000A    /** Return a typed reference to this Buffer. Useful for converting\u000A     * a reference to a Buffer<void> to a reference to, for example, a\u000A     * Buffer<const uint8_t>, or converting a Buffer<T>& to Buffer<const T>&.\u000A     * Does a runtime assert if the source buffer type is void. */\u000A    template<typename T2, int D2 = D,\u000A             typename = typename std::enable_if<(D2 <= D)>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<T2, D2> &as() & {\u000A        Buffer<T2, D>::assert_can_convert_from(*this);\u000A        return *((Buffer<T2, D2> *)this);\u000A    }\u000A\u000A    /** Return a const typed reference to this Buffer. Useful for\u000A     * converting a conference reference to one Buffer type to a const\u000A     * reference to another Buffer type. Does a runtime assert if the\u000A     * source buffer type is void. */\u000A    template<typename T2, int D2 = D,\u000A             typename = typename std::enable_if<(D2 <= D)>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    const Buffer<T2, D2> &as() const &  {\u000A        Buffer<T2, D>::assert_can_convert_from(*this);\u000A        return *((const Buffer<T2, D2> *)this);\u000A    }\u000A\u000A    /** Returns this rval Buffer with a different type attached. Does\u000A     * a dynamic type check if the source type is void. */\u000A    template<typename T2, int D2 = D>\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<T2, D2> as() && {\u000A        Buffer<T2, D2>::assert_can_convert_from(*this);\u000A        return *((Buffer<T2, D2> *)this);\u000A    }\u000A\u000A    /** as_const() is syntactic sugar for .as<const T>(), to avoid the need\u000A     * to recapitulate the type argument. */\u000A    // @{\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<typename std::add_const<T>::type, D> &as_const() & {\u000A        // Note that we can skip the assert_can_convert_from(), since T -> const T\u000A        // conversion is always legal.\u000A        return *((Buffer<typename std::add_const<T>::type> *)this);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    const Buffer<typename std::add_const<T>::type, D> &as_const() const & {\u000A        return *((const Buffer<typename std::add_const<T>::type> *)this);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<typename std::add_const<T>::type, D> as_const() && {\u000A        return *((Buffer<typename std::add_const<T>::type> *)this);\u000A    }\u000A    // @}\u000A\u000A    /** Conventional names for the first three dimensions. */\u000A    // @{\u000A    int width() const {\u000A        return (dimensions() > 0) ? dim(0).extent() : 1;\u000A    }\u000A    int height() const {\u000A        return (dimensions() > 1) ? dim(1).extent() : 1;\u000A    }\u000A    int channels() const {\u000A        return (dimensions() > 2) ? dim(2).extent() : 1;\u000A    }\u000A    // @}\u000A\u000A    /** Conventional names for the min and max value of each dimension */\u000A    // @{\u000A    int left() const {\u000A        return dim(0).min();\u000A    }\u000A\u000A    int right() const {\u000A        return dim(0).max();\u000A    }\u000A\u000A    int top() const {\u000A        return dim(1).min();\u000A    }\u000A\u000A    int bottom() const {\u000A        return dim(1).max();\u000A    }\u000A    // @}\u000A\u000A    /** Make a new image which is a deep copy of this image. Use crop\u000A     * or slice followed by copy to make a copy of only a portion of\u000A     * the image. The new image uses the same memory layout as the\u000A     * original, with holes compacted away. Note that the returned\u000A     * Buffer is always of a non-const type T (ie:\u000A     *\u000A     *     Buffer<const T>.copy() -> Buffer<T> rather than Buffer<const T>\u000A     *\u000A     * which is always safe, since we are making a deep copy. (The caller\u000A     * can easily cast it back to Buffer<const T> if desired, which is\u000A     * always safe and free.)\u000A     */\u000A    Buffer<not_const_T, D> copy(void *(*allocate_fn)(size_t) = nullptr,\u000A                                void (*deallocate_fn)(void *) = nullptr) const {\u000A        Buffer<not_const_T, D> dst = Buffer<not_const_T, D>::make_with_shape_of(*this, allocate_fn, deallocate_fn);\u000A        dst.copy_from(*this);\u000A        return dst;\u000A    }\u000A\u000A    /** Like copy(), but the copy is created in interleaved memory layout\u000A     * (vs. keeping the same memory layout as the original). Requires that 'this'\u000A     * has exactly 3 dimensions.\u000A     */\u000A    Buffer<not_const_T, D> copy_to_interleaved(void *(*allocate_fn)(size_t) = nullptr,\u000A                                               void (*deallocate_fn)(void *) = nullptr) const {\u000A        assert(dimensions() == 3);\u000A        Buffer<not_const_T, D> dst = Buffer<not_const_T, D>::make_interleaved(nullptr, width(), height(), channels());\u000A        dst.set_min(min(0), min(1), min(2));\u000A        dst.allocate(allocate_fn, deallocate_fn);\u000A        dst.copy_from(*this);\u000A        return dst;\u000A    }\u000A\u000A    /** Like copy(), but the copy is created in planar memory layout\u000A     * (vs. keeping the same memory layout as the original).\u000A     */\u000A    Buffer<not_const_T, D> copy_to_planar(void *(*allocate_fn)(size_t) = nullptr,\u000A                                          void (*deallocate_fn)(void *) = nullptr) const {\u000A        std::vector<int> mins, extents;\u000A        const int dims = dimensions();\u000A        mins.reserve(dims);\u000A        extents.reserve(dims);\u000A        for (int d = 0; d < dims; ++d) {\u000A            mins.push_back(dim(d).min());\u000A            extents.push_back(dim(d).extent());\u000A        }\u000A        Buffer<not_const_T, D> dst = Buffer<not_const_T, D>(nullptr, extents);\u000A        dst.set_min(mins);\u000A        dst.allocate(allocate_fn, deallocate_fn);\u000A        dst.copy_from(*this);\u000A        return dst;\u000A    }\u000A\u000A    /** Make a copy of the Buffer which shares the underlying host and/or device\u000A     * allocations as the existing Buffer. This is purely syntactic sugar for\u000A     * cases where you have a const reference to a Buffer but need a temporary\u000A     * non-const copy (e.g. to make a call into AOT-generated Halide code), and want a terse\u000A     * inline way to create a temporary. \\code\u000A     * void call_my_func(const Buffer<const uint8_t>& input) {\u000A     *     my_func(input.alias(), output);\u000A     * }\\endcode\u000A     */\u000A    inline Buffer<T, D> alias() const {\u000A        return *this;\u000A    }\u000A\u000A    /** Fill a Buffer with the values at the same coordinates in\u000A     * another Buffer. Restricts itself to coordinates contained\u000A     * within the intersection of the two buffers. If the two Buffers\u000A     * are not in the same coordinate system, you will need to\u000A     * translate the argument Buffer first. E.g. if you're blitting a\u000A     * sprite onto a framebuffer, you'll want to translate the sprite\u000A     * to the correct location first like so: \\code\u000A     * framebuffer.copy_from(sprite.translated({x, y})); \\endcode\u000A    */\u000A    template<typename T2, int D2>\u000A    void copy_from(const Buffer<T2, D2> &other) {\u000A        static_assert(!std::is_const<T>::value, \"Cannot call copy_from() on a Buffer<const T>\");\u000A        assert(!device_dirty() && \"Cannot call Halide::Runtime::Buffer::copy_from on a device dirty destination.\");\u000A        assert(!other.device_dirty() && \"Cannot call Halide::Runtime::Buffer::copy_from on a device dirty source.\");\u000A\u000A        Buffer<const T, D> src(other);\u000A        Buffer<T, D> dst(*this);\u000A\u000A        assert(src.dimensions() == dst.dimensions());\u000A\u000A        // Trim the copy to the region in common\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            int min_coord = std::max(dst.dim(i).min(), src.dim(i).min());\u000A            int max_coord = std::min(dst.dim(i).max(), src.dim(i).max());\u000A            if (max_coord < min_coord) {\u000A                // The buffers do not overlap.\u000A                return;\u000A            }\u000A            dst.crop(i, min_coord, max_coord - min_coord + 1);\u000A            src.crop(i, min_coord, max_coord - min_coord + 1);\u000A        }\u000A\u000A        // If T is void, we need to do runtime dispatch to an\u000A        // appropriately-typed lambda. We're copying, so we only care\u000A        // about the element size. (If not, this should optimize away\u000A        // into a static dispatch to the right-sized copy.)\u000A        if (T_is_void ? (type().bytes() == 1) : (sizeof(not_void_T) == 1)) {\u000A            using MemType = uint8_t;\u000A            auto &typed_dst = (Buffer<MemType, D> &)dst;\u000A            auto &typed_src = (Buffer<const MemType, D> &)src;\u000A            typed_dst.for_each_value([&](MemType &dst, MemType src) {dst = src;}, typed_src);\u000A        } else if (T_is_void ? (type().bytes() == 2) : (sizeof(not_void_T) == 2)) {\u000A            using MemType = uint16_t;\u000A            auto &typed_dst = (Buffer<MemType, D> &)dst;\u000A            auto &typed_src = (Buffer<const MemType, D> &)src;\u000A            typed_dst.for_each_value([&](MemType &dst, MemType src) {dst = src;}, typed_src);\u000A        } else if (T_is_void ? (type().bytes() == 4) : (sizeof(not_void_T) == 4)) {\u000A            using MemType = uint32_t;\u000A            auto &typed_dst = (Buffer<MemType, D> &)dst;\u000A            auto &typed_src = (Buffer<const MemType, D> &)src;\u000A            typed_dst.for_each_value([&](MemType &dst, MemType src) {dst = src;}, typed_src);\u000A        } else if (T_is_void ? (type().bytes() == 8) : (sizeof(not_void_T) == 8)) {\u000A            using MemType = uint64_t;\u000A            auto &typed_dst = (Buffer<MemType, D> &)dst;\u000A            auto &typed_src = (Buffer<const MemType, D> &)src;\u000A            typed_dst.for_each_value([&](MemType &dst, MemType src) {dst = src;}, typed_src);\u000A        } else {\u000A            assert(false && \"type().bytes() must be 1, 2, 4, or 8\");\u000A        }\u000A        set_host_dirty();\u000A    }\u000A\u000A    /** Make an image that refers to a sub-range of this image along\u000A     * the given dimension. Asserts that the crop region is within\u000A     * the existing bounds: you cannot \"crop outwards\", even if you know there\u000A     * is valid Buffer storage (e.g. because you already cropped inwards). */\u000A    Buffer<T, D> cropped(int d, int min, int extent) const {\u000A        // Make a fresh copy of the underlying buffer (but not a fresh\u000A        // copy of the allocation, if there is one).\u000A        Buffer<T, D> im = *this;\u000A\u000A        // This guarantees the prexisting device ref is dropped if the\u000A        // device_crop call fails and maintains the buffer in a consistent\u000A        // state.\u000A        im.device_deallocate();\u000A\u000A        im.crop_host(d, min, extent);\u000A        if (buf.device_interface != nullptr) {\u000A            complete_device_crop(im);\u000A        }\u000A        return im;\u000A    }\u000A\u000A    /** Crop an image in-place along the given dimension. This does\u000A     * not move any data around in memory - it just changes the min\u000A     * and extent of the given dimension. */\u000A    void crop(int d, int min, int extent) {\u000A        // An optimization for non-device buffers. For the device case,\u000A        // a temp buffer is required, so reuse the not-in-place version.\u000A        // TODO(zalman|abadams): Are nop crops common enough to special\u000A        // case the device part of the if to do nothing?\u000A        if (buf.device_interface != nullptr) {\u000A            *this = cropped(d, min, extent);\u000A        } else {\u000A            crop_host(d, min, extent);\u000A        }\u000A    }\u000A\u000A    /** Make an image that refers to a sub-rectangle of this image along\u000A     * the first N dimensions. Asserts that the crop region is within\u000A     * the existing bounds. The cropped image may drop any device handle\u000A     * if the device_interface cannot accomplish the crop in-place. */\u000A    Buffer<T, D> cropped(const std::vector<std::pair<int, int>> &rect) const {\u000A        // Make a fresh copy of the underlying buffer (but not a fresh\u000A        // copy of the allocation, if there is one).\u000A        Buffer<T, D> im = *this;\u000A\u000A        // This guarantees the prexisting device ref is dropped if the\u000A        // device_crop call fails and maintains the buffer in a consistent\u000A        // state.\u000A        im.device_deallocate();\u000A\u000A        im.crop_host(rect);\u000A        if (buf.device_interface != nullptr) {\u000A            complete_device_crop(im);\u000A        }\u000A        return im;\u000A    }\u000A\u000A    /** Crop an image in-place along the first N dimensions. This does\u000A     * not move any data around in memory, nor does it free memory. It\u000A     * just rewrites the min/extent of each dimension to refer to a\u000A     * subregion of the same allocation. */\u000A    void crop(const std::vector<std::pair<int, int>> &rect) {\u000A        // An optimization for non-device buffers. For the device case,\u000A        // a temp buffer is required, so reuse the not-in-place version.\u000A        // TODO(zalman|abadams): Are nop crops common enough to special\u000A        // case the device part of the if to do nothing?\u000A        if (buf.device_interface != nullptr) {\u000A            *this = cropped(rect);\u000A        } else {\u000A            crop_host(rect);\u000A        }\u000A    }\u000A\u000A    /** Make an image which refers to the same data with using\u000A     * translated coordinates in the given dimension. Positive values\u000A     * move the image data to the right or down relative to the\u000A     * coordinate system. Drops any device handle. */\u000A    Buffer<T, D> translated(int d, int dx) const {\u000A        Buffer<T, D> im = *this;\u000A        im.translate(d, dx);\u000A        return im;\u000A    }\u000A\u000A    /** Translate an image in-place along one dimension by changing\u000A     * how it is indexed. Does not move any data around in memory. */\u000A    void translate(int d, int delta) {\u000A        assert(d >= 0 && d < this->dimensions());\u000A        device_deallocate();\u000A        buf.dim[d].min += delta;\u000A    }\u000A\u000A    /** Make an image which refers to the same data translated along\u000A     * the first N dimensions. */\u000A    Buffer<T, D> translated(const std::vector<int> &delta) const {\u000A        Buffer<T, D> im = *this;\u000A        im.translate(delta);\u000A        return im;\u000A    }\u000A\u000A    /** Translate an image along the first N dimensions by changing\u000A     * how it is indexed. Does not move any data around in memory. */\u000A    void translate(const std::vector<int> &delta) {\u000A        device_deallocate();\u000A        assert(delta.size() <= static_cast<decltype(delta.size())>(std::numeric_limits<int>::max()));\u000A        int limit = (int)delta.size();\u000A        assert(limit <= dimensions());\u000A        for (int i = 0; i < limit; i++) {\u000A            translate(i, delta[i]);\u000A        }\u000A    }\u000A\u000A    /** Set the min coordinate of an image in the first N dimensions. */\u000A    // @{\u000A    void set_min(const std::vector<int> &mins) {\u000A        assert(mins.size() <= static_cast<decltype(mins.size())>(dimensions()));\u000A        device_deallocate();\u000A        for (size_t i = 0; i < mins.size(); i++) {\u000A            buf.dim[i].min = mins[i];\u000A        }\u000A    }\u000A\u000A    template<typename ...Args>\u000A    void set_min(Args... args) {\u000A        set_min(std::vector<int>{args...});\u000A    }\u000A    // @}\u000A\u000A    /** Test if a given coordinate is within the bounds of an image. */\u000A    // @{\u000A    bool contains(const std::vector<int> &coords) const {\u000A        assert(coords.size() <= static_cast<decltype(coords.size())>(dimensions()));\u000A        for (size_t i = 0; i < coords.size(); i++) {\u000A            if (coords[i] < dim((int) i).min() || coords[i] > dim((int) i).max()) {\u000A                return false;\u000A            }\u000A        }\u000A        return true;\u000A    }\u000A\u000A    template<typename ...Args>\u000A    bool contains(Args... args) const {\u000A        return contains(std::vector<int>{args...});\u000A    }\u000A    // @}\u000A\u000A    /** Make a buffer which refers to the same data in the same layout\u000A     * using a swapped indexing order for the dimensions given. So\u000A     * A = B.transposed(0, 1) means that A(i, j) == B(j, i), and more\u000A     * strongly that A.address_of(i, j) == B.address_of(j, i). */\u000A    Buffer<T, D> transposed(int d1, int d2) const {\u000A        Buffer<T, D> im = *this;\u000A        im.transpose(d1, d2);\u000A        return im;\u000A    }\u000A\u000A    /** Transpose a buffer in-place by changing how it is indexed. For\u000A     * example, transpose(0, 1) on a two-dimensional buffer means that\u000A     * the value referred to by coordinates (i, j) is now reached at\u000A     * the coordinates (j, i), and vice versa. This is done by\u000A     * reordering the per-dimension metadata rather than by moving\u000A     * data around in memory, so other views of the same memory will\u000A     * not see the data as having been transposed. */\u000A    void transpose(int d1, int d2) {\u000A        assert(d1 >= 0 && d1 < this->dimensions());\u000A        assert(d2 >= 0 && d2 < this->dimensions());\u000A        std::swap(buf.dim[d1], buf.dim[d2]);\u000A    }\u000A\u000A    /** A generalized transpose: instead of swapping two dimensions,\u000A     * pass a vector that lists each dimension index exactly once, in\u000A     * the desired order. This does not move any data around in memory\u000A     * - it just permutes how it is indexed. */\u000A    void transpose(const std::vector<int> &order) {\u000A        assert((int) order.size() == dimensions());\u000A        if (dimensions() < 2) {\u000A            // My, that was easy\u000A            return;\u000A        }\u000A\u000A        std::vector<int> order_sorted = order;\u000A        for (size_t i = 1; i < order_sorted.size(); i++) {\u000A            for (size_t j = i; j > 0 && order_sorted[j-1] > order_sorted[j]; j--) {\u000A                std::swap(order_sorted[j], order_sorted[j-1]);\u000A                transpose(j, j-1);\u000A            }\u000A        }\u000A    }\u000A\u000A    /** Make a buffer which refers to the same data in the same\u000A     * layout using a different ordering of the dimensions. */\u000A    Buffer<T, D> transposed(const std::vector<int> &order) const {\u000A        Buffer<T, D> im = *this;\u000A        im.transpose(order);\u000A        return im;\u000A    }\u000A\u000A    /** Make a lower-dimensional buffer that refers to one slice of\u000A     * this buffer. */\u000A    Buffer<T, D> sliced(int d, int pos) const {\u000A        Buffer<T, D> im = *this;\u000A\u000A        // This guarantees the prexisting device ref is dropped if the\u000A        // device_slice call fails and maintains the buffer in a consistent\u000A        // state.\u000A        im.device_deallocate();\u000A\u000A        im.slice_host(d, pos);\u000A        if (buf.device_interface != nullptr) {\u000A            complete_device_slice(im, d, pos);\u000A        }\u000A        return im;\u000A    }\u000A\u000A    /** Make a lower-dimensional buffer that refers to one slice of this\u000A     * buffer at the dimension's minimum. */\u000A    inline Buffer<T, D> sliced(int d) const {\u000A        return sliced(d, dim(d).min());\u000A    }\u000A\u000A    /** Rewrite the buffer to refer to a single lower-dimensional\u000A     * slice of itself along the given dimension at the given\u000A     * coordinate. Does not move any data around or free the original\u000A     * memory, so other views of the same data are unaffected. */\u000A    void slice(int d, int pos) {\u000A        // An optimization for non-device buffers. For the device case,\u000A        // a temp buffer is required, so reuse the not-in-place version.\u000A        // TODO(zalman|abadams): Are nop slices common enough to special\u000A        // case the device part of the if to do nothing?\u000A        if (buf.device_interface != nullptr) {\u000A            *this = sliced(d, pos);\u000A        } else {\u000A            slice_host(d, pos);\u000A        }\u000A    }\u000A\u000A    /** Slice a buffer in-place at the dimension's minimum. */\u000A    inline void slice(int d) {\u000A        slice(d, dim(d).min());\u000A    }\u000A\u000A    /** Make a new buffer that views this buffer as a single slice in a\u000A     * higher-dimensional space. The new dimension has extent one and\u000A     * the given min. This operation is the opposite of slice. As an\u000A     * example, the following condition is true:\u000A     *\u000A     \\code\u000A     im2 = im.embedded(1, 17);\u000A     &im(x, y, c) == &im2(x, 17, y, c);\u000A     \\endcode\u000A     */\u000A    Buffer<T, D> embedded(int d, int pos = 0) const {\u000A        Buffer<T, D> im(*this);\u000A        im.embed(d, pos);\u000A        return im;\u000A    }\u000A\u000A    /** Embed a buffer in-place, increasing the\u000A     * dimensionality. */\u000A    void embed(int d, int pos = 0) {\u000A        assert(d >= 0 && d <= dimensions());\u000A        add_dimension();\u000A        translate(dimensions() - 1, pos);\u000A        for (int i = dimensions() - 1; i > d; i--) {\u000A            transpose(i, i-1);\u000A        }\u000A    }\u000A\u000A    /** Add a new dimension with a min of zero and an extent of\u000A     * one. The stride is the extent of the outermost dimension times\u000A     * its stride. The new dimension is the last dimension. This is a\u000A     * special case of embed. */\u000A    void add_dimension() {\u000A        const int dims = buf.dimensions;\u000A        buf.dimensions++;\u000A        if (buf.dim != shape) {\u000A            // We're already on the heap. Reallocate.\u000A            halide_dimension_t *new_shape = new halide_dimension_t[buf.dimensions];\u000A            for (int i = 0; i < dims; i++) {\u000A                new_shape[i] = buf.dim[i];\u000A            }\u000A            delete[] buf.dim;\u000A            buf.dim = new_shape;\u000A        } else if (dims == D) {\u000A            // Transition from the in-class storage to the heap\u000A            make_shape_storage(buf.dimensions);\u000A            for (int i = 0; i < dims; i++) {\u000A                buf.dim[i] = shape[i];\u000A            }\u000A        } else {\u000A            // We still fit in the class\u000A        }\u000A        buf.dim[dims] = {0, 1, 0};\u000A        if (dims == 0) {\u000A            buf.dim[dims].stride = 1;\u000A        } else {\u000A            buf.dim[dims].stride = buf.dim[dims-1].extent * buf.dim[dims-1].stride;\u000A        }\u000A    }\u000A\u000A    /** Add a new dimension with a min of zero, an extent of one, and\u000A     * the specified stride. The new dimension is the last\u000A     * dimension. This is a special case of embed. */\u000A    void add_dimension_with_stride(int s) {\u000A        add_dimension();\u000A        buf.dim[buf.dimensions-1].stride = s;\u000A    }\u000A\u000A    /** Methods for managing any GPU allocation. */\u000A    // @{\u000A    // Set the host dirty flag. Called by every operator()\u000A    // access. Must be inlined so it can be hoisted out of loops.\u000A    HALIDE_ALWAYS_INLINE\u000A    void set_host_dirty(bool v = true) {\u000A        assert((!v || !device_dirty()) && \"Cannot set host dirty when device is already dirty.\");\u000A        buf.set_host_dirty(v);\u000A    }\u000A\u000A    // Check if the device allocation is dirty. Called by\u000A    // set_host_dirty, which is called by every accessor. Must be\u000A    // inlined so it can be hoisted out of loops.\u000A    HALIDE_ALWAYS_INLINE\u000A    bool device_dirty() const {\u000A        return buf.device_dirty();\u000A    }\u000A\u000A    bool host_dirty() const {\u000A        return buf.host_dirty();\u000A    }\u000A\u000A    void set_device_dirty(bool v = true) {\u000A        assert((!v || !host_dirty()) && \"Cannot set device dirty when host is already dirty.\");\u000A        buf.set_device_dirty(v);\u000A    }\u000A\u000A    int copy_to_host(void *ctx = nullptr) {\u000A        if (device_dirty()) {\u000A            return buf.device_interface->copy_to_host(ctx, &buf);\u000A        }\u000A        return 0;\u000A    }\u000A\u000A    int copy_to_device(const struct halide_device_interface_t *device_interface, void *ctx = nullptr) {\u000A        if (host_dirty()) {\u000A            return device_interface->copy_to_device(ctx, &buf, device_interface);\u000A        }\u000A        return 0;\u000A    }\u000A\u000A    int device_malloc(const struct halide_device_interface_t *device_interface, void *ctx = nullptr) {\u000A        return device_interface->device_malloc(ctx, &buf, device_interface);\u000A    }\u000A\u000A    int device_free(void *ctx = nullptr) {\u000A        if (dev_ref_count) {\u000A            assert(dev_ref_count->ownership == BufferDeviceOwnership::Allocated &&\u000A                   \"Can't call device_free on an unmanaged or wrapped native device handle. \"\u000A                   \"Free the source allocation or call device_detach_native instead.\");\u000A            // Multiple people may be holding onto this dev field\u000A            assert(dev_ref_count->count == 1 &&\u000A                   \"Multiple Halide::Runtime::Buffer objects share this device \"\u000A                   \"allocation. Freeing it would create dangling references. \"\u000A                   \"Don't call device_free on Halide buffers that you have copied or \"\u000A                   \"passed by value.\");\u000A        }\u000A        int ret = 0;\u000A        if (buf.device_interface) {\u000A            ret = buf.device_interface->device_free(ctx, &buf);\u000A        }\u000A        if (dev_ref_count) {\u000A            delete dev_ref_count;\u000A            dev_ref_count = nullptr;\u000A        }\u000A        return ret;\u000A    }\u000A\u000A    int device_wrap_native(const struct halide_device_interface_t *device_interface,\u000A                           uint64_t handle, void *ctx = nullptr) {\u000A        assert(device_interface);\u000A        dev_ref_count = new DeviceRefCount;\u000A        dev_ref_count->ownership = BufferDeviceOwnership::WrappedNative;\u000A        return device_interface->wrap_native(ctx, &buf, handle, device_interface);\u000A    }\u000A\u000A    int device_detach_native(void *ctx = nullptr) {\u000A        assert(dev_ref_count &&\u000A               dev_ref_count->ownership == BufferDeviceOwnership::WrappedNative &&\u000A               \"Only call device_detach_native on buffers wrapping a native \"\u000A               \"device handle via device_wrap_native. This buffer was allocated \"\u000A               \"using device_malloc, or is unmanaged. \"\u000A               \"Call device_free or free the original allocation instead.\");\u000A        // Multiple people may be holding onto this dev field\u000A        assert(dev_ref_count->count == 1 &&\u000A               \"Multiple Halide::Runtime::Buffer objects share this device \"\u000A               \"allocation. Freeing it could create dangling references. \"\u000A               \"Don't call device_detach_native on Halide buffers that you \"\u000A               \"have copied or passed by value.\");\u000A        int ret = 0;\u000A        if (buf.device_interface) {\u000A            ret = buf.device_interface->detach_native(ctx, &buf);\u000A        }\u000A        delete dev_ref_count;\u000A        dev_ref_count = nullptr;\u000A        return ret;\u000A    }\u000A\u000A    int device_and_host_malloc(const struct halide_device_interface_t *device_interface, void *ctx = nullptr) {\u000A        return device_interface->device_and_host_malloc(ctx, &buf, device_interface);\u000A    }\u000A\u000A    int device_and_host_free(const struct halide_device_interface_t *device_interface, void *ctx = nullptr) {\u000A        if (dev_ref_count) {\u000A            assert(dev_ref_count->ownership == BufferDeviceOwnership::AllocatedDeviceAndHost &&\u000A                   \"Can't call device_and_host_free on a device handle not allocated with device_and_host_malloc. \"\u000A                   \"Free the source allocation or call device_detach_native instead.\");\u000A            // Multiple people may be holding onto this dev field\u000A            assert(dev_ref_count->count == 1 &&\u000A                   \"Multiple Halide::Runtime::Buffer objects share this device \"\u000A                   \"allocation. Freeing it would create dangling references. \"\u000A                   \"Don't call device_and_host_free on Halide buffers that you have copied or \"\u000A                   \"passed by value.\");\u000A        }\u000A        int ret = 0;\u000A        if (buf.device_interface) {\u000A            ret = buf.device_interface->device_and_host_free(ctx, &buf);\u000A        }\u000A        if (dev_ref_count) {\u000A            delete dev_ref_count;\u000A            dev_ref_count = nullptr;\u000A        }\u000A        return ret;\u000A    }\u000A\u000A    int device_sync(void *ctx = nullptr) {\u000A        if (buf.device_interface) {\u000A            return buf.device_interface->device_sync(ctx, &buf);\u000A        } else {\u000A            return 0;\u000A        }\u000A    }\u000A\u000A    bool has_device_allocation() const {\u000A        return buf.device != 0;\u000A    }\u000A\u000A    /** Return the method by which the device field is managed. */\u000A    BufferDeviceOwnership device_ownership() const {\u000A        if (dev_ref_count == nullptr) {\u000A            return BufferDeviceOwnership::Allocated;\u000A        }\u000A        return dev_ref_count->ownership;\u000A    }\u000A    // @}\u000A\u000A    /** If you use the (x, y, c) indexing convention, then Halide\u000A     * Buffers are stored planar by default. This function constructs\u000A     * an interleaved RGB or RGBA image that can still be indexed\u000A     * using (x, y, c). Passing it to a generator requires that the\u000A     * generator has been compiled with support for interleaved (also\u000A     * known as packed or chunky) memory layouts. */\u000A    static Buffer<void, D> make_interleaved(halide_type_t t, int width, int height, int channels) {\u000A        Buffer<void, D> im(t, channels, width, height);\u000A        // Note that this is equivalent to calling transpose({2, 0, 1}),\u000A        // but slightly more efficient.\u000A        im.transpose(0, 1);\u000A        im.transpose(1, 2);\u000A        return im;\u000A    }\u000A\u000A    /** If you use the (x, y, c) indexing convention, then Halide\u000A     * Buffers are stored planar by default. This function constructs\u000A     * an interleaved RGB or RGBA image that can still be indexed\u000A     * using (x, y, c). Passing it to a generator requires that the\u000A     * generator has been compiled with support for interleaved (also\u000A     * known as packed or chunky) memory layouts. */\u000A    static Buffer<T, D> make_interleaved(int width, int height, int channels) {\u000A        return make_interleaved(static_halide_type(), width, height, channels);\u000A    }\u000A\u000A    /** Wrap an existing interleaved image. */\u000A    static Buffer<add_const_if_T_is_const<void>, D>\u000A    make_interleaved(halide_type_t t, T *data, int width, int height, int channels) {\u000A        Buffer<add_const_if_T_is_const<void>, D> im(t, data, channels, width, height);\u000A        im.transpose(0, 1);\u000A        im.transpose(1, 2);\u000A        return im;\u000A    }\u000A\u000A    /** Wrap an existing interleaved image. */\u000A    static Buffer<T, D> make_interleaved(T *data, int width, int height, int channels) {\u000A        return make_interleaved(static_halide_type(), data, width, height, channels);\u000A    }\u000A\u000A    /** Make a zero-dimensional Buffer */\u000A    static Buffer<add_const_if_T_is_const<void>, D> make_scalar(halide_type_t t) {\u000A        Buffer<add_const_if_T_is_const<void>, 1> buf(t, 1);\u000A        buf.slice(0, 0);\u000A        return buf;\u000A    }\u000A\u000A    /** Make a zero-dimensional Buffer */\u000A    static Buffer<T, D> make_scalar() {\u000A        Buffer<T, 1> buf(1);\u000A        buf.slice(0, 0);\u000A        return buf;\u000A    }\u000A\u000A    /** Make a zero-dimensional Buffer that points to non-owned, existing data */\u000A    static Buffer<T, D> make_scalar(T* data) {\u000A        Buffer<T, 1> buf(data, 1);\u000A        buf.slice(0, 0);\u000A        return buf;\u000A    }\u000A\u000A    /** Make a buffer with the same shape and memory nesting order as\u000A     * another buffer. It may have a different type. */\u000A    template<typename T2, int D2>\u000A    static Buffer<T, D> make_with_shape_of(Buffer<T2, D2> src,\u000A                                           void *(*allocate_fn)(size_t) = nullptr,\u000A                                           void (*deallocate_fn)(void *) = nullptr) {\u000A\u000A        const halide_type_t dst_type = T_is_void\u000A            ? src.type()\u000A            : halide_type_of<typename std::remove_cv<not_void_T>::type>();\u000A        return Buffer<>::make_with_shape_of_helper(dst_type, src.\u000A                                                   dimensions(), src.buf.dim,\u000A                                                   allocate_fn, deallocate_fn);\u000A    }\u000A\u000Aprivate:\u000A\u000A    static Buffer<> make_with_shape_of_helper(halide_type_t dst_type,\u000A                                              int dimensions,\u000A                                              halide_dimension_t *shape,\u000A                                              void *(*allocate_fn)(size_t),\u000A                                              void (*deallocate_fn)(void *)) {\u000A        // Reorder the dimensions of src to have strides in increasing order\u000A        std::vector<int> swaps;\u000A        for (int i = dimensions - 1; i > 0; i--) {\u000A            for (int j = i; j > 0; j--) {\u000A                if (shape[j-1].stride > shape[j].stride) {\u000A                    std::swap(shape[j-1], shape[j]);\u000A                    swaps.push_back(j);\u000A                }\u000A            }\u000A        }\u000A\u000A        // Rewrite the strides to be dense (this messes up src, which\u000A        // is why we took it by value).\u000A        for (int i = 0; i < dimensions; i++) {\u000A            if (i == 0) {\u000A                shape[i].stride = 1;\u000A            } else {\u000A                shape[i].stride = shape[i-1].extent * shape[i-1].stride;\u000A            }\u000A        }\u000A\u000A        // Undo the dimension reordering\u000A        while (!swaps.empty()) {\u000A            int j = swaps.back();\u000A            std::swap(shape[j-1], shape[j]);\u000A            swaps.pop_back();\u000A        }\u000A\u000A        // Use an explicit runtime type, and make dst a Buffer<void>, to allow\u000A        // using this method with Buffer<void> for either src or dst.\u000A        Buffer<> dst(dst_type, nullptr, dimensions, shape);\u000A        dst.allocate(allocate_fn, deallocate_fn);\u000A\u000A        return dst;\u000A    }\u000A\u000A    template<typename ...Args>\u000A    HALIDE_ALWAYS_INLINE\u000A    ptrdiff_t offset_of(int d, int first, Args... rest) const {\u000A        return offset_of(d+1, rest...) + this->buf.dim[d].stride * (first - this->buf.dim[d].min);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    ptrdiff_t offset_of(int d) const {\u000A        return 0;\u000A    }\u000A\u000A    template<typename ...Args>\u000A    HALIDE_ALWAYS_INLINE\u000A    storage_T *address_of(Args... args) const {\u000A        if (T_is_void) {\u000A            return (storage_T *)(this->buf.host) + offset_of(0, args...) * type().bytes();\u000A        } else {\u000A            return (storage_T *)(this->buf.host) + offset_of(0, args...);\u000A        }\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    ptrdiff_t offset_of(const int *pos) const {\u000A        ptrdiff_t offset = 0;\u000A        for (int i = this->dimensions() - 1; i >= 0; i--) {\u000A            offset += this->buf.dim[i].stride * (pos[i] - this->buf.dim[i].min);\u000A        }\u000A        return offset;\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    storage_T *address_of(const int *pos) const {\u000A        if (T_is_void) {\u000A            return (storage_T *)this->buf.host + offset_of(pos) * type().bytes();\u000A        } else {\u000A            return (storage_T *)this->buf.host + offset_of(pos);\u000A        }\u000A    }\u000A\u000Apublic:\u000A\u000A    /** Get a pointer to the address of the min coordinate. */\u000A    T *data() const {\u000A        return (T *)(this->buf.host);\u000A    }\u000A\u000A    /** Access elements. Use im(...) to get a reference to an element,\u000A     * and use &im(...) to get the address of an element. If you pass\u000A     * fewer arguments than the buffer has dimensions, the rest are\u000A     * treated as their min coordinate. The non-const versions set the\u000A     * host_dirty flag to true.\u000A     */\u000A    //@{\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    const not_void_T &operator()(int first, Args... rest) const {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        assert(!device_dirty());\u000A        return *((const not_void_T *)(address_of(first, rest...)));\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    const not_void_T &\u000A    operator()() const {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        assert(!device_dirty());\u000A        return *((const not_void_T *)(data()));\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    const not_void_T &\u000A    operator()(const int *pos) const {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        assert(!device_dirty());\u000A        return *((const not_void_T *)(address_of(pos)));\u000A    }\u000A\u000A    template<typename ...Args,\u000A             typename = typename std::enable_if<AllInts<Args...>::value>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    not_void_T &operator()(int first, Args... rest) {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        set_host_dirty();\u000A        return *((not_void_T *)(address_of(first, rest...)));\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    not_void_T &\u000A    operator()() {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        set_host_dirty();\u000A        return *((not_void_T *)(data()));\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    not_void_T &\u000A    operator()(const int *pos) {\u000A        static_assert(!T_is_void,\u000A                      \"Cannot use operator() on Buffer<void> types\");\u000A        set_host_dirty();\u000A        return *((not_void_T *)(address_of(pos)));\u000A    }\u000A    // @}\u000A\u000A    /** Tests that all values in this buffer are equal to val. */\u000A    bool all_equal(not_void_T val) const{\u000A        bool all_equal = true;\u000A        for_each_element([&](const int *pos) {all_equal &= (*this)(pos) == val;});\u000A        return all_equal;\u000A    }\u000A\u000A    Buffer<T, D> &fill(not_void_T val) {\u000A        set_host_dirty();\u000A        for_each_value([=](T &v) {v = val;});\u000A        return *this;\u000A    }\u000A\u000Aprivate:\u000A    /** Helper functions for for_each_value. */\u000A    // @{\u000A    template<int N>\u000A    struct for_each_value_task_dim {\u000A        int extent;\u000A        int stride[N];\u000A    };\u000A\u000A    // Given an array of strides, and a bunch of pointers to pointers\u000A    // (all of different types), advance the pointers using the\u000A    // strides.\u000A    template<typename Ptr, typename ...Ptrs>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void advance_ptrs(const int *stride, Ptr *ptr, Ptrs... ptrs) {\u000A        (*ptr) += *stride;\u000A        advance_ptrs(stride + 1, ptrs...);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    static void advance_ptrs(const int *) {}\u000A\u000A    // Same as the above, but just increments the pointers.\u000A    template<typename Ptr, typename ...Ptrs>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void increment_ptrs(Ptr *ptr, Ptrs... ptrs) {\u000A        (*ptr)++;\u000A        increment_ptrs(ptrs...);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE\u000A    static void increment_ptrs() {}\u000A\u000A    template<typename Fn, typename... Ptrs>\u000A    HALIDE_NEVER_INLINE\u000A    static void for_each_value_helper(Fn &&f, int d, bool innermost_strides_are_one,\u000A                                      const for_each_value_task_dim<sizeof...(Ptrs)> *t, Ptrs... ptrs) {\u000A        if (d == -1) {\u000A            f((*ptrs)...);\u000A        } else if (d == 0) {\u000A            if (innermost_strides_are_one) {\u000A                for (int i = t[0].extent; i != 0; i--) {\u000A                    f((*ptrs)...);\u000A                    increment_ptrs((&ptrs)...);\u000A                }\u000A            } else {\u000A                for (int i = t[0].extent; i != 0; i--) {\u000A                    f((*ptrs)...);\u000A                    advance_ptrs(t[0].stride, (&ptrs)...);\u000A                }\u000A            }\u000A        } else {\u000A            for (int i = t[d].extent; i != 0; i--) {\u000A                for_each_value_helper(f, d-1, innermost_strides_are_one, t, ptrs...);\u000A                advance_ptrs(t[d].stride, (&ptrs)...);\u000A            }\u000A        }\u000A    }\u000A\u000A    template<int N>\u000A    HALIDE_NEVER_INLINE\u000A    static bool for_each_value_prep(for_each_value_task_dim<N> *t,\u000A                                    const halide_buffer_t **buffers) {\u000A        const int dimensions = buffers[0]->dimensions;\u000A\u000A        // Extract the strides in all the dimensions\u000A        for (int i = 0; i < dimensions; i++) {\u000A            for (int j = 0; j < N; j++) {\u000A                assert(buffers[j]->dimensions == dimensions);\u000A                assert(buffers[j]->dim[i].extent == buffers[0]->dim[i].extent &&\u000A                       buffers[j]->dim[i].min == buffers[0]->dim[i].min);\u000A                const int s = buffers[j]->dim[i].stride;\u000A                t[i].stride[j] = s;\u000A            }\u000A            t[i].extent = buffers[0]->dim[i].extent;\u000A\u000A            // Order the dimensions by stride, so that the traversal is cache-coherent.\u000A            for (int j = i; j > 0 && t[j].stride[0] < t[j-1].stride[0]; j--) {\u000A                std::swap(t[j], t[j-1]);\u000A            }\u000A        }\u000A\u000A        // flatten dimensions where possible to make a larger inner\u000A        // loop for autovectorization.\u000A        int d = dimensions;\u000A        for (int i = 1; i < d; i++) {\u000A            bool flat = true;\u000A            for (int j = 0; j < N; j++) {\u000A                flat = flat && t[i-1].stride[j] * t[i-1].extent == t[i].stride[j];\u000A            }\u000A            if (flat) {\u000A                t[i-1].extent *= t[i].extent;\u000A                for (int j = i; j < d; j++) {\u000A                    t[j] = t[j+1];\u000A                }\u000A                i--;\u000A                d--;\u000A                t[d].extent = 1;\u000A            }\u000A        }\u000A\u000A        bool innermost_strides_are_one = true;\u000A        if (dimensions > 0) {\u000A            for (int i = 0; i < N; i++) {\u000A                innermost_strides_are_one &= (t[0].stride[i] == 1);\u000A            }\u000A        }\u000A\u000A        return innermost_strides_are_one;\u000A    }\u000A\u000A    template<typename Fn, typename ...Args, int N = sizeof...(Args) + 1>\u000A    void for_each_value_impl(Fn &&f, Args&&... other_buffers) const {\u000A        Buffer<>::for_each_value_task_dim<N> *t =\u000A        (Buffer<>::for_each_value_task_dim<N> *)HALIDE_ALLOCA((dimensions()+1) * sizeof(for_each_value_task_dim<N>));\u000A        // Move the preparatory code into a non-templated helper to\u000A        // save code size.\u000A        const halide_buffer_t *buffers[] = {&buf, (&other_buffers.buf)...};\u000A        bool innermost_strides_are_one = Buffer<>::for_each_value_prep(t, buffers);\u000A\u000A        Buffer<>::for_each_value_helper(f, dimensions() - 1,\u000A                                        innermost_strides_are_one,\u000A                                        t,\u000A                                        data(), (other_buffers.data())...);\u000A    }\u000A    // @}\u000A\u000Apublic:\u000A    /** Call a function on every value in the buffer, and the\u000A     * corresponding values in some number of other buffers of the\u000A     * same size. The function should take a reference, const\u000A     * reference, or value of the correct type for each buffer. This\u000A     * effectively lifts a function of scalars to an element-wise\u000A     * function of buffers. This produces code that the compiler can\u000A     * autovectorize. This is slightly cheaper than for_each_element,\u000A     * because it does not need to track the coordinates.\u000A     *\u000A     * Note that constness of Buffers is preserved: a const Buffer<T> (for either\u000A     * 'this' or the other-buffers arguments) will allow mutation of the\u000A     * buffer contents, while a Buffer<const T> will not. Attempting to specify\u000A     * a mutable reference for the lambda argument of a Buffer<const T>\u000A     * will result in a compilation error. */\u000A    // @{\u000A    template<typename Fn, typename ...Args, int N = sizeof...(Args) + 1>\u000A    HALIDE_ALWAYS_INLINE\u000A    const Buffer<T, D> &for_each_value(Fn &&f, Args&&... other_buffers) const {\u000A        for_each_value_impl(f, std::forward<Args>(other_buffers)...);\u000A        return *this;\u000A    }\u000A\u000A    template<typename Fn, typename ...Args, int N = sizeof...(Args) + 1>\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<T, D> &for_each_value(Fn &&f, Args&&... other_buffers) {\u000A        for_each_value_impl(f, std::forward<Args>(other_buffers)...);\u000A        return *this;\u000A    }\u000A    // @}\u000A\u000Aprivate:\u000A\u000A    // Helper functions for for_each_element\u000A    struct for_each_element_task_dim {\u000A        int min, max;\u000A    };\u000A\u000A    /** If f is callable with this many args, call it. The first\u000A     * argument is just to make the overloads distinct. Actual\u000A     * overload selection is done using the enable_if. */\u000A    template<typename Fn,\u000A             typename ...Args,\u000A             typename = decltype(std::declval<Fn>()(std::declval<Args>()...))>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void for_each_element_variadic(int, int, const for_each_element_task_dim *, Fn &&f, Args... args) {\u000A        f(args...);\u000A    }\u000A\u000A    /** If the above overload is impossible, we add an outer loop over\u000A     * an additional argument and try again. */\u000A    template<typename Fn,\u000A             typename ...Args>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void for_each_element_variadic(double, int d, const for_each_element_task_dim *t, Fn &&f, Args... args) {\u000A        for (int i = t[d].min; i <= t[d].max; i++) {\u000A            for_each_element_variadic(0, d - 1, t, std::forward<Fn>(f), i, args...);\u000A        }\u000A    }\u000A\u000A    /** Determine the minimum number of arguments a callable can take\u000A     * using the same trick. */\u000A    template<typename Fn,\u000A             typename ...Args,\u000A             typename = decltype(std::declval<Fn>()(std::declval<Args>()...))>\u000A    HALIDE_ALWAYS_INLINE\u000A    static int num_args(int, Fn &&, Args...) {\u000A        return (int)(sizeof...(Args));\u000A    }\u000A\u000A    /** The recursive version is only enabled up to a recursion limit\u000A     * of 256. This catches callables that aren't callable with any\u000A     * number of ints. */\u000A    template<typename Fn,\u000A             typename ...Args>\u000A    HALIDE_ALWAYS_INLINE\u000A    static int num_args(double, Fn &&f, Args... args) {\u000A        static_assert(sizeof...(args) <= 256,\u000A                      \"Callable passed to for_each_element must accept either a const int *,\"\u000A                      \" or up to 256 ints. No such operator found. Expect infinite template recursion.\");\u000A        return num_args(0, std::forward<Fn>(f), 0, args...);\u000A    }\u000A\u000A    /** A version where the callable takes a position array instead,\u000A     * with compile-time recursion on the dimensionality.  This\u000A     * overload is preferred to the one below using the same int vs\u000A     * double trick as above, but is impossible once d hits -1 using\u000A     * std::enable_if. */\u000A    template<int d,\u000A             typename Fn,\u000A             typename = typename std::enable_if<(d >= 0)>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void for_each_element_array_helper(int, const for_each_element_task_dim *t, Fn &&f, int *pos) {\u000A        for (pos[d] = t[d].min; pos[d] <= t[d].max; pos[d]++) {\u000A            for_each_element_array_helper<d - 1>(0, t, std::forward<Fn>(f), pos);\u000A        }\u000A    }\u000A\u000A    /** Base case for recursion above. */\u000A    template<int d,\u000A             typename Fn,\u000A             typename = typename std::enable_if<(d < 0)>::type>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void for_each_element_array_helper(double, const for_each_element_task_dim *t, Fn &&f, int *pos) {\u000A        f(pos);\u000A    }\u000A\u000A    /** A run-time-recursive version (instead of\u000A     * compile-time-recursive) that requires the callable to take a\u000A     * pointer to a position array instead. Dispatches to the\u000A     * compile-time-recursive version once the dimensionality gets\u000A     * small. */\u000A    template<typename Fn>\u000A    static void for_each_element_array(int d, const for_each_element_task_dim *t, Fn &&f, int *pos) {\u000A        if (d == -1) {\u000A            f(pos);\u000A        } else if (d == 0) {\u000A            // Once the dimensionality gets small enough, dispatch to\u000A            // a compile-time-recursive version for better codegen of\u000A            // the inner loops.\u000A            for_each_element_array_helper<0, Fn>(0, t, std::forward<Fn>(f), pos);\u000A        } else if (d == 1) {\u000A            for_each_element_array_helper<1, Fn>(0, t, std::forward<Fn>(f), pos);\u000A        } else if (d == 2) {\u000A            for_each_element_array_helper<2, Fn>(0, t, std::forward<Fn>(f), pos);\u000A        } else if (d == 3) {\u000A            for_each_element_array_helper<3, Fn>(0, t, std::forward<Fn>(f), pos);\u000A        } else {\u000A            for (pos[d] = t[d].min; pos[d] <= t[d].max; pos[d]++) {\u000A                for_each_element_array(d - 1, t, std::forward<Fn>(f), pos);\u000A            }\u000A        }\u000A    }\u000A\u000A    /** We now have two overloads for for_each_element. This one\u000A     * triggers if the callable takes a const int *.\u000A     */\u000A    template<typename Fn,\u000A             typename = decltype(std::declval<Fn>()((const int *)nullptr))>\u000A    static void for_each_element(int, int dims, const for_each_element_task_dim *t, Fn &&f, int check = 0) {\u000A        int *pos = (int *)HALIDE_ALLOCA(dims * sizeof(int));\u000A        for_each_element_array(dims - 1, t, std::forward<Fn>(f), pos);\u000A    }\u000A\u000A    /** This one triggers otherwise. It treats the callable as\u000A     * something that takes some number of ints. */\u000A    template<typename Fn>\u000A    HALIDE_ALWAYS_INLINE\u000A    static void for_each_element(double, int dims, const for_each_element_task_dim *t, Fn &&f) {\u000A        int args = num_args(0, std::forward<Fn>(f));\u000A        assert(dims >= args);\u000A        for_each_element_variadic(0, args - 1, t, std::forward<Fn>(f));\u000A    }\u000A\u000A    template<typename Fn>\u000A    void for_each_element_impl(Fn &&f) const {\u000A        for_each_element_task_dim *t =\u000A            (for_each_element_task_dim *)HALIDE_ALLOCA(dimensions() * sizeof(for_each_element_task_dim));\u000A        for (int i = 0; i < dimensions(); i++) {\u000A            t[i].min = dim(i).min();\u000A            t[i].max = dim(i).max();\u000A        }\u000A        for_each_element(0, dimensions(), t, std::forward<Fn>(f));\u000A    }\u000A\u000Apublic:\u000A    /** Call a function at each site in a buffer. This is likely to be\u000A     * much slower than using Halide code to populate a buffer, but is\u000A     * convenient for tests. If the function has more arguments than the\u000A     * buffer has dimensions, the remaining arguments will be zero. If it\u000A     * has fewer arguments than the buffer has dimensions then the last\u000A     * few dimensions of the buffer are not iterated over. For example,\u000A     * the following code exploits this to set a floating point RGB image\u000A     * to red:\u000A\u000A     \\code\u000A     Buffer<float, 3> im(100, 100, 3);\u000A     im.for_each_element([&](int x, int y) {\u000A         im(x, y, 0) = 1.0f;\u000A         im(x, y, 1) = 0.0f;\u000A         im(x, y, 2) = 0.0f:\u000A     });\u000A     \\endcode\u000A\u000A     * The compiled code is equivalent to writing the a nested for loop,\u000A     * and compilers are capable of optimizing it in the same way.\u000A     *\u000A     * If the callable can be called with an int * as the sole argument,\u000A     * that version is called instead. Each location in the buffer is\u000A     * passed to it in a coordinate array. This version is higher-overhead\u000A     * than the variadic version, but is useful for writing generic code\u000A     * that accepts buffers of arbitrary dimensionality. For example, the\u000A     * following sets the value at all sites in an arbitrary-dimensional\u000A     * buffer to their first coordinate:\u000A\u000A     \\code\u000A     im.for_each_element([&](const int *pos) {im(pos) = pos[0];});\u000A     \\endcode\u000A\u000A     * It is also possible to use for_each_element to iterate over entire\u000A     * rows or columns by cropping the buffer to a single column or row\u000A     * respectively and iterating over elements of the result. For example,\u000A     * to set the diagonal of the image to 1 by iterating over the columns:\u000A\u000A     \\code\u000A     Buffer<float, 3> im(100, 100, 3);\u000A         im.sliced(1, 0).for_each_element([&](int x, int c) {\u000A         im(x, x, c) = 1.0f;\u000A     });\u000A     \\endcode\u000A\u000A     * Or, assuming the memory layout is known to be dense per row, one can\u000A     * memset each row of an image like so:\u000A\u000A     \\code\u000A     Buffer<float, 3> im(100, 100, 3);\u000A     im.sliced(0, 0).for_each_element([&](int y, int c) {\u000A         memset(&im(0, y, c), 0, sizeof(float) * im.width());\u000A     });\u000A     \\endcode\u000A\u000A    */\u000A    // @{\u000A    template<typename Fn>\u000A    HALIDE_ALWAYS_INLINE\u000A    const Buffer<T, D> &for_each_element(Fn &&f) const {\u000A        for_each_element_impl(f);\u000A        return *this;\u000A    }\u000A\u000A    template<typename Fn>\u000A    HALIDE_ALWAYS_INLINE\u000A    Buffer<T, D> &for_each_element(Fn &&f) {\u000A        for_each_element_impl(f);\u000A        return *this;\u000A    }\u000A    // @}\u000A\u000Aprivate:\u000A    template<typename Fn>\u000A    struct FillHelper {\u000A        Fn f;\u000A        Buffer<T, D> *buf;\u000A\u000A        template<typename... Args,\u000A                 typename = decltype(std::declval<Fn>()(std::declval<Args>()...))>\u000A        void operator()(Args... args) {\u000A            (*buf)(args...) = f(args...);\u000A        }\u000A\u000A        FillHelper(Fn &&f, Buffer<T, D> *buf) : f(std::forward<Fn>(f)), buf(buf) {}\u000A    };\u000A\u000Apublic:\u000A    /** Fill a buffer by evaluating a callable at every site. The\u000A     * callable should look much like a callable passed to\u000A     * for_each_element, but it should return the value that should be\u000A     * stored to the coordinate corresponding to the arguments. */\u000A    template<typename Fn,\u000A             typename = typename std::enable_if<!std::is_arithmetic<typename std::decay<Fn>::type>::value>::type>\u000A    Buffer<T, D> &fill(Fn &&f) {\u000A        // We'll go via for_each_element. We need a variadic wrapper lambda.\u000A        FillHelper<Fn> wrapper(std::forward<Fn>(f), this);\u000A        return for_each_element(wrapper);\u000A    }\u000A\u000A    /** Check if an input buffer passed extern stage is a querying\u000A     * bounds. Compared to doing the host pointer check directly,\u000A     * this both adds clarity to code and will facilitate moving to\u000A     * another representation for bounds query arguments. */\u000A    bool is_bounds_query() const {\u000A        return buf.is_bounds_query();\u000A    }\u000A\u000A    /** Convenient check to verify that all of the interesting bytes in the Buffer\u000A     * are initialized under MSAN. Note that by default, we use for_each_value() here so that\u000A     * we skip any unused padding that isn't part of the Buffer; this isn't efficient,\u000A     * but in MSAN mode, it doesn't matter. (Pass true for the flag to force check\u000A     * the entire Buffer storage.) */\u000A    void msan_check_mem_is_initialized(bool entire = false) const {\u000A#if defined(__has_feature)\u000A#if __has_feature(memory_sanitizer)\u000A        if (entire) {\u000A            __msan_check_mem_is_initialized(data(), size_in_bytes());\u000A        } else {\u000A            for_each_value([](T &v) { __msan_check_mem_is_initialized(&v, sizeof(T)); ;});\u000A        }\u000A#endif\u000A#endif\u000A    }\u000A};\u000A\u000A}  // namespace Runtime\u000A}  // namespace Halide\u000A\u000A#undef HALIDE_ALLOCA\u000A\u000A#endif  // HALIDE_RUNTIME_IMAGE_H\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/tools/Halide/include/HalideRuntime.h", "name":"HalideRuntime.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/tools/Halide/include/HalideRuntime.h", "content":"#ifndef HALIDE_HALIDERUNTIME_H\u000A#define HALIDE_HALIDERUNTIME_H\u000A\u000A#ifndef COMPILING_HALIDE_RUNTIME\u000A#include <stdbool.h>\u000A#include <stddef.h>\u000A#include <stdint.h>\u000A#include <string.h>\u000A#else\u000A#include \"runtime_internal.h\"\u000A#endif\u000A\u000A#ifdef __cplusplus\u000A// Forward declare type to allow naming typed handles.\u000A// See Type.h for documentation.\u000Atemplate<typename T> struct halide_handle_traits;\u000A#endif\u000A\u000A#ifdef __cplusplus\u000Aextern \"C\" {\u000A#endif\u000A\u000A// Note that you should not use \"inline\" along with HALIDE_ALWAYS_INLINE;\u000A// it is not necessary, and may produce warnings for some build configurations.\u000A#ifdef _MSC_VER\u000A#define HALIDE_ALWAYS_INLINE __forceinline\u000A#define HALIDE_NEVER_INLINE __declspec(noinline)\u000A#else\u000A#define HALIDE_ALWAYS_INLINE __attribute__((always_inline)) inline\u000A#define HALIDE_NEVER_INLINE __attribute__((noinline))\u000A#endif\u000A\u000A#ifndef HALIDE_MUST_USE_RESULT\u000A#ifdef __has_attribute\u000A#if __has_attribute(nodiscard)\u000A// C++17 or later\u000A#define HALIDE_MUST_USE_RESULT [[nodiscard]]\u000A#elif __has_attribute(warn_unused_result)\u000A// Clang/GCC\u000A#define HALIDE_MUST_USE_RESULT __attribute__((warn_unused_result))\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#endif\u000A\u000A/** \\file\u000A *\u000A * This file declares the routines used by Halide internally in its\u000A * runtime. On platforms that support weak linking, these can be\u000A * replaced with user-defined versions by defining an extern \"C\"\u000A * function with the same name and signature.\u000A *\u000A * When doing Just In Time (JIT) compilation methods on the Func being\u000A * compiled must be called instead. The corresponding methods are\u000A * documented below.\u000A *\u000A * All of these functions take a \"void *user_context\" parameter as their\u000A * first argument; if the Halide kernel that calls back to any of these\u000A * functions has been compiled with the UserContext feature set on its Target,\u000A * then the value of that pointer passed from the code that calls the\u000A * Halide kernel is piped through to the function.\u000A *\u000A * Some of these are also useful to call when using the default\u000A * implementation. E.g. halide_shutdown_thread_pool.\u000A *\u000A * Note that even on platforms with weak linking, some linker setups\u000A * may not respect the override you provide. E.g. if the override is\u000A * in a shared library and the halide object files are linked directly\u000A * into the output, the builtin versions of the runtime functions will\u000A * be called. See your linker documentation for more details. On\u000A * Linux, LD_DYNAMIC_WEAK=1 may help.\u000A *\u000A */\u000A\u000A// Forward-declare to suppress warnings if compiling as C.\u000Astruct halide_buffer_t;\u000Astruct buffer_t;\u000A\u000A/** Print a message to stderr. Main use is to support tracing\u000A * functionality, print, and print_when calls. Also called by the default\u000A * halide_error.  This function can be replaced in JITed code by using\u000A * halide_custom_print and providing an implementation of halide_print\u000A * in AOT code. See Func::set_custom_print.\u000A */\u000A// @{\u000Aextern void halide_print(void *user_context, const char *);\u000Aextern void halide_default_print(void *user_context, const char *);\u000Atypedef void (*halide_print_t)(void *, const char *);\u000Aextern halide_print_t halide_set_custom_print(halide_print_t print);\u000A// @}\u000A\u000A/** Halide calls this function on runtime errors (for example bounds\u000A * checking failures). This function can be replaced in JITed code by\u000A * using Func::set_error_handler, or in AOT code by calling\u000A * halide_set_error_handler. In AOT code on platforms that support\u000A * weak linking (i.e. not Windows), you can also override it by simply\u000A * defining your own halide_error.\u000A */\u000A// @{\u000Aextern void halide_error(void *user_context, const char *);\u000Aextern void halide_default_error(void *user_context, const char *);\u000Atypedef void (*halide_error_handler_t)(void *, const char *);\u000Aextern halide_error_handler_t halide_set_error_handler(halide_error_handler_t handler);\u000A// @}\u000A\u000A/** Cross-platform mutex. Must be initialized with zero and implementation\u000A * must treat zero as an unlocked mutex with no waiters, etc.\u000A */\u000Astruct halide_mutex {\u000A    uintptr_t _private[1];\u000A};\u000A\u000A/** Cross platform condition variable. Must be initialized to 0. */\u000Astruct halide_cond {\u000A    uintptr_t _private[1];\u000A};\u000A\u000A/** A basic set of mutex and condition variable functions, which call\u000A * platform specific code for mutual exclusion. Equivalent to posix\u000A * calls. */\u000A//@{\u000Aextern void halide_mutex_lock(struct halide_mutex *mutex);\u000Aextern void halide_mutex_unlock(struct halide_mutex *mutex);\u000Aextern void halide_cond_signal(struct halide_cond *cond);\u000Aextern void halide_cond_broadcast(struct halide_cond *cond);\u000Aextern void halide_cond_wait(struct halide_cond *cond, struct halide_mutex *mutex);\u000A//@}\u000A\u000A/** Functions for constructing/destroying/locking/unlocking arrays of mutexes. */\u000Astruct halide_mutex_array;\u000A//@{\u000Aextern struct halide_mutex_array* halide_mutex_array_create(int sz);\u000Aextern void halide_mutex_array_destroy(void *user_context, void *array);\u000Aextern int halide_mutex_array_lock(struct halide_mutex_array *array, int entry);\u000Aextern int halide_mutex_array_unlock(struct halide_mutex_array *array, int entry);\u000A//@}\u000A\u000A/** Define halide_do_par_for to replace the default thread pool\u000A * implementation. halide_shutdown_thread_pool can also be called to\u000A * release resources used by the default thread pool on platforms\u000A * where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is\u000A * used so %Halide does not own the threads backing the pool and they\u000A * cannot be released.)  See Func::set_custom_do_task and\u000A * Func::set_custom_do_par_for. Should return zero if all the jobs\u000A * return zero, or an arbitrarily chosen return value from one of the\u000A * jobs otherwise.\u000A */\u000A//@{\u000Atypedef int (*halide_task_t)(void *user_context, int task_number, uint8_t *closure);\u000Aextern int halide_do_par_for(void *user_context,\u000A                             halide_task_t task,\u000A                             int min, int size, uint8_t *closure);\u000Aextern void halide_shutdown_thread_pool();\u000A//@}\u000A\u000A/** Set a custom method for performing a parallel for loop. Returns\u000A * the old do_par_for handler. */\u000Atypedef int (*halide_do_par_for_t)(void *, halide_task_t, int, int, uint8_t*);\u000Aextern halide_do_par_for_t halide_set_custom_do_par_for(halide_do_par_for_t do_par_for);\u000A\u000A/** An opaque struct representing a semaphore. Used by the task system for async tasks. */\u000Astruct halide_semaphore_t {\u000A    uint64_t _private[2];\u000A};\u000A\u000A/** A struct representing a semaphore and a number of items that must\u000A * be acquired from it. Used in halide_parallel_task_t below. */\u000Astruct halide_semaphore_acquire_t {\u000A    struct halide_semaphore_t *semaphore;\u000A    int count;\u000A};\u000Aextern int halide_semaphore_init(struct halide_semaphore_t *, int n);\u000Aextern int halide_semaphore_release(struct halide_semaphore_t *, int n);\u000Aextern bool halide_semaphore_try_acquire(struct halide_semaphore_t *, int n);\u000Atypedef int (*halide_semaphore_init_t)(struct halide_semaphore_t *, int);\u000Atypedef int (*halide_semaphore_release_t)(struct halide_semaphore_t *, int);\u000Atypedef bool (*halide_semaphore_try_acquire_t)(struct halide_semaphore_t *, int);\u000A\u000A\u000A/** A task representing a serial for loop evaluated over some range.\u000A * Note that task_parent is a pass through argument that should be\u000A * passed to any dependent taks that are invokved using halide_do_parallel_tasks\u000A * underneath this call. */\u000Atypedef int (*halide_loop_task_t)(void *user_context, int min, int extent,\u000A                                  uint8_t *closure, void *task_parent);\u000A\u000A/** A parallel task to be passed to halide_do_parallel_tasks. This\u000A * task may recursively call halide_do_parallel_tasks, and there may\u000A * be complex dependencies between seemingly unrelated tasks expressed\u000A * using semaphores. If you are using a custom task system, care must\u000A * be taken to avoid potential deadlock. This can be done by carefully\u000A * respecting the static metadata at the end of the task struct.*/\u000Astruct halide_parallel_task_t {\u000A    // The function to call. It takes a user context, a min and\u000A    // extent, a closure, and a task system pass through argument.\u000A    halide_loop_task_t fn;\u000A\u000A    // The closure to pass it\u000A    uint8_t *closure;\u000A\u000A    // The name of the function to be called. For debugging purposes only.\u000A    const char *name;\u000A\u000A    // An array of semaphores that must be acquired before the\u000A    // function is called. Must be reacquired for every call made.\u000A    struct halide_semaphore_acquire_t *semaphores;\u000A    int num_semaphores;\u000A\u000A    // The entire range the function should be called over. This range\u000A    // may be sliced up and the function called multiple times.\u000A    int min, extent;\u000A\u000A    // A parallel task provides several pieces of metadata to prevent\u000A    // unbounded resource usage or deadlock.\u000A\u000A    // The first is the minimum number of execution contexts (call\u000A    // stacks or threads) necessary for the function to run to\u000A    // completion. This may be greater than one when there is nested\u000A    // parallelism with internal producer-consumer relationships\u000A    // (calling the function recursively spawns and blocks on parallel\u000A    // sub-tasks that communicate with each other via semaphores). If\u000A    // a parallel runtime calls the function when fewer than this many\u000A    // threads are idle, it may need to create more threads to\u000A    // complete the task, or else risk deadlock due to committing all\u000A    // threads to tasks that cannot complete without more.\u000A    //\u000A    // FIXME: Note that extern stages are assumed to only require a\u000A    // single thread to complete. If the extern stage is itself a\u000A    // Halide pipeline, this may be an underestimate.\u000A    int min_threads;\u000A\u000A    // The calls to the function should be in serial order from min to min+extent-1, with only\u000A    // one executing at a time. If false, any order is fine, and\u000A    // concurrency is fine.\u000A    bool serial;\u000A};\u000A\u000A/** Enqueue some number of the tasks described above and wait for them\u000A * to complete. While waiting, the calling threads assists with either\u000A * the tasks enqueued, or other non-blocking tasks in the task\u000A * system. Note that task_parent should be NULL for top-level calls\u000A * and the pass through argument if this call is being made from\u000A * another task. */\u000Aextern int halide_do_parallel_tasks(void *user_context, int num_tasks,\u000A                                    struct halide_parallel_task_t *tasks,\u000A                                    void *task_parent);\u000A\u000A/** If you use the default do_par_for, you can still set a custom\u000A * handler to perform each individual task. Returns the old handler. */\u000A//@{\u000Atypedef int (*halide_do_task_t)(void *, halide_task_t, int, uint8_t *);\u000Aextern halide_do_task_t halide_set_custom_do_task(halide_do_task_t do_task);\u000Aextern int halide_do_task(void *user_context, halide_task_t f, int idx,\u000A                          uint8_t *closure);\u000A//@}\u000A\u000A/** The version of do_task called for loop tasks. By default calls the\u000A * loop task with the same arguments. */\u000A// @{\u000A  typedef int (*halide_do_loop_task_t)(void *, halide_loop_task_t, int, int, uint8_t *, void *);\u000Aextern halide_do_loop_task_t halide_set_custom_do_loop_task(halide_do_loop_task_t do_task);\u000Aextern int halide_do_loop_task(void *user_context, halide_loop_task_t f, int min, int extent,\u000A                               uint8_t *closure, void *task_parent);\u000A//@}\u000A\u000A/** Provide an entire custom tasking runtime via function\u000A * pointers. Note that do_task and semaphore_try_acquire are only ever\u000A * called by halide_default_do_par_for and\u000A * halide_default_do_parallel_tasks, so it's only necessary to provide\u000A * those if you are mixing in the default implementations of\u000A * do_par_for and do_parallel_tasks. */\u000A// @{\u000Atypedef int (*halide_do_parallel_tasks_t)(void *, int, struct halide_parallel_task_t *,\u000A                                          void *task_parent);\u000Aextern void halide_set_custom_parallel_runtime(\u000A    halide_do_par_for_t,\u000A    halide_do_task_t,\u000A    halide_do_loop_task_t,\u000A    halide_do_parallel_tasks_t,\u000A    halide_semaphore_init_t,\u000A    halide_semaphore_try_acquire_t,\u000A    halide_semaphore_release_t\u000A    );\u000A// @}\u000A\u000A/** The default versions of the parallel runtime functions. */\u000A// @{\u000Aextern int halide_default_do_par_for(void *user_context,\u000A                                     halide_task_t task,\u000A                                     int min, int size, uint8_t *closure);\u000Aextern int halide_default_do_parallel_tasks(void *user_context,\u000A                                            int num_tasks,\u000A                                            struct halide_parallel_task_t *tasks,\u000A                                            void *task_parent);\u000Aextern int halide_default_do_task(void *user_context, halide_task_t f, int idx,\u000A                                  uint8_t *closure);\u000Aextern int halide_default_do_loop_task(void *user_context, halide_loop_task_t f,\u000A                                       int min, int extent,\u000A                                       uint8_t *closure, void *task_parent);\u000Aextern int halide_default_semaphore_init(struct halide_semaphore_t *, int n);\u000Aextern int halide_default_semaphore_release(struct halide_semaphore_t *, int n);\u000Aextern bool halide_default_semaphore_try_acquire(struct halide_semaphore_t *, int n);\u000A// @}\u000A\u000Astruct halide_thread;\u000A\u000A/** Spawn a thread. Returns a handle to the thread for the purposes of\u000A * joining it. The thread must be joined in order to clean up any\u000A * resources associated with it. */\u000Aextern struct halide_thread *halide_spawn_thread(void (*f)(void *), void *closure);\u000A\u000A/** Join a thread. */\u000Aextern void halide_join_thread(struct halide_thread *);\u000A\u000A/** Set the number of threads used by Halide's thread pool. Returns\u000A * the old number.\u000A *\u000A * n < 0  : error condition\u000A * n == 0 : use a reasonable system default (typically, number of cpus online).\u000A * n == 1 : use exactly one thread; this will always enforce serial execution\u000A * n > 1  : use a pool of exactly n threads.\u000A *\u000A * (Note that this is only guaranteed when using the default implementations\u000A * of halide_do_par_for(); custom implementations may completely ignore values\u000A * passed to halide_set_num_threads().)\u000A */\u000Aextern int halide_set_num_threads(int n);\u000A\u000A/** Halide calls these functions to allocate and free memory. To\u000A * replace in AOT code, use the halide_set_custom_malloc and\u000A * halide_set_custom_free, or (on platforms that support weak\u000A * linking), simply define these functions yourself. In JIT-compiled\u000A * code use Func::set_custom_allocator.\u000A *\u000A * If you override them, and find yourself wanting to call the default\u000A * implementation from within your override, use\u000A * halide_default_malloc/free.\u000A *\u000A * Note that halide_malloc must return a pointer aligned to the\u000A * maximum meaningful alignment for the platform for the purpose of\u000A * vector loads and stores. The default implementation uses 32-byte\u000A * alignment, which is safe for arm and x86. Additionally, it must be\u000A * safe to read at least 8 bytes before the start and beyond the\u000A * end.\u000A */\u000A//@{\u000Aextern void *halide_malloc(void *user_context, size_t x);\u000Aextern void halide_free(void *user_context, void *ptr);\u000Aextern void *halide_default_malloc(void *user_context, size_t x);\u000Aextern void halide_default_free(void *user_context, void *ptr);\u000Atypedef void *(*halide_malloc_t)(void *, size_t);\u000Atypedef void (*halide_free_t)(void *, void *);\u000Aextern halide_malloc_t halide_set_custom_malloc(halide_malloc_t user_malloc);\u000Aextern halide_free_t halide_set_custom_free(halide_free_t user_free);\u000A//@}\u000A\u000A/** Halide calls these functions to interact with the underlying\u000A * system runtime functions. To replace in AOT code on platforms that\u000A * support weak linking, define these functions yourself, or use\u000A * the halide_set_custom_load_library() and halide_set_custom_get_library_symbol()\u000A * functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().\u000A *\u000A * halide_load_library and halide_get_library_symbol are equivalent to\u000A * dlopen and dlsym. halide_get_symbol(sym) is equivalent to\u000A * dlsym(RTLD_DEFAULT, sym).\u000A */\u000A//@{\u000Aextern void *halide_get_symbol(const char *name);\u000Aextern void *halide_load_library(const char *name);\u000Aextern void *halide_get_library_symbol(void *lib, const char *name);\u000Aextern void *halide_default_get_symbol(const char *name);\u000Aextern void *halide_default_load_library(const char *name);\u000Aextern void *halide_default_get_library_symbol(void *lib, const char *name);\u000Atypedef void *(*halide_get_symbol_t)(const char *name);\u000Atypedef void *(*halide_load_library_t)(const char *name);\u000Atypedef void *(*halide_get_library_symbol_t)(void *lib, const char *name);\u000Aextern halide_get_symbol_t halide_set_custom_get_symbol(halide_get_symbol_t user_get_symbol);\u000Aextern halide_load_library_t halide_set_custom_load_library(halide_load_library_t user_load_library);\u000Aextern halide_get_library_symbol_t halide_set_custom_get_library_symbol(halide_get_library_symbol_t user_get_library_symbol);\u000A//@}\u000A\u000A/** Called when debug_to_file is used inside %Halide code.  See\u000A * Func::debug_to_file for how this is called\u000A *\u000A * Cannot be replaced in JITted code at present.\u000A */\u000Aextern int32_t halide_debug_to_file(void *user_context, const char *filename,\u000A                                    int32_t type_code,\u000A                                    struct halide_buffer_t *buf);\u000A\u000A/** Types in the halide type system. They can be ints, unsigned ints,\u000A * or floats (of various bit-widths), or a handle (which is always 64-bits).\u000A * Note that the int/uint/float values do not imply a specific bit width\u000A * (the bit width is expected to be encoded in a separate value).\u000A */\u000Atypedef enum halide_type_code_t\u000A#if __cplusplus >= 201103L\u000A: uint8_t\u000A#endif\u000A{\u000A    halide_type_int = 0,   //!< signed integers\u000A    halide_type_uint = 1,  //!< unsigned integers\u000A    halide_type_float = 2, //!< IEEE floating point numbers\u000A    halide_type_handle = 3, //!< opaque pointer type (void *)\u000A    halide_type_bfloat = 4, //!< floating point numbers in the bfloat format\u000A    halide_type_complex = 5,\u000A} halide_type_code_t;\u000A\u000A// Note that while __attribute__ can go before or after the declaration,\u000A// __declspec apparently is only allowed before.\u000A#ifndef HALIDE_ATTRIBUTE_ALIGN\u000A    #ifdef _MSC_VER\u000A        #define HALIDE_ATTRIBUTE_ALIGN(x) __declspec(align(x))\u000A    #else\u000A        #define HALIDE_ATTRIBUTE_ALIGN(x) __attribute__((aligned(x)))\u000A    #endif\u000A#endif\u000A\u000A/** A runtime tag for a type in the halide type system. Can be ints,\u000A * unsigned ints, or floats of various bit-widths (the 'bits'\u000A * field). Can also be vectors of the same (by setting the 'lanes'\u000A * field to something larger than one). This struct should be\u000A * exactly 32-bits in size. */\u000Astruct halide_type_t {\u000A    /** The basic type code: signed integer, unsigned integer, or floating point. */\u000A#if __cplusplus >= 201103L\u000A    HALIDE_ATTRIBUTE_ALIGN(1) halide_type_code_t code; // halide_type_code_t\u000A#else\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t code; // halide_type_code_t\u000A#endif\u000A\u000A    /** The number of bits of precision of a single scalar value of this type. */\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t bits;\u000A\u000A    /** How many elements in a vector. This is 1 for scalar types. */\u000A    HALIDE_ATTRIBUTE_ALIGN(2) uint16_t lanes;\u000A\u000A#ifdef __cplusplus\u000A    /** Construct a runtime representation of a Halide type from:\u000A     * code: The fundamental type from an enum.\u000A     * bits: The bit size of one element.\u000A     * lanes: The number of vector elements in the type. */\u000A    HALIDE_ALWAYS_INLINE halide_type_t(halide_type_code_t code, uint8_t bits, uint16_t lanes = 1)\u000A        : code(code), bits(bits), lanes(lanes) {\u000A    }\u000A\u000A    /** Default constructor is required e.g. to declare halide_trace_event\u000A     * instances. */\u000A    HALIDE_ALWAYS_INLINE halide_type_t() : code((halide_type_code_t)0), bits(0), lanes(0) {}\u000A\u000A    HALIDE_ALWAYS_INLINE halide_type_t with_lanes(uint16_t new_lanes) const {\u000A        return halide_type_t((halide_type_code_t) code, bits, new_lanes);\u000A    }\u000A\u000A    /** Compare two types for equality. */\u000A    HALIDE_ALWAYS_INLINE bool operator==(const halide_type_t &other) const {\u000A        return as_u32() == other.as_u32();\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator!=(const halide_type_t &other) const {\u000A        return !(*this == other);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator<(const halide_type_t &other) const {\u000A        return as_u32() < other.as_u32();\u000A    }\u000A\u000A    /** Size in bytes for a single element, even if width is not 1, of this type. */\u000A    HALIDE_ALWAYS_INLINE int bytes() const { return (bits + 7) / 8; }\u000A\u000A    HALIDE_ALWAYS_INLINE uint32_t as_u32() const {\u000A        uint32_t u;\u000A        memcpy(&u, this, sizeof(u));\u000A        return u;\u000A    }\u000A#endif\u000A};\u000A\u000Aenum halide_trace_event_code_t {halide_trace_load = 0,\u000A                                halide_trace_store = 1,\u000A                                halide_trace_begin_realization = 2,\u000A                                halide_trace_end_realization = 3,\u000A                                halide_trace_produce = 4,\u000A                                halide_trace_end_produce = 5,\u000A                                halide_trace_consume = 6,\u000A                                halide_trace_end_consume = 7,\u000A                                halide_trace_begin_pipeline = 8,\u000A                                halide_trace_end_pipeline = 9,\u000A                                halide_trace_tag = 10 };\u000A\u000Astruct halide_trace_event_t {\u000A    /** The name of the Func or Pipeline that this event refers to */\u000A    const char *func;\u000A\u000A    /** If the event type is a load or a store, this points to the\u000A     * value being loaded or stored. Use the type field to safely cast\u000A     * this to a concrete pointer type and retrieve it. For other\u000A     * events this is null. */\u000A    void *value;\u000A\u000A    /** For loads and stores, an array which contains the location\u000A     * being accessed. For vector loads or stores it is an array of\u000A     * vectors of coordinates (the vector dimension is innermost).\u000A     *\u000A     * For realization or production-related events, this will contain\u000A     * the mins and extents of the region being accessed, in the order\u000A     * min0, extent0, min1, extent1, ...\u000A     *\u000A     * For pipeline-related events, this will be null.\u000A     */\u000A    int32_t *coordinates;\u000A\u000A    /** For halide_trace_tag, this points to a read-only null-terminated string\u000A     * of arbitrary text. For all other events, this will be null.\u000A     */\u000A    const char *trace_tag;\u000A\u000A    /** If the event type is a load or a store, this is the type of\u000A     * the data. Otherwise, the value is meaningless. */\u000A    struct halide_type_t type;\u000A\u000A    /** The type of event */\u000A    enum halide_trace_event_code_t event;\u000A\u000A    /* The ID of the parent event (see below for an explanation of\u000A     * event ancestry). */\u000A    int32_t parent_id;\u000A\u000A    /** If this was a load or store of a Tuple-valued Func, this is\u000A     * which tuple element was accessed. */\u000A    int32_t value_index;\u000A\u000A    /** The length of the coordinates array */\u000A    int32_t dimensions;\u000A\u000A#ifdef __cplusplus\u000A    // If we don't explicitly mark the default ctor as inline,\u000A    // certain build configurations can fail (notably iOS)\u000A    HALIDE_ALWAYS_INLINE halide_trace_event_t() {}\u000A#endif\u000A};\u000A\u000A/** Called when Funcs are marked as trace_load, trace_store, or\u000A * trace_realization. See Func::set_custom_trace. The default\u000A * implementation either prints events via halide_print, or if\u000A * HL_TRACE_FILE is defined, dumps the trace to that file in a\u000A * sequence of trace packets. The header for a trace packet is defined\u000A * below. If the trace is going to be large, you may want to make the\u000A * file a named pipe, and then read from that pipe into gzip.\u000A *\u000A * halide_trace returns a unique ID which will be passed to future\u000A * events that \"belong\" to the earlier event as the parent id. The\u000A * ownership hierarchy looks like:\u000A *\u000A * begin_pipeline\u000A * +--trace_tag (if any)\u000A * +--trace_tag (if any)\u000A * ...\u000A * +--begin_realization\u000A * |  +--produce\u000A * |  |  +--load/store\u000A * |  |  +--end_produce\u000A * |  +--consume\u000A * |  |  +--load\u000A * |  |  +--end_consume\u000A * |  +--end_realization\u000A * +--end_pipeline\u000A *\u000A * Threading means that ownership cannot be inferred from the ordering\u000A * of events. There can be many active realizations of a given\u000A * function, or many active productions for a single\u000A * realization. Within a single production, the ordering of events is\u000A * meaningful.\u000A *\u000A * Note that all trace_tag events (if any) will occur just after the begin_pipeline\u000A * event, but before any begin_realization events. All trace_tags for a given Func\u000A * will be emitted in the order added.\u000A */\u000A// @}\u000Aextern int32_t halide_trace(void *user_context, const struct halide_trace_event_t *event);\u000Aextern int32_t halide_default_trace(void *user_context, const struct halide_trace_event_t *event);\u000Atypedef int32_t (*halide_trace_t)(void *user_context, const struct halide_trace_event_t *);\u000Aextern halide_trace_t halide_set_custom_trace(halide_trace_t trace);\u000A// @}\u000A\u000A/** The header of a packet in a binary trace. All fields are 32-bit. */\u000Astruct halide_trace_packet_t {\u000A    /** The total size of this packet in bytes. Always a multiple of\u000A     * four. Equivalently, the number of bytes until the next\u000A     * packet. */\u000A    uint32_t size;\u000A\u000A    /** The id of this packet (for the purpose of parent_id). */\u000A    int32_t id;\u000A\u000A    /** The remaining fields are equivalent to those in halide_trace_event_t */\u000A    // @{\u000A    struct halide_type_t type;\u000A    enum halide_trace_event_code_t event;\u000A    int32_t parent_id;\u000A    int32_t value_index;\u000A    int32_t dimensions;\u000A    // @}\u000A\u000A    #ifdef __cplusplus\u000A    // If we don't explicitly mark the default ctor as inline,\u000A    // certain build configurations can fail (notably iOS)\u000A    HALIDE_ALWAYS_INLINE halide_trace_packet_t() {}\u000A\u000A    /** Get the coordinates array, assuming this packet is laid out in\u000A     * memory as it was written. The coordinates array comes\u000A     * immediately after the packet header. */\u000A    HALIDE_ALWAYS_INLINE const int *coordinates() const {\u000A        return (const int *)(this + 1);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE int *coordinates() {\u000A        return (int *)(this + 1);\u000A    }\u000A\u000A    /** Get the value, assuming this packet is laid out in memory as\u000A     * it was written. The packet comes immediately after the coordinates\u000A     * array. */\u000A    HALIDE_ALWAYS_INLINE const void *value() const {\u000A        return (const void *)(coordinates() + dimensions);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void *value() {\u000A        return (void *)(coordinates() + dimensions);\u000A    }\u000A\u000A    /** Get the func name, assuming this packet is laid out in memory\u000A     * as it was written. It comes after the value. */\u000A    HALIDE_ALWAYS_INLINE const char *func() const {\u000A        return (const char *)value() + type.lanes * type.bytes();\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE char *func() {\u000A        return (char *)value() + type.lanes * type.bytes();\u000A    }\u000A\u000A    /** Get the trace_tag (if any), assuming this packet is laid out in memory\u000A     * as it was written. It comes after the func name. If there is no trace_tag,\u000A     * this will return a pointer to an empty string. */\u000A    HALIDE_ALWAYS_INLINE const char *trace_tag() const {\u000A        const char *f = func();\u000A        // strlen may not be available here\u000A        while (*f++) {\u000A            // nothing\u000A        }\u000A        return f;\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE char *trace_tag() {\u000A        char *f = func();\u000A        // strlen may not be available here\u000A        while (*f++) {\u000A            // nothing\u000A        }\u000A        return f;\u000A    }\u000A    #endif\u000A};\u000A\u000A\u000A\u000A/** Set the file descriptor that Halide should write binary trace\u000A * events to. If called with 0 as the argument, Halide outputs trace\u000A * information to stdout in a human-readable format. If never called,\u000A * Halide checks the for existence of an environment variable called\u000A * HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined,\u000A * it outputs trace information to stdout in a human-readable\u000A * format. */\u000Aextern void halide_set_trace_file(int fd);\u000A\u000A/** Halide calls this to retrieve the file descriptor to write binary\u000A * trace events to. The default implementation returns the value set\u000A * by halide_set_trace_file. Implement it yourself if you wish to use\u000A * a custom file descriptor per user_context. Return zero from your\u000A * implementation to tell Halide to print human-readable trace\u000A * information to stdout. */\u000Aextern int halide_get_trace_file(void *user_context);\u000A\u000A/** If tracing is writing to a file. This call closes that file\u000A * (flushing the trace). Returns zero on success. */\u000Aextern int halide_shutdown_trace();\u000A\u000A/** All Halide GPU or device backend implementations provide an\u000A * interface to be used with halide_device_malloc, etc. This is\u000A * accessed via the functions below.\u000A */\u000A\u000A/** An opaque struct containing per-GPU API implementations of the\u000A * device functions. */\u000Astruct halide_device_interface_impl_t;\u000A\u000A/** Each GPU API provides a halide_device_interface_t struct pointing\u000A * to the code that manages device allocations. You can access these\u000A * functions directly from the struct member function pointers, or by\u000A * calling the functions declared below. Note that the global\u000A * functions are not available when using Halide as a JIT compiler.\u000A * If you are using raw halide_buffer_t in that context you must use\u000A * the function pointers in the device_interface struct.\u000A *\u000A * The function pointers below are currently the same for every GPU\u000A * API; only the impl field varies. These top-level functions do the\u000A * bookkeeping that is common across all GPU APIs, and then dispatch\u000A * to more API-specific functions via another set of function pointers\u000A * hidden inside the impl field.\u000A */\u000Astruct halide_device_interface_t {\u000A    int (*device_malloc)(void *user_context, struct halide_buffer_t *buf,\u000A                         const struct halide_device_interface_t *device_interface);\u000A    int (*device_free)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*device_sync)(void *user_context, struct halide_buffer_t *buf);\u000A    void (*device_release)(void *user_context,\u000A                          const struct halide_device_interface_t *device_interface);\u000A    int (*copy_to_host)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*copy_to_device)(void *user_context, struct halide_buffer_t *buf,\u000A                          const struct halide_device_interface_t *device_interface);\u000A    int (*device_and_host_malloc)(void *user_context, struct halide_buffer_t *buf,\u000A                                  const struct halide_device_interface_t *device_interface);\u000A    int (*device_and_host_free)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*buffer_copy)(void *user_context, struct halide_buffer_t *src,\u000A                       const struct halide_device_interface_t *dst_device_interface, struct halide_buffer_t *dst);\u000A    int (*device_crop)(void *user_context, const struct halide_buffer_t *src,\u000A                       struct halide_buffer_t *dst);\u000A    int (*device_slice)(void *user_context, const struct halide_buffer_t *src,\u000A                        int slice_dim, int slice_pos, struct halide_buffer_t *dst);\u000A    int (*device_release_crop)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*wrap_native)(void *user_context, struct halide_buffer_t *buf, uint64_t handle,\u000A                       const struct halide_device_interface_t *device_interface);\u000A    int (*detach_native)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*compute_capability)(void *user_context, int *major, int *minor);\u000A    const struct halide_device_interface_impl_t *impl;\u000A};\u000A\u000A/** Release all data associated with the given device interface, in\u000A * particular all resources (memory, texture, context handles)\u000A * allocated by Halide. Must be called explicitly when using AOT\u000A * compilation. This is *not* thread-safe with respect to actively\u000A * running Halide code. Ensure all pipelines are finished before\u000A * calling this. */\u000Aextern void halide_device_release(void *user_context,\u000A                                  const struct halide_device_interface_t *device_interface);\u000A\u000A/** Copy image data from device memory to host memory. This must be called\u000A * explicitly to copy back the results of a GPU-based filter. */\u000Aextern int halide_copy_to_host(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Copy image data from host memory to device memory. This should not\u000A * be called directly; Halide handles copying to the device\u000A * automatically.  If interface is NULL and the buf has a non-zero dev\u000A * field, the device associated with the dev handle will be\u000A * used. Otherwise if the dev field is 0 and interface is NULL, an\u000A * error is returned. */\u000Aextern int halide_copy_to_device(void *user_context, struct halide_buffer_t *buf,\u000A                                 const struct halide_device_interface_t *device_interface);\u000A\u000A/** Copy data from one buffer to another. The buffers may have\u000A * different shapes and sizes, but the destination buffer's shape must\u000A * be contained within the source buffer's shape. That is, for each\u000A * dimension, the min on the destination buffer must be greater than\u000A * or equal to the min on the source buffer, and min+extent on the\u000A * destination buffer must be less that or equal to min+extent on the\u000A * source buffer. The source data is pulled from either device or\u000A * host memory on the source, depending on the dirty flags. host is\u000A * preferred if both are valid. The dst_device_interface parameter\u000A * controls the destination memory space. NULL means host memory. */\u000Aextern int halide_buffer_copy(void *user_context, struct halide_buffer_t *src,\u000A                              const struct halide_device_interface_t *dst_device_interface,\u000A                              struct halide_buffer_t *dst);\u000A\u000A/** Give the destination buffer a device allocation which is an alias\u000A * for the same coordinate range in the source buffer. Modifies the\u000A * device, device_interface, and the device_dirty flag only. Only\u000A * supported by some device APIs (others will return\u000A * halide_error_code_device_crop_unsupported). Call\u000A * halide_device_release_crop instead of halide_device_free to clean\u000A * up resources associated with the cropped view. Do not free the\u000A * device allocation on the source buffer while the destination buffer\u000A * still lives. Note that the two buffers do not share dirty flags, so\u000A * care must be taken to update them together as needed. Note that src\u000A * and dst are required to have the same number of dimensions.\u000A *\u000A * Note also that (in theory) device interfaces which support cropping may\u000A * still not support cropping a crop (instead, create a new crop of the parent\u000A * buffer); in practice, no known implementation has this limitation, although\u000A * it is possible that some future implementations may require it. */\u000Aextern int halide_device_crop(void *user_context,\u000A                              const struct halide_buffer_t *src,\u000A                              struct halide_buffer_t *dst);\u000A\u000A/** Give the destination buffer a device allocation which is an alias\u000A * for a similar coordinate range in the source buffer, but with one dimension\u000A * sliced away in the dst. Modifies the device, device_interface, and the\u000A * device_dirty flag only. Only supported by some device APIs (others will return\u000A * halide_error_code_device_crop_unsupported). Call\u000A * halide_device_release_crop instead of halide_device_free to clean\u000A * up resources associated with the sliced view. Do not free the\u000A * device allocation on the source buffer while the destination buffer\u000A * still lives. Note that the two buffers do not share dirty flags, so\u000A * care must be taken to update them together as needed. Note that the dst buffer\u000A * must have exactly one fewer dimension than the src buffer, and that slice_dim\u000A * and slice_pos must be valid within src. */\u000Aextern int halide_device_slice(void *user_context,\u000A                               const struct halide_buffer_t *src,\u000A                               int slice_dim, int slice_pos,\u000A                               struct halide_buffer_t *dst);\u000A\u000A/** Release any resources associated with a cropped/sliced view of another\u000A * buffer. */\u000Aextern int halide_device_release_crop(void *user_context,\u000A                                      struct halide_buffer_t *buf);\u000A\u000A/** Wait for current GPU operations to complete. Calling this explicitly\u000A * should rarely be necessary, except maybe for profiling. */\u000Aextern int halide_device_sync(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Allocate device memory to back a halide_buffer_t. */\u000Aextern int halide_device_malloc(void *user_context, struct halide_buffer_t *buf,\u000A                                const struct halide_device_interface_t *device_interface);\u000A\u000A/** Free device memory. */\u000Aextern int halide_device_free(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Wrap or detach a native device handle, setting the device field\u000A * and device_interface field as appropriate for the given GPU\u000A * API. The meaning of the opaque handle is specific to the device\u000A * interface, so if you know the device interface in use, call the\u000A * more specific functions in the runtime headers for your specific\u000A * device API instead (e.g. HalideRuntimeCuda.h). */\u000A// @{\u000Aextern int halide_device_wrap_native(void *user_context,\u000A                                     struct halide_buffer_t *buf,\u000A                                     uint64_t handle,\u000A                                     const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_detach_native(void *user_context, struct halide_buffer_t *buf);\u000A// @}\u000A\u000A/** Versions of the above functions that accept legacy buffer_t structs. */\u000A// @{\u000Aextern int halide_copy_to_host_legacy(void *user_context, struct buffer_t *buf);\u000Aextern int halide_copy_to_device_legacy(void *user_context, struct buffer_t *buf,\u000A                                 const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_sync_legacy(void *user_context, struct buffer_t *buf);\u000Aextern int halide_device_malloc_legacy(void *user_context, struct buffer_t *buf,\u000A                                const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_free_legacy(void *user_context, struct buffer_t *buf);\u000A// @}\u000A\u000A/** Selects which gpu device to use. 0 is usually the display\u000A * device. If never called, Halide uses the environment variable\u000A * HL_GPU_DEVICE. If that variable is unset, Halide uses the last\u000A * device. Set this to -1 to use the last device. */\u000Aextern void halide_set_gpu_device(int n);\u000A\u000A/** Halide calls this to get the desired halide gpu device\u000A * setting. Implement this yourself to use a different gpu device per\u000A * user_context. The default implementation returns the value set by\u000A * halide_set_gpu_device, or the environment variable\u000A * HL_GPU_DEVICE. */\u000Aextern int halide_get_gpu_device(void *user_context);\u000A\u000A/** Set the soft maximum amount of memory, in bytes, that the LRU\u000A *  cache will use to memoize Func results.  This is not a strict\u000A *  maximum in that concurrency and simultaneous use of memoized\u000A *  reults larger than the cache size can both cause it to\u000A *  temporariliy be larger than the size specified here.\u000A */\u000Aextern void halide_memoization_cache_set_size(int64_t size);\u000A\u000A/** Given a cache key for a memoized result, currently constructed\u000A *  from the Func name and top-level Func name plus the arguments of\u000A *  the computation, determine if the result is in the cache and\u000A *  return it if so. (The internals of the cache key should be\u000A *  considered opaque by this function.) If this routine returns true,\u000A *  it is a cache miss. Otherwise, it will return false and the\u000A *  buffers passed in will be filled, via copying, with memoized\u000A *  data. The last argument is a list if halide_buffer_t pointers which\u000A *  represents the outputs of the memoized Func. If the Func does not\u000A *  return a Tuple, there will only be one halide_buffer_t in the list. The\u000A *  tuple_count parameters determines the length of the list.\u000A *\u000A * The return values are:\u000A * -1: Signals an error.\u000A *  0: Success and cache hit.\u000A *  1: Success and cache miss.\u000A */\u000Aextern int halide_memoization_cache_lookup(void *user_context, const uint8_t *cache_key, int32_t size,\u000A                                           struct halide_buffer_t *realized_bounds,\u000A                                           int32_t tuple_count, struct halide_buffer_t **tuple_buffers);\u000A\u000A/** Given a cache key for a memoized result, currently constructed\u000A *  from the Func name and top-level Func name plus the arguments of\u000A *  the computation, store the result in the cache for futre access by\u000A *  halide_memoization_cache_lookup. (The internals of the cache key\u000A *  should be considered opaque by this function.) Data is copied out\u000A *  from the inputs and inputs are unmodified. The last argument is a\u000A *  list if halide_buffer_t pointers which represents the outputs of the\u000A *  memoized Func. If the Func does not return a Tuple, there will\u000A *  only be one halide_buffer_t in the list. The tuple_count parameters\u000A *  determines the length of the list.\u000A *\u000A * If there is a memory allocation failure, the store does not store\u000A * the data into the cache.\u000A */\u000Aextern int halide_memoization_cache_store(void *user_context, const uint8_t *cache_key, int32_t size,\u000A                                          struct halide_buffer_t *realized_bounds,\u000A                                          int32_t tuple_count,\u000A                                          struct halide_buffer_t **tuple_buffers);\u000A\u000A/** If halide_memoization_cache_lookup succeeds,\u000A * halide_memoization_cache_release must be called to signal the\u000A * storage is no longer being used by the caller. It will be passed\u000A * the host pointer of one the buffers returned by\u000A * halide_memoization_cache_lookup. That is\u000A * halide_memoization_cache_release will be called multiple times for\u000A * the case where halide_memoization_cache_lookup is handling multiple\u000A * buffers.  (This corresponds to memoizing a Tuple in Halide.) Note\u000A * that the host pointer must be sufficient to get to all information\u000A * the relase operation needs. The default Halide cache impleemntation\u000A * accomplishes this by storing extra data before the start of the user\u000A * modifiable host storage.\u000A *\u000A * This call is like free and does not have a failure return.\u000A  */\u000Aextern void halide_memoization_cache_release(void *user_context, void *host);\u000A\u000A/** Free all memory and resources associated with the memoization cache.\u000A * Must be called at a time when no other threads are accessing the cache.\u000A */\u000Aextern void halide_memoization_cache_cleanup();\u000A\u000A/** Annotate that a given range of memory has been initialized;\u000A * only used when Target::MSAN is enabled.\u000A *\u000A * The default implementation uses the LLVM-provided AnnotateMemoryIsInitialized() function.\u000A */\u000Aextern int halide_msan_annotate_memory_is_initialized(void *user_context, const void *ptr, uint64_t len);\u000A\u000A/** Mark the data pointed to by the buffer_t as initialized (but *not* the buffer_t itself),\u000A * using halide_msan_annotate_memory_is_initialized() for marking.\u000A *\u000A * The default implementation takes pains to only mark the active memory ranges\u000A * (skipping padding), and sorting into ranges to always mark the smallest number of\u000A * ranges, in monotonically increasing memory order.\u000A *\u000A * Most client code should never need to replace the default implementation.\u000A */\u000Aextern int halide_msan_annotate_buffer_is_initialized(void *user_context, struct halide_buffer_t *buffer);\u000Aextern void halide_msan_annotate_buffer_is_initialized_as_destructor(void *user_context, void *buffer);\u000A\u000A/** The error codes that may be returned by a Halide pipeline. */\u000Aenum halide_error_code_t {\u000A    /** There was no error. This is the value returned by Halide on success. */\u000A    halide_error_code_success = 0,\u000A\u000A    /** An uncategorized error occurred. Refer to the string passed to halide_error. */\u000A    halide_error_code_generic_error = -1,\u000A\u000A    /** A Func was given an explicit bound via Func::bound, but this\u000A     * was not large enough to encompass the region that is used of\u000A     * the Func by the rest of the pipeline. */\u000A    halide_error_code_explicit_bounds_too_small = -2,\u000A\u000A    /** The elem_size field of a halide_buffer_t does not match the size in\u000A     * bytes of the type of that ImageParam. Probable type mismatch. */\u000A    halide_error_code_bad_type = -3,\u000A\u000A    /** A pipeline would access memory outside of the halide_buffer_t passed\u000A     * in. */\u000A    halide_error_code_access_out_of_bounds = -4,\u000A\u000A    /** A halide_buffer_t was given that spans more than 2GB of memory. */\u000A    halide_error_code_buffer_allocation_too_large = -5,\u000A\u000A    /** A halide_buffer_t was given with extents that multiply to a number\u000A     * greater than 2^31-1 */\u000A    halide_error_code_buffer_extents_too_large = -6,\u000A\u000A    /** Applying explicit constraints on the size of an input or\u000A     * output buffer shrank the size of that buffer below what will be\u000A     * accessed by the pipeline. */\u000A    halide_error_code_constraints_make_required_region_smaller = -7,\u000A\u000A    /** A constraint on a size or stride of an input or output buffer\u000A     * was not met by the halide_buffer_t passed in. */\u000A    halide_error_code_constraint_violated = -8,\u000A\u000A    /** A scalar parameter passed in was smaller than its minimum\u000A     * declared value. */\u000A    halide_error_code_param_too_small = -9,\u000A\u000A    /** A scalar parameter passed in was greater than its minimum\u000A     * declared value. */\u000A    halide_error_code_param_too_large = -10,\u000A\u000A    /** A call to halide_malloc returned NULL. */\u000A    halide_error_code_out_of_memory = -11,\u000A\u000A    /** A halide_buffer_t pointer passed in was NULL. */\u000A    halide_error_code_buffer_argument_is_null = -12,\u000A\u000A    /** debug_to_file failed to open or write to the specified\u000A     * file. */\u000A    halide_error_code_debug_to_file_failed = -13,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from device to host. Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_copy_to_host_failed = -14,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from host to device. Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_copy_to_device_failed = -15,\u000A\u000A    /** The Halide runtime encountered an error while trying to\u000A     * allocate memory on device. Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_malloc_failed = -16,\u000A\u000A    /** The Halide runtime encountered an error while trying to\u000A     * synchronize with a device. Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_sync_failed = -17,\u000A\u000A    /** The Halide runtime encountered an error while trying to free a\u000A     * device allocation. Turn on -debug in your target string to see\u000A     * more details. */\u000A    halide_error_code_device_free_failed = -18,\u000A\u000A    /** Buffer has a non-zero device but no device interface, which\u000A     * violates a Halide invariant. */\u000A    halide_error_code_no_device_interface = -19,\u000A\u000A    /** An error occurred when attempting to initialize the Matlab\u000A     * runtime. */\u000A    halide_error_code_matlab_init_failed = -20,\u000A\u000A    /** The type of an mxArray did not match the expected type. */\u000A    halide_error_code_matlab_bad_param_type = -21,\u000A\u000A    /** There is a bug in the Halide compiler. */\u000A    halide_error_code_internal_error = -22,\u000A\u000A    /** The Halide runtime encountered an error while trying to launch\u000A     * a GPU kernel. Turn on -debug in your target string to see more\u000A     * details. */\u000A    halide_error_code_device_run_failed = -23,\u000A\u000A    /** The Halide runtime encountered a host pointer that violated\u000A     * the alignment set for it by way of a call to\u000A     * set_host_alignment */\u000A    halide_error_code_unaligned_host_ptr = -24,\u000A\u000A    /** A fold_storage directive was used on a dimension that is not\u000A     * accessed in a monotonically increasing or decreasing fashion. */\u000A    halide_error_code_bad_fold = -25,\u000A\u000A    /** A fold_storage directive was used with a fold factor that was\u000A     * too small to store all the values of a producer needed by the\u000A     * consumer. */\u000A    halide_error_code_fold_factor_too_small = -26,\u000A\u000A    /** User-specified require() expression was not satisfied. */\u000A    halide_error_code_requirement_failed = -27,\u000A\u000A    /** At least one of the buffer's extents are negative. */\u000A    halide_error_code_buffer_extents_negative = -28,\u000A\u000A    /** A compiled pipeline was passed the old deprecated buffer_t\u000A     * struct, and it could not be upgraded to a halide_buffer_t. */\u000A    halide_error_code_failed_to_upgrade_buffer_t = -29,\u000A\u000A    /** A compiled pipeline was passed the old deprecated buffer_t\u000A     * struct in bounds inference mode, but the returned information\u000A     * can't be expressed in the old buffer_t. */\u000A    halide_error_code_failed_to_downgrade_buffer_t = -30,\u000A\u000A    /** A specialize_fail() schedule branch was selected at runtime. */\u000A    halide_error_code_specialize_fail = -31,\u000A\u000A    /** The Halide runtime encountered an error while trying to wrap a\u000A     * native device handle.  Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_device_wrap_native_failed = -32,\u000A\u000A    /** The Halide runtime encountered an error while trying to detach\u000A     * a native device handle.  Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_detach_native_failed = -33,\u000A\u000A    /** The host field on an input or output was null, the device\u000A     * field was not zero, and the pipeline tries to use the buffer on\u000A     * the host. You may be passing a GPU-only buffer to a pipeline\u000A     * which is scheduled to use it on the CPU. */\u000A    halide_error_code_host_is_null = -34,\u000A\u000A    /** A folded buffer was passed to an extern stage, but the region\u000A     * touched wraps around the fold boundary. */\u000A    halide_error_code_bad_extern_fold = -35,\u000A\u000A    /** Buffer has a non-null device_interface but device is 0, which\u000A     * violates a Halide invariant. */\u000A    halide_error_code_device_interface_no_device= -36,\u000A\u000A    /** Buffer has both host and device dirty bits set, which violates\u000A     * a Halide invariant. */\u000A    halide_error_code_host_and_device_dirty = -37,\u000A\u000A    /** The halide_buffer_t * passed to a halide runtime routine is\u000A     * nullptr and this is not allowed. */\u000A    halide_error_code_buffer_is_null = -38,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from one buffer to another. Turn on -debug in your target\u000A     * string to see more details. */\u000A    halide_error_code_device_buffer_copy_failed = -39,\u000A\u000A    /** Attempted to make cropped/sliced alias of a buffer with a device\u000A     * field, but the device_interface does not support cropping. */\u000A    halide_error_code_device_crop_unsupported = -40,\u000A\u000A    /** Cropping/slicing a buffer failed for some other reason. Turn on -debug\u000A     * in your target string. */\u000A    halide_error_code_device_crop_failed = -41,\u000A\u000A    /** An operation on a buffer required an allocation on a\u000A     * particular device interface, but a device allocation already\u000A     * existed on a different device interface. Free the old one\u000A     * first. */\u000A    halide_error_code_incompatible_device_interface = -42,\u000A\u000A    /** The dimensions field of a halide_buffer_t does not match the dimensions of that ImageParam. */\u000A    halide_error_code_bad_dimensions = -43,\u000A\u000A    /** An expression that would perform an integer division or modulo\u000A     * by zero was evaluated. */\u000A    halide_error_code_integer_division_by_zero = -44,\u000A\u000A};\u000A\u000A/** Halide calls the functions below on various error conditions. The\u000A * default implementations construct an error message, call\u000A * halide_error, then return the matching error code above. On\u000A * platforms that support weak linking, you can override these to\u000A * catch the errors individually. */\u000A\u000A/** A call into an extern stage for the purposes of bounds inference\u000A * failed. Returns the error code given by the extern stage. */\u000Aextern int halide_error_bounds_inference_call_failed(void *user_context, const char *extern_stage_name, int result);\u000A\u000A/** A call to an extern stage failed. Returned the error code given by\u000A * the extern stage. */\u000Aextern int halide_error_extern_stage_failed(void *user_context, const char *extern_stage_name, int result);\u000A\u000A/** Various other error conditions. See the enum above for a\u000A * description of each. */\u000A// @{\u000Aextern int halide_error_explicit_bounds_too_small(void *user_context, const char *func_name, const char *var_name,\u000A                                                      int min_bound, int max_bound, int min_required, int max_required);\u000Aextern int halide_error_bad_type(void *user_context, const char *func_name,\u000A                                 uint32_t type_given, uint32_t correct_type); // N.B. The last two args are the bit representation of a halide_type_t\u000Aextern int halide_error_bad_dimensions(void *user_context, const char *func_name,\u000A                                       int32_t dimensions_given, int32_t correct_dimensions);\u000Aextern int halide_error_access_out_of_bounds(void *user_context, const char *func_name,\u000A                                             int dimension, int min_touched, int max_touched,\u000A                                             int min_valid, int max_valid);\u000Aextern int halide_error_buffer_allocation_too_large(void *user_context, const char *buffer_name,\u000A                                                    uint64_t allocation_size, uint64_t max_size);\u000Aextern int halide_error_buffer_extents_negative(void *user_context, const char *buffer_name, int dimension, int extent);\u000Aextern int halide_error_buffer_extents_too_large(void *user_context, const char *buffer_name,\u000A                                                 int64_t actual_size, int64_t max_size);\u000Aextern int halide_error_constraints_make_required_region_smaller(void *user_context, const char *buffer_name,\u000A                                                                 int dimension,\u000A                                                                 int constrained_min, int constrained_extent,\u000A                                                                 int required_min, int required_extent);\u000Aextern int halide_error_constraint_violated(void *user_context, const char *var, int val,\u000A                                            const char *constrained_var, int constrained_val);\u000Aextern int halide_error_param_too_small_i64(void *user_context, const char *param_name,\u000A                                            int64_t val, int64_t min_val);\u000Aextern int halide_error_param_too_small_u64(void *user_context, const char *param_name,\u000A                                            uint64_t val, uint64_t min_val);\u000Aextern int halide_error_param_too_small_f64(void *user_context, const char *param_name,\u000A                                            double val, double min_val);\u000Aextern int halide_error_param_too_large_i64(void *user_context, const char *param_name,\u000A                                            int64_t val, int64_t max_val);\u000Aextern int halide_error_param_too_large_u64(void *user_context, const char *param_name,\u000A                                            uint64_t val, uint64_t max_val);\u000Aextern int halide_error_param_too_large_f64(void *user_context, const char *param_name,\u000A                                            double val, double max_val);\u000Aextern int halide_error_out_of_memory(void *user_context);\u000Aextern int halide_error_buffer_argument_is_null(void *user_context, const char *buffer_name);\u000Aextern int halide_error_debug_to_file_failed(void *user_context, const char *func,\u000A                                             const char *filename, int error_code);\u000Aextern int halide_error_unaligned_host_ptr(void *user_context, const char *func_name, int alignment);\u000Aextern int halide_error_host_is_null(void *user_context, const char *func_name);\u000Aextern int halide_error_failed_to_upgrade_buffer_t(void *user_context,\u000A                                                   const char *input_name,\u000A                                                   const char *reason);\u000Aextern int halide_error_failed_to_downgrade_buffer_t(void *user_context,\u000A                                                     const char *input_name,\u000A                                                     const char *reason);\u000Aextern int halide_error_bad_fold(void *user_context, const char *func_name, const char *var_name,\u000A                                 const char *loop_name);\u000Aextern int halide_error_bad_extern_fold(void *user_context, const char *func_name,\u000A                                        int dim, int min, int extent, int valid_min, int fold_factor);\u000A\u000Aextern int halide_error_fold_factor_too_small(void *user_context, const char *func_name, const char *var_name,\u000A                                              int fold_factor, const char *loop_name, int required_extent);\u000Aextern int halide_error_requirement_failed(void *user_context, const char *condition, const char *message);\u000Aextern int halide_error_specialize_fail(void *user_context, const char *message);\u000Aextern int halide_error_no_device_interface(void *user_context);\u000Aextern int halide_error_device_interface_no_device(void *user_context);\u000Aextern int halide_error_host_and_device_dirty(void *user_context);\u000Aextern int halide_error_buffer_is_null(void *user_context, const char *routine);\u000Aextern int halide_error_integer_division_by_zero(void *user_context);\u000A// @}\u000A\u000A/** Optional features a compilation Target can have.\u000A * Be sure to keep this in sync with the Feature enum in Target.h and the implementation of\u000A * get_runtime_compatible_target in Target.cpp if you add a new feature.\u000A */\u000Atypedef enum halide_target_feature_t {\u000A    halide_target_feature_jit = 0,  ///< Generate code that will run immediately inside the calling process.\u000A    halide_target_feature_debug,  ///< Turn on debug info and output for runtime code.\u000A    halide_target_feature_no_asserts,  ///< Disable all runtime checks, for slightly tighter code.\u000A    halide_target_feature_no_bounds_query, ///< Disable the bounds querying functionality.\u000A\u000A    halide_target_feature_sse41,  ///< Use SSE 4.1 and earlier instructions. Only relevant on x86.\u000A    halide_target_feature_avx,  ///< Use AVX 1 instructions. Only relevant on x86.\u000A    halide_target_feature_avx2,  ///< Use AVX 2 instructions. Only relevant on x86.\u000A    halide_target_feature_fma,  ///< Enable x86 FMA instruction\u000A    halide_target_feature_fma4,  ///< Enable x86 (AMD) FMA4 instruction set\u000A    halide_target_feature_f16c,  ///< Enable x86 16-bit float support\u000A\u000A    halide_target_feature_armv7s,  ///< Generate code for ARMv7s. Only relevant for 32-bit ARM.\u000A    halide_target_feature_no_neon,  ///< Avoid using NEON instructions. Only relevant for 32-bit ARM.\u000A\u000A    halide_target_feature_vsx,  ///< Use VSX instructions. Only relevant on POWERPC.\u000A    halide_target_feature_power_arch_2_07,  ///< Use POWER ISA 2.07 new instructions. Only relevant on POWERPC.\u000A\u000A    halide_target_feature_cuda,  ///< Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi)\u000A    halide_target_feature_cuda_capability30,  ///< Enable CUDA compute capability 3.0 (Kepler)\u000A    halide_target_feature_cuda_capability32,  ///< Enable CUDA compute capability 3.2 (Tegra K1)\u000A    halide_target_feature_cuda_capability35,  ///< Enable CUDA compute capability 3.5 (Kepler)\u000A    halide_target_feature_cuda_capability50,  ///< Enable CUDA compute capability 5.0 (Maxwell)\u000A\u000A    halide_target_feature_opencl,  ///< Enable the OpenCL runtime.\u000A    halide_target_size_opencl, ///<Temporary testing target placeholder marked by size>\u000A    halide_target_feature_cl_doubles,  ///< Enable double support on OpenCL targets\u000A    halide_target_feature_cl_atomic64, ///< Enable 64-bit atomics operations on OpenCL targets\u000A\u000A    halide_target_feature_opengl,  ///< Enable the OpenGL runtime.\u000A    halide_target_feature_openglcompute, ///< Enable OpenGL Compute runtime.\u000A\u000A    halide_target_feature_user_context,  ///< Generated code takes a user_context pointer as first argument\u000A\u000A    halide_target_feature_matlab,  ///< Generate a mexFunction compatible with Matlab mex libraries. See tools/mex_halide.m.\u000A\u000A    halide_target_feature_profile, ///< Launch a sampling profiler alongside the Halide pipeline that monitors and reports the runtime used by each Func\u000A    halide_target_feature_no_runtime, ///< Do not include a copy of the Halide runtime in any generated object file or assembly\u000A\u000A    halide_target_feature_metal, ///< Enable the (Apple) Metal runtime.\u000A    halide_target_feature_mingw, ///< For Windows compile to MinGW toolset rather then Visual Studio\u000A\u000A    halide_target_feature_c_plus_plus_mangling, ///< Generate C++ mangled names for result function, et al\u000A\u000A    halide_target_feature_large_buffers, ///< Enable 64-bit buffer indexing to support buffers > 2GB. Ignored if bits != 64.\u000A\u000A    halide_target_feature_hvx_64, ///< Enable HVX 64 byte mode.\u000A    halide_target_feature_hvx_128, ///< Enable HVX 128 byte mode.\u000A    halide_target_feature_hvx_v62, ///< Enable Hexagon v62 architecture.\u000A    halide_target_feature_fuzz_float_stores, ///< On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors.\u000A    halide_target_feature_soft_float_abi, ///< Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats.\u000A    halide_target_feature_msan, ///< Enable hooks for MSAN support.\u000A    halide_target_feature_avx512, ///< Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See https://en.wikipedia.org/wiki/AVX-512 for a description of each AVX subset.\u000A    halide_target_feature_avx512_knl, ///< Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER.\u000A    halide_target_feature_avx512_skylake, ///< Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors.\u000A    halide_target_feature_avx512_cannonlake, ///< Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI.\u000A    halide_target_feature_hvx_use_shared_object, ///< Deprecated\u000A    halide_target_feature_trace_loads, ///< Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func.\u000A    halide_target_feature_trace_stores, ///< Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func.\u000A    halide_target_feature_trace_realizations, ///< Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func.\u000A    halide_target_feature_trace_pipeline, ///< Trace the pipeline.\u000A    halide_target_feature_cuda_capability61,  ///< Enable CUDA compute capability 6.1 (Pascal)\u000A    halide_target_feature_hvx_v65, ///< Enable Hexagon v65 architecture.\u000A    halide_target_feature_hvx_v66, ///< Enable Hexagon v66 architecture.\u000A    halide_target_feature_cl_half,  ///< Enable half support on OpenCL targets\u000A    halide_target_feature_strict_float, ///< Turn off all non-IEEE floating-point optimization. Currently applies only to LLVM targets.\u000A    halide_target_feature_legacy_buffer_wrappers,  ///< Emit legacy wrapper code for buffer_t (vs halide_buffer_t) when AOT-compiled.\u000A    halide_target_feature_tsan, ///< Enable hooks for TSAN support.\u000A    halide_target_feature_asan, ///< Enable hooks for ASAN support.\u000A    halide_target_feature_d3d12compute, ///< Enable Direct3D 12 Compute runtime.\u000A    halide_target_feature_check_unsafe_promises, ///< Insert assertions for promises.\u000A    halide_target_feature_hexagon_dma, ///< Enable Hexagon DMA buffers.\u000A    halide_target_feature_embed_bitcode,  ///< Emulate clang -fembed-bitcode flag.\u000A    halide_target_feature_enable_llvm_loop_opt,  ///< Enable loop vectorization + unrolling in LLVM. Overrides halide_target_feature_disable_llvm_loop_opt. (Ignored for non-LLVM targets.)\u000A    halide_target_feature_disable_llvm_loop_opt,  ///< Disable loop vectorization + unrolling in LLVM. (Ignored for non-LLVM targets.)\u000A    halide_target_feature_wasm_simd128,  ///< Enable +simd128 instructions for WebAssembly codegen.\u000A    halide_target_feature_wasm_signext,  ///< Enable +sign-ext instructions for WebAssembly codegen.\u000A    halide_target_feature_sve, ///< Enable ARM Scalable Vector Extensions\u000A    halide_target_feature_sve2, ///< Enable ARM Scalable Vector Extensions v2\u000A    halide_target_feature_egl,            ///< Force use of EGL support.\u000A    halide_target_feature_intel_fpga, ///< Enable Intel FPGAs\u000A    halide_target_feature_one_api, ///< Enable Intel OneAPI dpcpp program generation\u000A    halide_target_feature_intel_gpu, ///< Enable Intel Graphics\u000A    halide_target_feature_enable_synthesis, ///< Enable synthesizing binaries. Currently used only for Intel FPGAs.\u000A    halide_target_feature_cm, ///< Enable C for metal\u000A    halide_target_feature_end ///< A sentinel. Every target is considered to have this feature, and setting this feature does nothing.\u000A} halide_target_feature_t;\u000A\u000A/** This function is called internally by Halide in some situations to determine\u000A * if the current execution environment can support the given set of\u000A * halide_target_feature_t flags. The implementation must do the following:\u000A *\u000A * -- If there are flags set in features that the function knows *cannot* be supported, return 0.\u000A * -- Otherwise, return 1.\u000A * -- Note that any flags set in features that the function doesn't know how to test should be ignored;\u000A * this implies that a return value of 1 means \"not known to be bad\" rather than \"known to be good\".\u000A *\u000A * In other words: a return value of 0 means \"It is not safe to use code compiled with these features\",\u000A * while a return value of 1 means \"It is not obviously unsafe to use code compiled with these features\".\u000A *\u000A * The default implementation simply calls halide_default_can_use_target_features.\u000A *\u000A * Note that `features` points to an array of `count` uint64_t; this array must contain enough\u000A * bits to represent all the currently known features. Any excess bits must be set to zero.\u000A */\u000A// @{\u000Aextern int halide_can_use_target_features(int count, const uint64_t *features);\u000Atypedef int (*halide_can_use_target_features_t)(int count, const uint64_t *features);\u000Aextern halide_can_use_target_features_t halide_set_custom_can_use_target_features(halide_can_use_target_features_t);\u000A// @}\u000A\u000A/**\u000A * This is the default implementation of halide_can_use_target_features; it is provided\u000A * for convenience of user code that may wish to extend halide_can_use_target_features\u000A * but continue providing existing support, e.g.\u000A *\u000A *     int halide_can_use_target_features(int count, const uint64_t *features) {\u000A *          if (features[halide_target_somefeature >> 6] & (1LL << (halide_target_somefeature & 63))) {\u000A *              if (!can_use_somefeature()) {\u000A *                  return 0;\u000A *              }\u000A *          }\u000A *          return halide_default_can_use_target_features(count, features);\u000A *     }\u000A */\u000Aextern int halide_default_can_use_target_features(int count, const uint64_t *features);\u000A\u000A\u000Atypedef struct halide_dimension_t {\u000A    int32_t min, extent, stride;\u000A\u000A    // Per-dimension flags. None are defined yet (This is reserved for future use).\u000A    uint32_t flags;\u000A\u000A#ifdef __cplusplus\u000A    HALIDE_ALWAYS_INLINE halide_dimension_t() : min(0), extent(0), stride(0), flags(0) {}\u000A    HALIDE_ALWAYS_INLINE halide_dimension_t(int32_t m, int32_t e, int32_t s, uint32_t f = 0) :\u000A        min(m), extent(e), stride(s), flags(f) {}\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator==(const halide_dimension_t &other) const {\u000A        return (min == other.min) &&\u000A            (extent == other.extent) &&\u000A            (stride == other.stride) &&\u000A            (flags == other.flags);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator!=(const halide_dimension_t &other) const {\u000A        return !(*this == other);\u000A    }\u000A#endif\u000A} halide_dimension_t;\u000A\u000A#ifdef __cplusplus\u000A} // extern \"C\"\u000A#endif\u000A\u000Atypedef enum {halide_buffer_flag_host_dirty = 1,\u000A              halide_buffer_flag_device_dirty = 2} halide_buffer_flags;\u000A\u000A/**\u000A * The raw representation of an image passed around by generated\u000A * Halide code. It includes some stuff to track whether the image is\u000A * not actually in main memory, but instead on a device (like a\u000A * GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>. */\u000Atypedef struct halide_buffer_t {\u000A    /** A device-handle for e.g. GPU memory used to back this buffer. */\u000A    uint64_t device;\u000A\u000A    /** The interface used to interpret the above handle. */\u000A    const struct halide_device_interface_t *device_interface;\u000A\u000A    /** A pointer to the start of the data in main memory. In terms of\u000A     * the Halide coordinate system, this is the address of the min\u000A     * coordinates (defined below). */\u000A    uint8_t* host;\u000A\u000A    /** flags with various meanings. */\u000A    uint64_t flags;\u000A\u000A    /** The type of each buffer element. */\u000A    struct halide_type_t type;\u000A\u000A    /** The dimensionality of the buffer. */\u000A    int32_t dimensions;\u000A\u000A    /** The shape of the buffer. Halide does not own this array - you\u000A     * must manage the memory for it yourself. */\u000A    halide_dimension_t *dim;\u000A\u000A    /** Pads the buffer up to a multiple of 8 bytes */\u000A    void *padding;\u000A\u000A#ifdef __cplusplus\u000A    /** Convenience methods for accessing the flags */\u000A    // @{\u000A    HALIDE_ALWAYS_INLINE bool get_flag(halide_buffer_flags flag) const {\u000A        return (flags & flag) != 0;\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_flag(halide_buffer_flags flag, bool value) {\u000A        if (value) {\u000A            flags |= flag;\u000A        } else {\u000A            flags &= ~flag;\u000A        }\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool host_dirty() const {\u000A        return get_flag(halide_buffer_flag_host_dirty);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool device_dirty() const {\u000A        return get_flag(halide_buffer_flag_device_dirty);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_host_dirty(bool v = true) {\u000A        set_flag(halide_buffer_flag_host_dirty, v);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_device_dirty(bool v = true) {\u000A        set_flag(halide_buffer_flag_device_dirty, v);\u000A    }\u000A    // @}\u000A\u000A    /** The total number of elements this buffer represents. Equal to\u000A     * the product of the extents */\u000A    HALIDE_ALWAYS_INLINE size_t number_of_elements() const {\u000A        size_t s = 1;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            s *= dim[i].extent;\u000A        }\u000A        return s;\u000A    }\u000A\u000A    /** A pointer to the element with the lowest address. If all\u000A     * strides are positive, equal to the host pointer. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *begin() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            if (dim[i].stride < 0) {\u000A                index += dim[i].stride * (dim[i].extent - 1);\u000A            }\u000A        }\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** A pointer to one beyond the element with the highest address. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *end() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            if (dim[i].stride > 0) {\u000A                index += dim[i].stride * (dim[i].extent - 1);\u000A            }\u000A        }\u000A        index += 1;\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** The total number of bytes spanned by the data in memory. */\u000A    HALIDE_ALWAYS_INLINE size_t size_in_bytes() const {\u000A        return (size_t)(end() - begin());\u000A    }\u000A\u000A    /** A pointer to the element at the given location. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *address_of(const int *pos) const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            index += dim[i].stride * (pos[i] - dim[i].min);\u000A        }\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** Attempt to call device_sync for the buffer. If the buffer\u000A     * has no device_interface (or no device_sync), this is a quiet no-op.\u000A     * Calling this explicitly should rarely be necessary, except for profiling. */\u000A    HALIDE_ALWAYS_INLINE int device_sync(void *ctx = NULL) {\u000A        if (device_interface && device_interface->device_sync) {\u000A            return device_interface->device_sync(ctx, this);\u000A        }\u000A        return 0;\u000A    }\u000A\u000A    /** Check if an input buffer passed extern stage is a querying\u000A     * bounds. Compared to doing the host pointer check directly,\u000A     * this both adds clarity to code and will facilitate moving to\u000A     * another representation for bounds query arguments. */\u000A    HALIDE_ALWAYS_INLINE bool is_bounds_query() const {\u000A        return host == NULL && device == 0;\u000A    }\u000A\u000A#endif\u000A} halide_buffer_t;\u000A\u000A#ifdef __cplusplus\u000Aextern \"C\" {\u000A#endif\u000A\u000A#ifndef HALIDE_ATTRIBUTE_DEPRECATED\u000A#ifdef HALIDE_ALLOW_DEPRECATED\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x)\u000A#else\u000A#ifdef _MSC_VER\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x) __declspec(deprecated(x))\u000A#else\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x) __attribute__((deprecated(x)))\u000A#endif\u000A#endif\u000A#endif\u000A\u000A/** The old buffer_t, included for compatibility with old code. Don't\u000A * use it. */\u000A#ifndef BUFFER_T_DEFINED\u000A#define BUFFER_T_DEFINED\u000Atypedef struct buffer_t {\u000A    uint64_t dev;\u000A    uint8_t* host;\u000A    int32_t extent[4];\u000A    int32_t stride[4];\u000A    int32_t min[4];\u000A    int32_t elem_size;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) bool host_dirty;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) bool dev_dirty;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t _padding[10 - sizeof(void *)];\u000A} buffer_t;\u000A#endif // BUFFER_T_DEFINED\u000A\u000A/** Copies host pointer, mins, extents, strides, and device state from\u000A * an old-style buffer_t into a new-style halide_buffer_t. If bounds_query_only is nonzero,\u000A * the copy is only done if the old_buf has null host and dev (ie, a bounds query is being\u000A * performed); otherwise new_buf is left untouched. (This is used for input buffers to avoid\u000A * benign data races.) The dimensions and type fields of the new buffer_t should already be\u000A * set. Returns an error code if the upgrade could not be performed. */\u000Aextern int halide_upgrade_buffer_t(void *user_context, const char *name,\u000A                                   const buffer_t *old_buf, halide_buffer_t *new_buf,\u000A                                   int bounds_query_only);\u000A\u000A/** Copies the host pointer, mins, extents, strides, and device state\u000A * from a halide_buffer_t to a buffer_t. Also sets elem_size. Useful\u000A * for backporting the results of bounds inference. */\u000Aextern int halide_downgrade_buffer_t(void *user_context, const char *name,\u000A                                     const halide_buffer_t *new_buf, buffer_t *old_buf);\u000A\u000A/** Copies the dirty flags and device allocation state from a new\u000A * buffer_t back to a legacy buffer_t. */\u000Aextern int halide_downgrade_buffer_t_device_fields(void *user_context, const char *name,\u000A                                                   const halide_buffer_t *new_buf, buffer_t *old_buf);\u000A\u000A/** halide_scalar_value_t is a simple union able to represent all the well-known\u000A * scalar values in a filter argument. Note that it isn't tagged with a type;\u000A * you must ensure you know the proper type before accessing. Most user\u000A * code will never need to create instances of this struct; its primary use\u000A * is to hold def/min/max values in a halide_filter_argument_t. (Note that\u000A * this is conceptually just a union; it's wrapped in a struct to ensure\u000A * that it doesn't get anonymized by LLVM.)\u000A */\u000Astruct halide_scalar_value_t {\u000A    union {\u000A        bool b;\u000A        int8_t i8;\u000A        int16_t i16;\u000A        int32_t i32;\u000A        int64_t i64;\u000A        uint8_t u8;\u000A        uint16_t u16;\u000A        uint32_t u32;\u000A        uint64_t u64;\u000A        float f32;\u000A        double f64;\u000A        void *handle;\u000A    } u;\u000A    #ifdef __cplusplus\u000A    HALIDE_ALWAYS_INLINE halide_scalar_value_t() {u.u64 = 0;}\u000A    #endif\u000A};\u000A\u000Aenum halide_argument_kind_t {\u000A    halide_argument_kind_input_scalar = 0,\u000A    halide_argument_kind_input_buffer = 1,\u000A    halide_argument_kind_output_buffer = 2\u000A};\u000A\u000A/*\u000A    These structs must be robust across different compilers and settings; when\u000A    modifying them, strive for the following rules:\u000A\u000A    1) All fields are explicitly sized. I.e. must use int32_t and not \"int\"\u000A    2) All fields must land on an alignment boundary that is the same as their size\u000A    3) Explicit padding is added to make that so\u000A    4) The sizeof the struct is padded out to a multiple of the largest natural size thing in the struct\u000A    5) don't forget that 32 and 64 bit pointers are different sizes\u000A*/\u000A\u000A/**\u000A * Obsolete version of halide_filter_argument_t; only present in\u000A * code that wrote halide_filter_metadata_t version 0.\u000A */\u000Astruct halide_filter_argument_t_v0 {\u000A    const char *name;\u000A    int32_t kind;\u000A    int32_t dimensions;\u000A    struct halide_type_t type;\u000A    const struct halide_scalar_value_t *def, *min, *max;\u000A};\u000A\u000A/**\u000A * halide_filter_argument_t is essentially a plain-C-struct equivalent to\u000A * Halide::Argument; most user code will never need to create one.\u000A */\u000Astruct halide_filter_argument_t {\u000A    const char *name;       // name of the argument; will never be null or empty.\u000A    int32_t kind;           // actually halide_argument_kind_t\u000A    int32_t dimensions;     // always zero for scalar arguments\u000A    struct halide_type_t type;\u000A    // These pointers should always be null for buffer arguments,\u000A    // and *may* be null for scalar arguments. (A null value means\u000A    // there is no def/min/max/estimate specified for this argument.)\u000A    const struct halide_scalar_value_t *scalar_def, *scalar_min, *scalar_max, *scalar_estimate;\u000A    // This pointer should always be null for scalar arguments,\u000A    // and *may* be null for buffer arguments. If not null, it should always\u000A    // point to an array of dimensions*2 pointers, which will be the (min, extent)\u000A    // estimates for each dimension of the buffer. (Note that any of the pointers\u000A    // may be null as well.)\u000A    int64_t const* const* buffer_estimates;\u000A};\u000A\u000Astruct halide_filter_metadata_t {\u000A#ifdef __cplusplus\u000A    static const int32_t VERSION = 1;\u000A#endif\u000A\u000A    /** version of this metadata; currently always 1. */\u000A    int32_t version;\u000A\u000A    /** The number of entries in the arguments field. This is always >= 1. */\u000A    int32_t num_arguments;\u000A\u000A    /** An array of the filters input and output arguments; this will never be\u000A     * null. The order of arguments is not guaranteed (input and output arguments\u000A     * may come in any order); however, it is guaranteed that all arguments\u000A     * will have a unique name within a given filter. */\u000A    const struct halide_filter_argument_t* arguments;\u000A\u000A    /** The Target for which the filter was compiled. This is always\u000A     * a canonical Target string (ie a product of Target::to_string). */\u000A    const char* target;\u000A\u000A    /** The function name of the filter. */\u000A    const char* name;\u000A};\u000A\u000A/** halide_register_argv_and_metadata() is a **user-defined** function that\u000A * must be provided in order to use the registration.cc files produced\u000A * by Generators when the 'registration' output is requested. Each registration.cc\u000A * file provides a static initializer that calls this function with the given\u000A * filter's argv-call variant, its metadata, and (optionally) and additional\u000A * textual data that the build system chooses to tack on for its own purposes.\u000A * Note that this will be called at static-initializer time (i.e., before\u000A * main() is called), and in an unpredictable order. Note that extra_key_value_pairs\u000A * may be nullptr; if it's not null, it's expected to be a null-terminated list\u000A * of strings, with an even number of entries. */\u000Avoid halide_register_argv_and_metadata(\u000A    int (*filter_argv_call)(void **),\u000A    const struct halide_filter_metadata_t *filter_metadata,\u000A    const char * const *extra_key_value_pairs\u000A);\u000A\u000A/** The functions below here are relevant for pipelines compiled with\u000A * the -profile target flag, which runs a sampling profiler thread\u000A * alongside the pipeline. */\u000A\u000A/** Per-Func state tracked by the sampling profiler. */\u000Astruct halide_profiler_func_stats {\u000A    /** Total time taken evaluating this Func (in nanoseconds). */\u000A    uint64_t time;\u000A\u000A    /** The current memory allocation of this Func. */\u000A    uint64_t memory_current;\u000A\u000A    /** The peak memory allocation of this Func. */\u000A    uint64_t memory_peak;\u000A\u000A    /** The total memory allocation of this Func. */\u000A    uint64_t memory_total;\u000A\u000A    /** The peak stack allocation of this Func's threads. */\u000A    uint64_t stack_peak;\u000A\u000A    /** The average number of thread pool worker threads active while computing this Func. */\u000A    uint64_t active_threads_numerator, active_threads_denominator;\u000A\u000A    /** The name of this Func. A global constant string. */\u000A    const char *name;\u000A\u000A    /** The total number of memory allocation of this Func. */\u000A    int num_allocs;\u000A};\u000A\u000A/** Per-pipeline state tracked by the sampling profiler. These exist\u000A * in a linked list. */\u000Astruct halide_profiler_pipeline_stats {\u000A    /** Total time spent inside this pipeline (in nanoseconds) */\u000A    uint64_t time;\u000A\u000A    /** The current memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_current;\u000A\u000A    /** The peak memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_peak;\u000A\u000A    /** The total memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_total;\u000A\u000A    /** The average number of thread pool worker threads doing useful\u000A     * work while computing this pipeline. */\u000A    uint64_t active_threads_numerator, active_threads_denominator;\u000A\u000A    /** The name of this pipeline. A global constant string. */\u000A    const char *name;\u000A\u000A    /** An array containing states for each Func in this pipeline. */\u000A    struct halide_profiler_func_stats *funcs;\u000A\u000A    /** The next pipeline_stats pointer. It's a void * because types\u000A     * in the Halide runtime may not currently be recursive. */\u000A    void *next;\u000A\u000A    /** The number of funcs in this pipeline. */\u000A    int num_funcs;\u000A\u000A    /** An internal base id used to identify the funcs in this pipeline. */\u000A    int first_func_id;\u000A\u000A    /** The number of times this pipeline has been run. */\u000A    int runs;\u000A\u000A    /** The total number of samples taken inside of this pipeline. */\u000A    int samples;\u000A\u000A    /** The total number of memory allocation of funcs in this pipeline. */\u000A    int num_allocs;\u000A};\u000A\u000A/** The global state of the profiler. */\u000A\u000Astruct halide_profiler_state {\u000A    /** Guards access to the fields below. If not locked, the sampling\u000A     * profiler thread is free to modify things below (including\u000A     * reordering the linked list of pipeline stats). */\u000A    struct halide_mutex lock;\u000A\u000A    /** The amount of time the profiler thread sleeps between samples\u000A     * in milliseconds. Defaults to 1 */\u000A    int sleep_time;\u000A\u000A    /** An internal id used for bookkeeping. */\u000A    int first_free_id;\u000A\u000A    /** The id of the current running Func. Set by the pipeline, read\u000A     * periodically by the profiler thread. */\u000A    int current_func;\u000A\u000A    /** The number of threads currently doing work. */\u000A    int active_threads;\u000A\u000A    /** A linked list of stats gathered for each pipeline. */\u000A    struct halide_profiler_pipeline_stats *pipelines;\u000A\u000A    /** Retrieve remote profiler state. Used so that the sampling\u000A     * profiler can follow along with execution that occurs elsewhere,\u000A     * e.g. on a DSP. If null, it reads from the int above instead. */\u000A    void (*get_remote_profiler_state)(int *func, int *active_workers);\u000A\u000A    /** Sampling thread reference to be joined at shutdown. */\u000A    struct halide_thread *sampling_thread;\u000A};\u000A\u000A/** Profiler func ids with special meanings. */\u000Aenum {\u000A    /// current_func takes on this value when not inside Halide code\u000A    halide_profiler_outside_of_halide = -1,\u000A    /// Set current_func to this value to tell the profiling thread to\u000A    /// halt. It will start up again next time you run a pipeline with\u000A    /// profiling enabled.\u000A    halide_profiler_please_stop = -2\u000A};\u000A\u000A/** Get a pointer to the global profiler state for programmatic\u000A * inspection. Lock it before using to pause the profiler. */\u000Aextern struct halide_profiler_state *halide_profiler_get_state();\u000A\u000A/** Get a pointer to the pipeline state associated with pipeline_name.\u000A * This function grabs the global profiler state's lock on entry. */\u000Aextern struct halide_profiler_pipeline_stats *halide_profiler_get_pipeline_state(const char *pipeline_name);\u000A\u000A/** Reset profiler state cheaply. May leave threads running or some\u000A * memory allocated but all accumluated statistics are reset.\u000A * WARNING: Do NOT call this method while any halide pipeline is\u000A * running; halide_profiler_memory_allocate/free and\u000A * halide_profiler_stack_peak_update update the profiler pipeline's\u000A * state without grabbing the global profiler state's lock. */\u000Aextern void halide_profiler_reset();\u000A\u000A/** Reset all profiler state.\u000A * WARNING: Do NOT call this method while any halide pipeline is\u000A * running; halide_profiler_memory_allocate/free and\u000A * halide_profiler_stack_peak_update update the profiler pipeline's\u000A * state without grabbing the global profiler state's lock. */\u000Avoid halide_profiler_shutdown();\u000A\u000A/** Print out timing statistics for everything run since the last\u000A * reset. Also happens at process exit. */\u000Aextern void halide_profiler_report(void *user_context);\u000A\u000A/// \\name \"Float16\" functions\u000A/// These functions operate of bits (``uint16_t``) representing a half\u000A/// precision floating point number (IEEE-754 2008 binary16).\u000A//{@\u000A\u000A/** Read bits representing a half precision floating point number and return\u000A *  the float that represents the same value */\u000Aextern float halide_float16_bits_to_float(uint16_t);\u000A\u000A/** Read bits representing a half precision floating point number and return\u000A *  the double that represents the same value */\u000Aextern double halide_float16_bits_to_double(uint16_t);\u000A\u000A// TODO: Conversion functions to half\u000A\u000A//@}\u000A\u000A// Allocating and freeing device memory is often very slow. The\u000A// methods below give Halide's runtime permission to hold onto device\u000A// memory to service future requests instead of returning it to the\u000A// underlying device API. The API does not manage an allocation pool,\u000A// all it does is provide access to a shared counter that acts as a\u000A// limit on the unused memory not yet returned to the underlying\u000A// device API. It makes callbacks to participants when memory needs to\u000A// be released because the limit is about to be exceeded (either\u000A// because the limit has been reduced, or because the memory owned by\u000A// some participant becomes unused).\u000A\u000A/** Tell Halide whether or not it is permitted to hold onto device\u000A * allocations to service future requests instead of returning them\u000A * eagerly to the underlying device API. Many device allocators are\u000A * quite slow, so it can be beneficial to set this to true. The\u000A * default value for now is false.\u000A *\u000A * Note that if enabled, the eviction policy is very simplistic. The\u000A * 32 most-recently used allocations are preserved, regardless of\u000A * their size. Additionally, if a call to cuMalloc results in an\u000A * out-of-memory error, the entire cache is flushed and the allocation\u000A * is retried. See https://github.com/halide/Halide/issues/4093\u000A *\u000A * If set to false, releases all unused device allocations back to the\u000A * underlying device APIs. For finer-grained control, see specific\u000A * methods in each device api runtime. */\u000Aextern int halide_reuse_device_allocations(void *user_context, bool);\u000A\u000A/** Determines whether on device_free the memory is returned\u000A * immediately to the device API, or placed on a free list for future\u000A * use. Override and switch based on the user_context for\u000A * finer-grained control. By default just returns the value most\u000A * recently set by the method above. */\u000Aextern bool halide_can_reuse_device_allocations(void *user_context);\u000A\u000Astruct halide_device_allocation_pool {\u000A    int (*release_unused)(void *user_context);\u000A    struct halide_device_allocation_pool *next;\u000A};\u000A\u000A/** Register a callback to be informed when\u000A * halide_reuse_device_allocations(false) is called, and all unused\u000A * device allocations must be released. The object passed should have\u000A * global lifetime, and its next field will be clobbered. */\u000Aextern void halide_register_device_allocation_pool(struct halide_device_allocation_pool *);\u000A\u000A#ifdef __cplusplus\u000A} // End extern \"C\"\u000A#endif\u000A\u000A#ifdef __cplusplus\u000A\u000Anamespace {\u000Atemplate<typename T> struct check_is_pointer;\u000Atemplate<typename T> struct check_is_pointer<T *> {};\u000A}\u000A\u000A/** Construct the halide equivalent of a C type */\u000Atemplate<typename T>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of() {\u000A    // Create a compile-time error if T is not a pointer (without\u000A    // using any includes - this code goes into the runtime).\u000A    check_is_pointer<T> check;\u000A    (void)check;\u000A    return halide_type_t(halide_type_handle, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<float>() {\u000A    return halide_type_t(halide_type_float, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<double>() {\u000A    return halide_type_t(halide_type_float, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<bool>() {\u000A    return halide_type_t(halide_type_uint, 1);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint8_t>() {\u000A    return halide_type_t(halide_type_uint, 8);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint16_t>() {\u000A    return halide_type_t(halide_type_uint, 16);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint32_t>() {\u000A    return halide_type_t(halide_type_uint, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint64_t>() {\u000A    return halide_type_t(halide_type_uint, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int8_t>() {\u000A    return halide_type_t(halide_type_int, 8);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int16_t>() {\u000A    return halide_type_t(halide_type_int, 16);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int32_t>() {\u000A    return halide_type_t(halide_type_int, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int64_t>() {\u000A    return halide_type_t(halide_type_int, 64);\u000A}\u000A\u000A#endif\u000A\u000A#endif // HALIDE_HALIDERUNTIME_H\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/complex_helper.hpp", "name":"complex_helper.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/complex_helper.hpp", "content":"#pragma once\u000A#include <complex>\u000A#include <array>\u000A\u000Anamespace t2sp {\u000Anamespace detail {\u000Atemplate <typename T, size_t N>\u000Aclass vec {\u000A    std::array<T, N> _arr;\u000A  public:\u000A    vec() = default;\u000A    vec(const vec &) = default;\u000A    vec(vec &&) = default;\u000A    vec &operator=(const vec &) = default;\u000A    vec &operator=(vec &&) = default;\u000A    vec(const T &arg) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] = arg;\u000A    }\u000A    template <typename ...Args>\u000A    vec(const Args &...args) : _arr{{args...}} {}\u000A    vec &operator=(const T& arg) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] = arg;\u000A        return *this;\u000A    }\u000A    T &operator[](size_t n) {\u000A        return _arr[n];\u000A    }\u000A    const T &operator[](size_t n) const {\u000A        return _arr[n];\u000A    }\u000A    vec &operator+=(const vec &rhs) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] += rhs._arr[i];\u000A        return *this;\u000A    }\u000A    vec &operator+=(const T &rhs) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] += rhs;\u000A        return *this;\u000A    }\u000A    vec &operator-=(const vec &rhs) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] -= rhs._arr[i];\u000A        return *this;\u000A    }\u000A    vec &operator-=(const T &rhs) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] -= rhs;\u000A        return *this;\u000A    }\u000A    vec &operator*=(const vec &rhs) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] *= rhs._arr[i];\u000A        return *this;\u000A    }\u000A    vec &operator*=(const T &arg) {\u000A        for (size_t i = 0; i < N; i++) _arr[i] *= arg;\u000A        return *this;\u000A    }\u000A    friend vec operator+(const vec &arg) {\u000A        return arg;\u000A    }\u000A    friend vec operator-(const vec &arg) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = -arg._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator+(const vec &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] + rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator+(const vec &lhs, const T &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] + rhs;\u000A        return ret;\u000A    }\u000A    friend vec operator+(const T &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs + rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator-(const vec &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] - rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator-(const vec &lhs, const T &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] - rhs;\u000A        return ret;\u000A    }\u000A    friend vec operator-(const T &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs - rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator*(const vec &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] * rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend vec operator*(const vec &lhs, const T &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs._arr[i] * rhs;\u000A        return ret;\u000A    }\u000A    friend vec operator*(const T &lhs, const vec &rhs) {\u000A        vec ret{};\u000A        for (size_t i = 0; i < N; i++) ret._arr[i] = lhs * rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend bool operator==(const vec &lhs, const vec &rhs) {\u000A        bool ret = true;\u000A        for (size_t i = 0; i < N; i++) ret = ret && lhs._arr[i] == rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend bool operator==(const vec &lhs, const T &rhs) {\u000A        bool ret = true;\u000A        for (size_t i = 0; i < N; i++) ret = ret && lhs._arr[i] == rhs;\u000A        return ret;\u000A    }\u000A    friend bool operator==(const T &lhs, const vec &rhs) {\u000A        bool ret = true;\u000A        for (size_t i = 0; i < N; i++) ret = ret && lhs == rhs._arr[i];\u000A        return ret;\u000A    }\u000A    friend bool operator!=(const vec &lhs, const vec &rhs) {\u000A        return !(lhs == rhs);\u000A    }\u000A    friend bool operator!=(const vec &lhs, const T &rhs) {\u000A        return !(lhs == rhs);\u000A    }\u000A    friend bool operator!=(const T &lhs, const vec &rhs) {\u000A        return !(lhs == rhs);\u000A    }\u000A};\u000A}\u000A}\u000A\u000Ausing complexf = std::complex<float>;\u000Ausing complexd = std::complex<double>;\u000Ausing complexf2 = t2sp::detail::vec<complexf, 2>;\u000Ausing complexf4 = t2sp::detail::vec<complexf, 4>;\u000Ausing complexf8 = t2sp::detail::vec<complexf, 8>;\u000Ausing complexf16 = t2sp::detail::vec<complexf, 16>;\u000Ausing complexd2 = t2sp::detail::vec<complexd, 2>;\u000Ausing complexd4 = t2sp::detail::vec<complexd, 4>;\u000Ausing complexd8 = t2sp::detail::vec<complexd, 8>;\u000Ausing complexd16 = t2sp::detail::vec<complexd, 16>;"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/constexpr_math.hpp", "name":"constexpr_math.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/constexpr_math.hpp", "content":"#ifndef __CONSTEXPR_MATH__\u000A#define __CONSTEXPR_MATH__\u000A\u000A//\u000A// This file contains various helper C++ metaprogramming math functions that\u000A// are useful across various designs.\u000A//\u000A\u000A#include <limits>\u000A\u000Anamespace fpga_tools {\u000A\u000A// returns the absolute value of 'x'\u000Atemplate <typename T>\u000Aconstexpr T Abs(T x) { return (x < 0) ? -x : x; }\u000A\u000A// returns the minimum of 'a' and 'b'.\u000A// The type, 'T', must have an operator<\u000Atemplate <typename T>\u000Aconstexpr T Min(T a, T b) { return (a < b) ? a : b; }\u000A\u000A// returns the maximum of 'a' and 'b'.\u000A// The type, 'T', must have an operator>\u000Atemplate <typename T>\u000Aconstexpr T Max(T a, T b) { return (a > b) ? a : b; }\u000A\u000A// rounds up to the nearest multiple of of 'multiple'\u000A// only works for positive numbers\u000Atemplate <typename T>\u000Aconstexpr T RoundUpToMultiple(T num, T multiple) {\u000A  static_assert(std::is_integral_v<T>);\u000A  static_assert(std::is_unsigned_v<T>);\u000A  if (multiple == 0) {\u000A    return num;\u000A  }\u000A\u000A  int remainder = num % multiple;\u000A  if (remainder == 0) {\u000A    return num;\u000A  } else {\u000A    return num + multiple - remainder;\u000A  }\u000A}\u000A\u000A// returns n^2\u000Atemplate <typename T>\u000Aconstexpr T Pow2(T n) {\u000A  static_assert(std::is_integral_v<T>);\u000A  return (n < 0) ? (T(1) << (-n)) : (T(1) << n);\u000A}\u000A\u000A// returns whether abs(n) is a power of 2\u000Atemplate <typename T>\u000Aconstexpr bool IsPow2(T n) {\u000A  static_assert(std::is_integral_v<T>);\u000A  if (n < 0) n = -n;\u000A  return (n != 0) && ((n & (n - 1)) == 0);\u000A}\u000A\u000A// returns log2(n) rounding down\u000Atemplate <typename T>\u000Aconstexpr T Log2(T n) {\u000A  static_assert(std::is_integral_v<T>);\u000A  if (n < 2) {\u000A    return T(0);\u000A  } else {\u000A    T ret = 0;\u000A    while (n >= 2) {\u000A      ret++;\u000A      n /= 2;\u000A    }\u000A    return ret;\u000A  }\u000A}\u000A\u000A// returns log(2) rounded up\u000Atemplate <typename T>\u000Astatic constexpr T CeilLog2(T n) {\u000A  return ((n == 1) ? T(0) : Log2(n - 1) + T(1));\u000A}\u000A\u000A\u000A// returns the number of bits required to encode all the values between 0 and N\u000Atemplate <unsigned int n>\u000Astatic constexpr unsigned int BitsForMaxValue() {\u000A  return CeilLog2(n + 1);\u000A}\u000A\u000A\u000A// return 'n' rounded up to the nearest power of 2\u000Atemplate <typename T>\u000Aconstexpr T RoundUpPow2(T n) {\u000A  static_assert(std::is_integral_v<T>);\u000A  static_assert(std::is_unsigned_v<T>);\u000A  if (n == 0) {\u000A    return 2;\u000A  } else if (IsPow2(n)) {\u000A    return n;\u000A  } else {\u000A    return T(1) << (Log2(n) + 1);\u000A  }\u000A}\u000A\u000A// computes x^y where y must be an integer (positive or negative)\u000Aconstexpr double Pow(double x, int y) {\u000A  if (y == 0) {\u000A    // x^0 = 1\u000A    return 1.0;\u000A  } else {\u000A    // handle both y < 0 and y > 0 by changing loop bound and multiply value\u000A    bool y_is_negative = (y < 0);\u000A    double mult_val = y_is_negative ? (1/x) : x;\u000A    int loop_bound = y_is_negative ? -y : y;\u000A\u000A    double ret = 1.0;\u000A    for (int i = 0; i < loop_bound; i++) {\u000A      ret *= mult_val;\u000A    }\u000A    return ret;\u000A  }\u000A}\u000A\u000A// estimates e^(x) for x >= 0 using a taylor series expansion\u000A// https://en.wikipedia.org/wiki/Taylor_series\u000Aconstexpr double Exp(double x, unsigned taylor_terms=32) {\u000A  double factorial = 1.0;\u000A  double power = 1.0;\u000A  double answer = 1.0;\u000A\u000A  for(int i = 1; i < taylor_terms-1; i++) {\u000A    power *= x;\u000A    factorial *= i;\u000A    answer += power / factorial;\u000A  }\u000A  return answer;\u000A}\u000A\u000A// Scale significand using floating-point base exponent\u000A// see: http://www.cplusplus.com/reference/cmath/scalbn/\u000Aconstexpr float Scalbn(float value, int exponent) {\u000A  if (exponent == 0) {\u000A    return value;\u000A  } else {\u000A    float ret = value;\u000A    while(exponent != 0) {\u000A      if (exponent > 0) {\u000A        ret *= 2;\u000A        exponent--;\u000A      } else {\u000A        ret /= 2;\u000A        exponent++;\u000A      }\u000A    }\u000A    return ret;\u000A  }\u000A}\u000A\u000A// extract the exponent from a 32-bit float\u000Aconstexpr int FP32ExtractExponent(float x) {\u000A  if (x == 0) {\u000A    return 0;\u000A  } else {\u000A    float ret = 0;\u000A    float abs_x = Abs(x);\u000A    while (abs_x >= 2 || abs_x < 1) {\u000A      bool abs_x_gte_2 = (abs_x >= 2);\u000A      ret += (abs_x_gte_2 ? 1 : -1);\u000A      x = (abs_x_gte_2 ? (x/2) : (x*2));\u000A      abs_x = Abs(x);\u000A    }\u000A    return ret;\u000A  }\u000A}\u000A\u000A// extract the mantissa from a 32-bit float\u000Aconstexpr int FP32ExtractMantissa(float x) {\u000A  // remove hidden 1 and bias the exponent to get integer\u000A  //#pragma clang fp contract(off)\u000A  //return (Abs(x) < std::numeric_limits<float>::infinity()) ?\u000A  //        Scalbn(Scalbn(Abs(x),-FP32ExtractExponent(x))-1,23) : 0;\u000A  return Scalbn(Scalbn(Abs(x),-FP32ExtractExponent(x))-1,23);\u000A}\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __CONSTEXPR_MATH__ */\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/halide_runtime_etc.h", "name":"halide_runtime_etc.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/halide_runtime_etc.h", "content":"#pragma once\u000A#include <iostream>\u000A#include <math.h>\u000A#include <float.h>\u000A#include <assert.h>\u000A#include <limits.h>\u000A#include <string.h>\u000A#include <stdio.h>\u000A#include <stdint.h>\u000A\u000Aextern \"C\" {\u000Aint64_t halide_current_time_ns(void *ctx);\u000Avoid halide_profiler_pipeline_end(void *, void *);\u000A}\u000A\u000A#ifdef _WIN32\u000A__declspec(dllimport) float __cdecl roundf(float);\u000A__declspec(dllimport) double __cdecl round(double);\u000A#else\u000Ainline float asinh_f32(float x) {return asinhf(x);}\u000Ainline float acosh_f32(float x) {return acoshf(x);}\u000Ainline float atanh_f32(float x) {return atanhf(x);}\u000Ainline double asinh_f64(double x) {return asinh(x);}\u000Ainline double acosh_f64(double x) {return acosh(x);}\u000Ainline double atanh_f64(double x) {return atanh(x);}\u000A#endif\u000Ainline float sqrt_f32(float x) {return sqrtf(x);}\u000Ainline float sin_f32(float x) {return sinf(x);}\u000Ainline float asin_f32(float x) {return asinf(x);}\u000Ainline float cos_f32(float x) {return cosf(x);}\u000Ainline float acos_f32(float x) {return acosf(x);}\u000Ainline float tan_f32(float x) {return tanf(x);}\u000Ainline float atan_f32(float x) {return atanf(x);}\u000Ainline float atan2_f32(float x, float y) {return atan2f(x, y);}\u000Ainline float sinh_f32(float x) {return sinhf(x);}\u000Ainline float cosh_f32(float x) {return coshf(x);}\u000Ainline float tanh_f32(float x) {return tanhf(x);}\u000Ainline float hypot_f32(float x, float y) {return hypotf(x, y);}\u000Ainline float exp_f32(float x) {return expf(x);}\u000Ainline float log_f32(float x) {return logf(x);}\u000Ainline float pow_f32(float x, float y) {return powf(x, y);}\u000Ainline float floor_f32(float x) {return floorf(x);}\u000Ainline float ceil_f32(float x) {return ceilf(x);}\u000Ainline float round_f32(float x) {return roundf(x);}\u000A\u000Ainline double sqrt_f64(double x) {return sqrt(x);}\u000Ainline double sin_f64(double x) {return sin(x);}\u000Ainline double asin_f64(double x) {return asin(x);}\u000Ainline double cos_f64(double x) {return cos(x);}\u000Ainline double acos_f64(double x) {return acos(x);}\u000Ainline double tan_f64(double x) {return tan(x);}\u000Ainline double atan_f64(double x) {return atan(x);}\u000Ainline double atan2_f64(double x, double y) {return atan2(x, y);}\u000Ainline double sinh_f64(double x) {return sinh(x);}\u000Ainline double cosh_f64(double x) {return cosh(x);}\u000Ainline double tanh_f64(double x) {return tanh(x);}\u000Ainline double hypot_f64(double x, double y) {return hypot(x, y);}\u000Ainline double exp_f64(double x) {return exp(x);}\u000Ainline double log_f64(double x) {return log(x);}\u000Ainline double pow_f64(double x, double y) {return pow(x, y);}\u000Ainline double floor_f64(double x) {return floor(x);}\u000Ainline double ceil_f64(double x) {return ceil(x);}\u000Ainline double round_f64(double x) {return round(x);}\u000A\u000Ainline float nan_f32() {return NAN;}\u000Ainline float neg_inf_f32() {return -INFINITY;}\u000Ainline float inf_f32() {return INFINITY;}\u000Ainline bool is_nan_f32(float x) {return isnan(x);}\u000Ainline bool is_nan_f64(double x) {return isnan(x);}\u000Ainline bool is_inf_f32(float x) {return isinf(x);}\u000Ainline bool is_inf_f64(double x) {return isinf(x);}\u000Ainline bool is_finite_f32(float x) {return isfinite(x);}\u000Ainline bool is_finite_f64(double x) {return isfinite(x);}\u000A\u000Atemplate<typename A, typename B>\u000Ainline A reinterpret(const B &b) {\u000A    #if __cplusplus >= 201103L\u000A    static_assert(sizeof(A) == sizeof(B), \"type size mismatch\");\u000A    #endif\u000A    A a;\u000A    memcpy(&a, &b, sizeof(a));\u000A    return a;\u000A}\u000Ainline float float_from_bits(uint32_t bits) {\u000A    return reinterpret<float, uint32_t>(bits);\u000A}\u000A\u000Atemplate<typename T>\u000Ainline int halide_popcount(T a) {\u000A    int bits_set = 0;\u000A    while (a != 0) {\u000A        bits_set += a & 1;\u000A        a >>= 1;\u000A    }\u000A    return bits_set;\u000A}\u000A\u000Atemplate<typename T>\u000Ainline int halide_count_leading_zeros(T a) {\u000A    int leading_zeros = 0;\u000A    int bit = sizeof(a) * 8 - 1;\u000A    while (bit >= 0 && (a & (((T)1) << bit)) == 0) {\u000A        leading_zeros++;\u000A        bit--;\u000A    }\u000A    return leading_zeros;\u000A}\u000A\u000Atemplate<typename T>\u000Ainline int halide_count_trailing_zeros(T a) {\u000A    int trailing_zeros = 0;\u000A    constexpr int bits = sizeof(a) * 8;\u000A    int bit = 0;\u000A    while (bit < bits && (a & (((T)1) << bit)) == 0) {\u000A        trailing_zeros++;\u000A        bit++;\u000A    }\u000A    return trailing_zeros;\u000A}\u000A\u000Atemplate<typename T>\u000Ainline T halide_cpp_max(const T &a, const T &b) {return (a > b) ? a : b;}\u000A\u000Atemplate<typename T>\u000Ainline T halide_cpp_min(const T &a, const T &b) {return (a < b) ? a : b;}\u000A\u000Atemplate<typename A, typename B>\u000Aconst B &return_second(const A &a, const B &b) {\u000A    (void) a;\u000A    return b;\u000A}\u000A\u000Atemplate<typename A, typename B>\u000Ainline auto quiet_div(const A &a, const B &b) -> decltype(a / b) {\u000A    return b == 0 ? static_cast<decltype(a / b)>(0) : (a / b);\u000A}\u000A\u000Atemplate<typename A, typename B>\u000Ainline auto quiet_mod(const A &a, const B &b) -> decltype(a % b) {\u000A    return b == 0 ? static_cast<decltype(a % b)>(0) : (a % b);\u000A}\u000A\u000Anamespace {\u000Aclass HalideFreeHelper {\u000A    typedef void (*FreeFunction)(void *user_context, void *p);\u000A    void * user_context;\u000A    void *p;\u000A    FreeFunction free_function;\u000Apublic:\u000A    HalideFreeHelper(void *user_context, void *p, FreeFunction free_function)\u000A        : user_context(user_context), p(p), free_function(free_function) {}\u000A    ~HalideFreeHelper() { free(); }\u000A    void free() {\u000A        if (p) {\u000A            // TODO: do all free_functions guarantee to ignore a nullptr?\u000A            free_function(user_context, p);\u000A            p = nullptr;\u000A        }\u000A    }\u000A};\u000A} // namespace\u000A#ifndef HALIDE_HALIDERUNTIME_H\u000A#define HALIDE_HALIDERUNTIME_H\u000A\u000A#ifndef COMPILING_HALIDE_RUNTIME\u000A#include <stdbool.h>\u000A#include <stddef.h>\u000A#include <stdint.h>\u000A#include <string.h>\u000A#else\u000A#include \"runtime_internal.h\"\u000A#endif\u000A\u000A#ifdef __cplusplus\u000A// Forward declare type to allow naming typed handles.\u000A// See Type.h for documentation.\u000Atemplate<typename T> struct halide_handle_traits;\u000A#endif\u000A\u000A#ifdef __cplusplus\u000Aextern \"C\" {\u000A#endif\u000A\u000A// Note that you should not use \"inline\" along with HALIDE_ALWAYS_INLINE;\u000A// it is not necessary, and may produce warnings for some build configurations.\u000A#ifdef _MSC_VER\u000A#define HALIDE_ALWAYS_INLINE __forceinline\u000A#define HALIDE_NEVER_INLINE __declspec(noinline)\u000A#else\u000A#define HALIDE_ALWAYS_INLINE __attribute__((always_inline)) inline\u000A#define HALIDE_NEVER_INLINE __attribute__((noinline))\u000A#endif\u000A\u000A#ifndef HALIDE_MUST_USE_RESULT\u000A#ifdef __has_attribute\u000A#if __has_attribute(nodiscard)\u000A// C++17 or later\u000A#define HALIDE_MUST_USE_RESULT [[nodiscard]]\u000A#elif __has_attribute(warn_unused_result)\u000A// Clang/GCC\u000A#define HALIDE_MUST_USE_RESULT __attribute__((warn_unused_result))\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#endif\u000A\u000A/** \\file\u000A *\u000A * This file declares the routines used by Halide internally in its\u000A * runtime. On platforms that support weak linking, these can be\u000A * replaced with user-defined versions by defining an extern \"C\"\u000A * function with the same name and signature.\u000A *\u000A * When doing Just In Time (JIT) compilation methods on the Func being\u000A * compiled must be called instead. The corresponding methods are\u000A * documented below.\u000A *\u000A * All of these functions take a \"void *user_context\" parameter as their\u000A * first argument; if the Halide kernel that calls back to any of these\u000A * functions has been compiled with the UserContext feature set on its Target,\u000A * then the value of that pointer passed from the code that calls the\u000A * Halide kernel is piped through to the function.\u000A *\u000A * Some of these are also useful to call when using the default\u000A * implementation. E.g. halide_shutdown_thread_pool.\u000A *\u000A * Note that even on platforms with weak linking, some linker setups\u000A * may not respect the override you provide. E.g. if the override is\u000A * in a shared library and the halide object files are linked directly\u000A * into the output, the builtin versions of the runtime functions will\u000A * be called. See your linker documentation for more details. On\u000A * Linux, LD_DYNAMIC_WEAK=1 may help.\u000A *\u000A */\u000A\u000A// Forward-declare to suppress warnings if compiling as C.\u000Astruct halide_buffer_t;\u000Astruct buffer_t;\u000A\u000A/** Print a message to stderr. Main use is to support tracing\u000A * functionality, print, and print_when calls. Also called by the default\u000A * halide_error.  This function can be replaced in JITed code by using\u000A * halide_custom_print and providing an implementation of halide_print\u000A * in AOT code. See Func::set_custom_print.\u000A */\u000A// @{\u000Aextern void halide_print(void *user_context, const char *);\u000Aextern void halide_default_print(void *user_context, const char *);\u000Atypedef void (*halide_print_t)(void *, const char *);\u000Aextern halide_print_t halide_set_custom_print(halide_print_t print);\u000A// @}\u000A\u000A/** Halide calls this function on runtime errors (for example bounds\u000A * checking failures). This function can be replaced in JITed code by\u000A * using Func::set_error_handler, or in AOT code by calling\u000A * halide_set_error_handler. In AOT code on platforms that support\u000A * weak linking (i.e. not Windows), you can also override it by simply\u000A * defining your own halide_error.\u000A */\u000A// @{\u000Aextern void halide_error(void *user_context, const char *);\u000Aextern void halide_default_error(void *user_context, const char *);\u000Atypedef void (*halide_error_handler_t)(void *, const char *);\u000Aextern halide_error_handler_t halide_set_error_handler(halide_error_handler_t handler);\u000A// @}\u000A\u000A/** Cross-platform mutex. Must be initialized with zero and implementation\u000A * must treat zero as an unlocked mutex with no waiters, etc.\u000A */\u000Astruct halide_mutex {\u000A    uintptr_t _private[1];\u000A};\u000A\u000A/** Cross platform condition variable. Must be initialized to 0. */\u000Astruct halide_cond {\u000A    uintptr_t _private[1];\u000A};\u000A\u000A/** A basic set of mutex and condition variable functions, which call\u000A * platform specific code for mutual exclusion. Equivalent to posix\u000A * calls. */\u000A//@{\u000Aextern void halide_mutex_lock(struct halide_mutex *mutex);\u000Aextern void halide_mutex_unlock(struct halide_mutex *mutex);\u000Aextern void halide_cond_signal(struct halide_cond *cond);\u000Aextern void halide_cond_broadcast(struct halide_cond *cond);\u000Aextern void halide_cond_wait(struct halide_cond *cond, struct halide_mutex *mutex);\u000A//@}\u000A\u000A/** Functions for constructing/destroying/locking/unlocking arrays of mutexes. */\u000Astruct halide_mutex_array;\u000A//@{\u000Aextern struct halide_mutex_array* halide_mutex_array_create(int sz);\u000Aextern void halide_mutex_array_destroy(void *user_context, void *array);\u000Aextern int halide_mutex_array_lock(struct halide_mutex_array *array, int entry);\u000Aextern int halide_mutex_array_unlock(struct halide_mutex_array *array, int entry);\u000A//@}\u000A\u000A/** Define halide_do_par_for to replace the default thread pool\u000A * implementation. halide_shutdown_thread_pool can also be called to\u000A * release resources used by the default thread pool on platforms\u000A * where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is\u000A * used so %Halide does not own the threads backing the pool and they\u000A * cannot be released.)  See Func::set_custom_do_task and\u000A * Func::set_custom_do_par_for. Should return zero if all the jobs\u000A * return zero, or an arbitrarily chosen return value from one of the\u000A * jobs otherwise.\u000A */\u000A//@{\u000Atypedef int (*halide_task_t)(void *user_context, int task_number, uint8_t *closure);\u000Aextern int halide_do_par_for(void *user_context,\u000A                             halide_task_t task,\u000A                             int min, int size, uint8_t *closure);\u000Aextern void halide_shutdown_thread_pool();\u000A//@}\u000A\u000A/** Set a custom method for performing a parallel for loop. Returns\u000A * the old do_par_for handler. */\u000Atypedef int (*halide_do_par_for_t)(void *, halide_task_t, int, int, uint8_t*);\u000Aextern halide_do_par_for_t halide_set_custom_do_par_for(halide_do_par_for_t do_par_for);\u000A\u000A/** An opaque struct representing a semaphore. Used by the task system for async tasks. */\u000Astruct halide_semaphore_t {\u000A    uint64_t _private[2];\u000A};\u000A\u000A/** A struct representing a semaphore and a number of items that must\u000A * be acquired from it. Used in halide_parallel_task_t below. */\u000Astruct halide_semaphore_acquire_t {\u000A    struct halide_semaphore_t *semaphore;\u000A    int count;\u000A};\u000Aextern int halide_semaphore_init(struct halide_semaphore_t *, int n);\u000Aextern int halide_semaphore_release(struct halide_semaphore_t *, int n);\u000Aextern bool halide_semaphore_try_acquire(struct halide_semaphore_t *, int n);\u000Atypedef int (*halide_semaphore_init_t)(struct halide_semaphore_t *, int);\u000Atypedef int (*halide_semaphore_release_t)(struct halide_semaphore_t *, int);\u000Atypedef bool (*halide_semaphore_try_acquire_t)(struct halide_semaphore_t *, int);\u000A\u000A\u000A/** A task representing a serial for loop evaluated over some range.\u000A * Note that task_parent is a pass through argument that should be\u000A * passed to any dependent taks that are invokved using halide_do_parallel_tasks\u000A * underneath this call. */\u000Atypedef int (*halide_loop_task_t)(void *user_context, int min, int extent,\u000A                                  uint8_t *closure, void *task_parent);\u000A\u000A/** A parallel task to be passed to halide_do_parallel_tasks. This\u000A * task may recursively call halide_do_parallel_tasks, and there may\u000A * be complex dependencies between seemingly unrelated tasks expressed\u000A * using semaphores. If you are using a custom task system, care must\u000A * be taken to avoid potential deadlock. This can be done by carefully\u000A * respecting the static metadata at the end of the task struct.*/\u000Astruct halide_parallel_task_t {\u000A    // The function to call. It takes a user context, a min and\u000A    // extent, a closure, and a task system pass through argument.\u000A    halide_loop_task_t fn;\u000A\u000A    // The closure to pass it\u000A    uint8_t *closure;\u000A\u000A    // The name of the function to be called. For debugging purposes only.\u000A    const char *name;\u000A\u000A    // An array of semaphores that must be acquired before the\u000A    // function is called. Must be reacquired for every call made.\u000A    struct halide_semaphore_acquire_t *semaphores;\u000A    int num_semaphores;\u000A\u000A    // The entire range the function should be called over. This range\u000A    // may be sliced up and the function called multiple times.\u000A    int min, extent;\u000A\u000A    // A parallel task provides several pieces of metadata to prevent\u000A    // unbounded resource usage or deadlock.\u000A\u000A    // The first is the minimum number of execution contexts (call\u000A    // stacks or threads) necessary for the function to run to\u000A    // completion. This may be greater than one when there is nested\u000A    // parallelism with internal producer-consumer relationships\u000A    // (calling the function recursively spawns and blocks on parallel\u000A    // sub-tasks that communicate with each other via semaphores). If\u000A    // a parallel runtime calls the function when fewer than this many\u000A    // threads are idle, it may need to create more threads to\u000A    // complete the task, or else risk deadlock due to committing all\u000A    // threads to tasks that cannot complete without more.\u000A    //\u000A    // FIXME: Note that extern stages are assumed to only require a\u000A    // single thread to complete. If the extern stage is itself a\u000A    // Halide pipeline, this may be an underestimate.\u000A    int min_threads;\u000A\u000A    // The calls to the function should be in serial order from min to min+extent-1, with only\u000A    // one executing at a time. If false, any order is fine, and\u000A    // concurrency is fine.\u000A    bool serial;\u000A};\u000A\u000A/** Enqueue some number of the tasks described above and wait for them\u000A * to complete. While waiting, the calling threads assists with either\u000A * the tasks enqueued, or other non-blocking tasks in the task\u000A * system. Note that task_parent should be NULL for top-level calls\u000A * and the pass through argument if this call is being made from\u000A * another task. */\u000Aextern int halide_do_parallel_tasks(void *user_context, int num_tasks,\u000A                                    struct halide_parallel_task_t *tasks,\u000A                                    void *task_parent);\u000A\u000A/** If you use the default do_par_for, you can still set a custom\u000A * handler to perform each individual task. Returns the old handler. */\u000A//@{\u000Atypedef int (*halide_do_task_t)(void *, halide_task_t, int, uint8_t *);\u000Aextern halide_do_task_t halide_set_custom_do_task(halide_do_task_t do_task);\u000Aextern int halide_do_task(void *user_context, halide_task_t f, int idx,\u000A                          uint8_t *closure);\u000A//@}\u000A\u000A/** The version of do_task called for loop tasks. By default calls the\u000A * loop task with the same arguments. */\u000A// @{\u000A  typedef int (*halide_do_loop_task_t)(void *, halide_loop_task_t, int, int, uint8_t *, void *);\u000Aextern halide_do_loop_task_t halide_set_custom_do_loop_task(halide_do_loop_task_t do_task);\u000Aextern int halide_do_loop_task(void *user_context, halide_loop_task_t f, int min, int extent,\u000A                               uint8_t *closure, void *task_parent);\u000A//@}\u000A\u000A/** Provide an entire custom tasking runtime via function\u000A * pointers. Note that do_task and semaphore_try_acquire are only ever\u000A * called by halide_default_do_par_for and\u000A * halide_default_do_parallel_tasks, so it's only necessary to provide\u000A * those if you are mixing in the default implementations of\u000A * do_par_for and do_parallel_tasks. */\u000A// @{\u000Atypedef int (*halide_do_parallel_tasks_t)(void *, int, struct halide_parallel_task_t *,\u000A                                          void *task_parent);\u000Aextern void halide_set_custom_parallel_runtime(\u000A    halide_do_par_for_t,\u000A    halide_do_task_t,\u000A    halide_do_loop_task_t,\u000A    halide_do_parallel_tasks_t,\u000A    halide_semaphore_init_t,\u000A    halide_semaphore_try_acquire_t,\u000A    halide_semaphore_release_t\u000A    );\u000A// @}\u000A\u000A/** The default versions of the parallel runtime functions. */\u000A// @{\u000Aextern int halide_default_do_par_for(void *user_context,\u000A                                     halide_task_t task,\u000A                                     int min, int size, uint8_t *closure);\u000Aextern int halide_default_do_parallel_tasks(void *user_context,\u000A                                            int num_tasks,\u000A                                            struct halide_parallel_task_t *tasks,\u000A                                            void *task_parent);\u000Aextern int halide_default_do_task(void *user_context, halide_task_t f, int idx,\u000A                                  uint8_t *closure);\u000Aextern int halide_default_do_loop_task(void *user_context, halide_loop_task_t f,\u000A                                       int min, int extent,\u000A                                       uint8_t *closure, void *task_parent);\u000Aextern int halide_default_semaphore_init(struct halide_semaphore_t *, int n);\u000Aextern int halide_default_semaphore_release(struct halide_semaphore_t *, int n);\u000Aextern bool halide_default_semaphore_try_acquire(struct halide_semaphore_t *, int n);\u000A// @}\u000A\u000Astruct halide_thread;\u000A\u000A/** Spawn a thread. Returns a handle to the thread for the purposes of\u000A * joining it. The thread must be joined in order to clean up any\u000A * resources associated with it. */\u000Aextern struct halide_thread *halide_spawn_thread(void (*f)(void *), void *closure);\u000A\u000A/** Join a thread. */\u000Aextern void halide_join_thread(struct halide_thread *);\u000A\u000A/** Set the number of threads used by Halide's thread pool. Returns\u000A * the old number.\u000A *\u000A * n < 0  : error condition\u000A * n == 0 : use a reasonable system default (typically, number of cpus online).\u000A * n == 1 : use exactly one thread; this will always enforce serial execution\u000A * n > 1  : use a pool of exactly n threads.\u000A *\u000A * (Note that this is only guaranteed when using the default implementations\u000A * of halide_do_par_for(); custom implementations may completely ignore values\u000A * passed to halide_set_num_threads().)\u000A */\u000Aextern int halide_set_num_threads(int n);\u000A\u000A/** Halide calls these functions to allocate and free memory. To\u000A * replace in AOT code, use the halide_set_custom_malloc and\u000A * halide_set_custom_free, or (on platforms that support weak\u000A * linking), simply define these functions yourself. In JIT-compiled\u000A * code use Func::set_custom_allocator.\u000A *\u000A * If you override them, and find yourself wanting to call the default\u000A * implementation from within your override, use\u000A * halide_default_malloc/free.\u000A *\u000A * Note that halide_malloc must return a pointer aligned to the\u000A * maximum meaningful alignment for the platform for the purpose of\u000A * vector loads and stores. The default implementation uses 32-byte\u000A * alignment, which is safe for arm and x86. Additionally, it must be\u000A * safe to read at least 8 bytes before the start and beyond the\u000A * end.\u000A */\u000A//@{\u000Aextern void *halide_malloc(void *user_context, size_t x);\u000Aextern void halide_free(void *user_context, void *ptr);\u000Aextern void *halide_default_malloc(void *user_context, size_t x);\u000Aextern void halide_default_free(void *user_context, void *ptr);\u000Atypedef void *(*halide_malloc_t)(void *, size_t);\u000Atypedef void (*halide_free_t)(void *, void *);\u000Aextern halide_malloc_t halide_set_custom_malloc(halide_malloc_t user_malloc);\u000Aextern halide_free_t halide_set_custom_free(halide_free_t user_free);\u000A//@}\u000A\u000A/** Halide calls these functions to interact with the underlying\u000A * system runtime functions. To replace in AOT code on platforms that\u000A * support weak linking, define these functions yourself, or use\u000A * the halide_set_custom_load_library() and halide_set_custom_get_library_symbol()\u000A * functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().\u000A *\u000A * halide_load_library and halide_get_library_symbol are equivalent to\u000A * dlopen and dlsym. halide_get_symbol(sym) is equivalent to\u000A * dlsym(RTLD_DEFAULT, sym).\u000A */\u000A//@{\u000Aextern void *halide_get_symbol(const char *name);\u000Aextern void *halide_load_library(const char *name);\u000Aextern void *halide_get_library_symbol(void *lib, const char *name);\u000Aextern void *halide_default_get_symbol(const char *name);\u000Aextern void *halide_default_load_library(const char *name);\u000Aextern void *halide_default_get_library_symbol(void *lib, const char *name);\u000Atypedef void *(*halide_get_symbol_t)(const char *name);\u000Atypedef void *(*halide_load_library_t)(const char *name);\u000Atypedef void *(*halide_get_library_symbol_t)(void *lib, const char *name);\u000Aextern halide_get_symbol_t halide_set_custom_get_symbol(halide_get_symbol_t user_get_symbol);\u000Aextern halide_load_library_t halide_set_custom_load_library(halide_load_library_t user_load_library);\u000Aextern halide_get_library_symbol_t halide_set_custom_get_library_symbol(halide_get_library_symbol_t user_get_library_symbol);\u000A//@}\u000A\u000A/** Called when debug_to_file is used inside %Halide code.  See\u000A * Func::debug_to_file for how this is called\u000A *\u000A * Cannot be replaced in JITted code at present.\u000A */\u000Aextern int32_t halide_debug_to_file(void *user_context, const char *filename,\u000A                                    int32_t type_code,\u000A                                    struct halide_buffer_t *buf);\u000A\u000A/** Types in the halide type system. They can be ints, unsigned ints,\u000A * or floats (of various bit-widths), or a handle (which is always 64-bits).\u000A * Note that the int/uint/float values do not imply a specific bit width\u000A * (the bit width is expected to be encoded in a separate value).\u000A */\u000Atypedef enum halide_type_code_t\u000A#if __cplusplus >= 201103L\u000A: uint8_t\u000A#endif\u000A{\u000A    halide_type_int = 0,   //!< signed integers\u000A    halide_type_uint = 1,  //!< unsigned integers\u000A    halide_type_float = 2, //!< IEEE floating point numbers\u000A    halide_type_handle = 3, //!< opaque pointer type (void *)\u000A    halide_type_bfloat = 4, //!< floating point numbers in the bfloat format\u000A    halide_type_complex = 5,\u000A} halide_type_code_t;\u000A\u000A// Note that while __attribute__ can go before or after the declaration,\u000A// __declspec apparently is only allowed before.\u000A#ifndef HALIDE_ATTRIBUTE_ALIGN\u000A    #ifdef _MSC_VER\u000A        #define HALIDE_ATTRIBUTE_ALIGN(x) __declspec(align(x))\u000A    #else\u000A        #define HALIDE_ATTRIBUTE_ALIGN(x) __attribute__((aligned(x)))\u000A    #endif\u000A#endif\u000A\u000A/** A runtime tag for a type in the halide type system. Can be ints,\u000A * unsigned ints, or floats of various bit-widths (the 'bits'\u000A * field). Can also be vectors of the same (by setting the 'lanes'\u000A * field to something larger than one). This struct should be\u000A * exactly 32-bits in size. */\u000Astruct halide_type_t {\u000A    /** The basic type code: signed integer, unsigned integer, or floating point. */\u000A#if __cplusplus >= 201103L\u000A    HALIDE_ATTRIBUTE_ALIGN(1) halide_type_code_t code; // halide_type_code_t\u000A#else\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t code; // halide_type_code_t\u000A#endif\u000A\u000A    /** The number of bits of precision of a single scalar value of this type. */\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t bits;\u000A\u000A    /** How many elements in a vector. This is 1 for scalar types. */\u000A    HALIDE_ATTRIBUTE_ALIGN(2) uint16_t lanes;\u000A\u000A#ifdef __cplusplus\u000A    /** Construct a runtime representation of a Halide type from:\u000A     * code: The fundamental type from an enum.\u000A     * bits: The bit size of one element.\u000A     * lanes: The number of vector elements in the type. */\u000A    HALIDE_ALWAYS_INLINE halide_type_t(halide_type_code_t code, uint8_t bits, uint16_t lanes = 1)\u000A        : code(code), bits(bits), lanes(lanes) {\u000A    }\u000A\u000A    /** Default constructor is required e.g. to declare halide_trace_event\u000A     * instances. */\u000A    HALIDE_ALWAYS_INLINE halide_type_t() : code((halide_type_code_t)0), bits(0), lanes(0) {}\u000A\u000A    HALIDE_ALWAYS_INLINE halide_type_t with_lanes(uint16_t new_lanes) const {\u000A        return halide_type_t((halide_type_code_t) code, bits, new_lanes);\u000A    }\u000A\u000A    /** Compare two types for equality. */\u000A    HALIDE_ALWAYS_INLINE bool operator==(const halide_type_t &other) const {\u000A        return as_u32() == other.as_u32();\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator!=(const halide_type_t &other) const {\u000A        return !(*this == other);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator<(const halide_type_t &other) const {\u000A        return as_u32() < other.as_u32();\u000A    }\u000A\u000A    /** Size in bytes for a single element, even if width is not 1, of this type. */\u000A    HALIDE_ALWAYS_INLINE int bytes() const { return (bits + 7) / 8; }\u000A\u000A    HALIDE_ALWAYS_INLINE uint32_t as_u32() const {\u000A        uint32_t u;\u000A        memcpy(&u, this, sizeof(u));\u000A        return u;\u000A    }\u000A#endif\u000A};\u000A\u000Aenum halide_trace_event_code_t {halide_trace_load = 0,\u000A                                halide_trace_store = 1,\u000A                                halide_trace_begin_realization = 2,\u000A                                halide_trace_end_realization = 3,\u000A                                halide_trace_produce = 4,\u000A                                halide_trace_end_produce = 5,\u000A                                halide_trace_consume = 6,\u000A                                halide_trace_end_consume = 7,\u000A                                halide_trace_begin_pipeline = 8,\u000A                                halide_trace_end_pipeline = 9,\u000A                                halide_trace_tag = 10 };\u000A\u000Astruct halide_trace_event_t {\u000A    /** The name of the Func or Pipeline that this event refers to */\u000A    const char *func;\u000A\u000A    /** If the event type is a load or a store, this points to the\u000A     * value being loaded or stored. Use the type field to safely cast\u000A     * this to a concrete pointer type and retrieve it. For other\u000A     * events this is null. */\u000A    void *value;\u000A\u000A    /** For loads and stores, an array which contains the location\u000A     * being accessed. For vector loads or stores it is an array of\u000A     * vectors of coordinates (the vector dimension is innermost).\u000A     *\u000A     * For realization or production-related events, this will contain\u000A     * the mins and extents of the region being accessed, in the order\u000A     * min0, extent0, min1, extent1, ...\u000A     *\u000A     * For pipeline-related events, this will be null.\u000A     */\u000A    int32_t *coordinates;\u000A\u000A    /** For halide_trace_tag, this points to a read-only null-terminated string\u000A     * of arbitrary text. For all other events, this will be null.\u000A     */\u000A    const char *trace_tag;\u000A\u000A    /** If the event type is a load or a store, this is the type of\u000A     * the data. Otherwise, the value is meaningless. */\u000A    struct halide_type_t type;\u000A\u000A    /** The type of event */\u000A    enum halide_trace_event_code_t event;\u000A\u000A    /* The ID of the parent event (see below for an explanation of\u000A     * event ancestry). */\u000A    int32_t parent_id;\u000A\u000A    /** If this was a load or store of a Tuple-valued Func, this is\u000A     * which tuple element was accessed. */\u000A    int32_t value_index;\u000A\u000A    /** The length of the coordinates array */\u000A    int32_t dimensions;\u000A\u000A#ifdef __cplusplus\u000A    // If we don't explicitly mark the default ctor as inline,\u000A    // certain build configurations can fail (notably iOS)\u000A    HALIDE_ALWAYS_INLINE halide_trace_event_t() {}\u000A#endif\u000A};\u000A\u000A/** Called when Funcs are marked as trace_load, trace_store, or\u000A * trace_realization. See Func::set_custom_trace. The default\u000A * implementation either prints events via halide_print, or if\u000A * HL_TRACE_FILE is defined, dumps the trace to that file in a\u000A * sequence of trace packets. The header for a trace packet is defined\u000A * below. If the trace is going to be large, you may want to make the\u000A * file a named pipe, and then read from that pipe into gzip.\u000A *\u000A * halide_trace returns a unique ID which will be passed to future\u000A * events that \"belong\" to the earlier event as the parent id. The\u000A * ownership hierarchy looks like:\u000A *\u000A * begin_pipeline\u000A * +--trace_tag (if any)\u000A * +--trace_tag (if any)\u000A * ...\u000A * +--begin_realization\u000A * |  +--produce\u000A * |  |  +--load/store\u000A * |  |  +--end_produce\u000A * |  +--consume\u000A * |  |  +--load\u000A * |  |  +--end_consume\u000A * |  +--end_realization\u000A * +--end_pipeline\u000A *\u000A * Threading means that ownership cannot be inferred from the ordering\u000A * of events. There can be many active realizations of a given\u000A * function, or many active productions for a single\u000A * realization. Within a single production, the ordering of events is\u000A * meaningful.\u000A *\u000A * Note that all trace_tag events (if any) will occur just after the begin_pipeline\u000A * event, but before any begin_realization events. All trace_tags for a given Func\u000A * will be emitted in the order added.\u000A */\u000A// @}\u000Aextern int32_t halide_trace(void *user_context, const struct halide_trace_event_t *event);\u000Aextern int32_t halide_default_trace(void *user_context, const struct halide_trace_event_t *event);\u000Atypedef int32_t (*halide_trace_t)(void *user_context, const struct halide_trace_event_t *);\u000Aextern halide_trace_t halide_set_custom_trace(halide_trace_t trace);\u000A// @}\u000A\u000A/** The header of a packet in a binary trace. All fields are 32-bit. */\u000Astruct halide_trace_packet_t {\u000A    /** The total size of this packet in bytes. Always a multiple of\u000A     * four. Equivalently, the number of bytes until the next\u000A     * packet. */\u000A    uint32_t size;\u000A\u000A    /** The id of this packet (for the purpose of parent_id). */\u000A    int32_t id;\u000A\u000A    /** The remaining fields are equivalent to those in halide_trace_event_t */\u000A    // @{\u000A    struct halide_type_t type;\u000A    enum halide_trace_event_code_t event;\u000A    int32_t parent_id;\u000A    int32_t value_index;\u000A    int32_t dimensions;\u000A    // @}\u000A\u000A    #ifdef __cplusplus\u000A    // If we don't explicitly mark the default ctor as inline,\u000A    // certain build configurations can fail (notably iOS)\u000A    HALIDE_ALWAYS_INLINE halide_trace_packet_t() {}\u000A\u000A    /** Get the coordinates array, assuming this packet is laid out in\u000A     * memory as it was written. The coordinates array comes\u000A     * immediately after the packet header. */\u000A    HALIDE_ALWAYS_INLINE const int *coordinates() const {\u000A        return (const int *)(this + 1);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE int *coordinates() {\u000A        return (int *)(this + 1);\u000A    }\u000A\u000A    /** Get the value, assuming this packet is laid out in memory as\u000A     * it was written. The packet comes immediately after the coordinates\u000A     * array. */\u000A    HALIDE_ALWAYS_INLINE const void *value() const {\u000A        return (const void *)(coordinates() + dimensions);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void *value() {\u000A        return (void *)(coordinates() + dimensions);\u000A    }\u000A\u000A    /** Get the func name, assuming this packet is laid out in memory\u000A     * as it was written. It comes after the value. */\u000A    HALIDE_ALWAYS_INLINE const char *func() const {\u000A        return (const char *)value() + type.lanes * type.bytes();\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE char *func() {\u000A        return (char *)value() + type.lanes * type.bytes();\u000A    }\u000A\u000A    /** Get the trace_tag (if any), assuming this packet is laid out in memory\u000A     * as it was written. It comes after the func name. If there is no trace_tag,\u000A     * this will return a pointer to an empty string. */\u000A    HALIDE_ALWAYS_INLINE const char *trace_tag() const {\u000A        const char *f = func();\u000A        // strlen may not be available here\u000A        while (*f++) {\u000A            // nothing\u000A        }\u000A        return f;\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE char *trace_tag() {\u000A        char *f = func();\u000A        // strlen may not be available here\u000A        while (*f++) {\u000A            // nothing\u000A        }\u000A        return f;\u000A    }\u000A    #endif\u000A};\u000A\u000A\u000A\u000A/** Set the file descriptor that Halide should write binary trace\u000A * events to. If called with 0 as the argument, Halide outputs trace\u000A * information to stdout in a human-readable format. If never called,\u000A * Halide checks the for existence of an environment variable called\u000A * HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined,\u000A * it outputs trace information to stdout in a human-readable\u000A * format. */\u000Aextern void halide_set_trace_file(int fd);\u000A\u000A/** Halide calls this to retrieve the file descriptor to write binary\u000A * trace events to. The default implementation returns the value set\u000A * by halide_set_trace_file. Implement it yourself if you wish to use\u000A * a custom file descriptor per user_context. Return zero from your\u000A * implementation to tell Halide to print human-readable trace\u000A * information to stdout. */\u000Aextern int halide_get_trace_file(void *user_context);\u000A\u000A/** If tracing is writing to a file. This call closes that file\u000A * (flushing the trace). Returns zero on success. */\u000Aextern int halide_shutdown_trace();\u000A\u000A/** All Halide GPU or device backend implementations provide an\u000A * interface to be used with halide_device_malloc, etc. This is\u000A * accessed via the functions below.\u000A */\u000A\u000A/** An opaque struct containing per-GPU API implementations of the\u000A * device functions. */\u000Astruct halide_device_interface_impl_t;\u000A\u000A/** Each GPU API provides a halide_device_interface_t struct pointing\u000A * to the code that manages device allocations. You can access these\u000A * functions directly from the struct member function pointers, or by\u000A * calling the functions declared below. Note that the global\u000A * functions are not available when using Halide as a JIT compiler.\u000A * If you are using raw halide_buffer_t in that context you must use\u000A * the function pointers in the device_interface struct.\u000A *\u000A * The function pointers below are currently the same for every GPU\u000A * API; only the impl field varies. These top-level functions do the\u000A * bookkeeping that is common across all GPU APIs, and then dispatch\u000A * to more API-specific functions via another set of function pointers\u000A * hidden inside the impl field.\u000A */\u000Astruct halide_device_interface_t {\u000A    int (*device_malloc)(void *user_context, struct halide_buffer_t *buf,\u000A                         const struct halide_device_interface_t *device_interface);\u000A    int (*device_free)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*device_sync)(void *user_context, struct halide_buffer_t *buf);\u000A    void (*device_release)(void *user_context,\u000A                          const struct halide_device_interface_t *device_interface);\u000A    int (*copy_to_host)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*copy_to_device)(void *user_context, struct halide_buffer_t *buf,\u000A                          const struct halide_device_interface_t *device_interface);\u000A    int (*device_and_host_malloc)(void *user_context, struct halide_buffer_t *buf,\u000A                                  const struct halide_device_interface_t *device_interface);\u000A    int (*device_and_host_free)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*buffer_copy)(void *user_context, struct halide_buffer_t *src,\u000A                       const struct halide_device_interface_t *dst_device_interface, struct halide_buffer_t *dst);\u000A    int (*device_crop)(void *user_context, const struct halide_buffer_t *src,\u000A                       struct halide_buffer_t *dst);\u000A    int (*device_slice)(void *user_context, const struct halide_buffer_t *src,\u000A                        int slice_dim, int slice_pos, struct halide_buffer_t *dst);\u000A    int (*device_release_crop)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*wrap_native)(void *user_context, struct halide_buffer_t *buf, uint64_t handle,\u000A                       const struct halide_device_interface_t *device_interface);\u000A    int (*detach_native)(void *user_context, struct halide_buffer_t *buf);\u000A    int (*compute_capability)(void *user_context, int *major, int *minor);\u000A    const struct halide_device_interface_impl_t *impl;\u000A};\u000A\u000A/** Release all data associated with the given device interface, in\u000A * particular all resources (memory, texture, context handles)\u000A * allocated by Halide. Must be called explicitly when using AOT\u000A * compilation. This is *not* thread-safe with respect to actively\u000A * running Halide code. Ensure all pipelines are finished before\u000A * calling this. */\u000Aextern void halide_device_release(void *user_context,\u000A                                  const struct halide_device_interface_t *device_interface);\u000A\u000A/** Copy image data from device memory to host memory. This must be called\u000A * explicitly to copy back the results of a GPU-based filter. */\u000Aextern int halide_copy_to_host(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Copy image data from host memory to device memory. This should not\u000A * be called directly; Halide handles copying to the device\u000A * automatically.  If interface is NULL and the buf has a non-zero dev\u000A * field, the device associated with the dev handle will be\u000A * used. Otherwise if the dev field is 0 and interface is NULL, an\u000A * error is returned. */\u000Aextern int halide_copy_to_device(void *user_context, struct halide_buffer_t *buf,\u000A                                 const struct halide_device_interface_t *device_interface);\u000A\u000A/** Copy data from one buffer to another. The buffers may have\u000A * different shapes and sizes, but the destination buffer's shape must\u000A * be contained within the source buffer's shape. That is, for each\u000A * dimension, the min on the destination buffer must be greater than\u000A * or equal to the min on the source buffer, and min+extent on the\u000A * destination buffer must be less that or equal to min+extent on the\u000A * source buffer. The source data is pulled from either device or\u000A * host memory on the source, depending on the dirty flags. host is\u000A * preferred if both are valid. The dst_device_interface parameter\u000A * controls the destination memory space. NULL means host memory. */\u000Aextern int halide_buffer_copy(void *user_context, struct halide_buffer_t *src,\u000A                              const struct halide_device_interface_t *dst_device_interface,\u000A                              struct halide_buffer_t *dst);\u000A\u000A/** Give the destination buffer a device allocation which is an alias\u000A * for the same coordinate range in the source buffer. Modifies the\u000A * device, device_interface, and the device_dirty flag only. Only\u000A * supported by some device APIs (others will return\u000A * halide_error_code_device_crop_unsupported). Call\u000A * halide_device_release_crop instead of halide_device_free to clean\u000A * up resources associated with the cropped view. Do not free the\u000A * device allocation on the source buffer while the destination buffer\u000A * still lives. Note that the two buffers do not share dirty flags, so\u000A * care must be taken to update them together as needed. Note that src\u000A * and dst are required to have the same number of dimensions.\u000A *\u000A * Note also that (in theory) device interfaces which support cropping may\u000A * still not support cropping a crop (instead, create a new crop of the parent\u000A * buffer); in practice, no known implementation has this limitation, although\u000A * it is possible that some future implementations may require it. */\u000Aextern int halide_device_crop(void *user_context,\u000A                              const struct halide_buffer_t *src,\u000A                              struct halide_buffer_t *dst);\u000A\u000A/** Give the destination buffer a device allocation which is an alias\u000A * for a similar coordinate range in the source buffer, but with one dimension\u000A * sliced away in the dst. Modifies the device, device_interface, and the\u000A * device_dirty flag only. Only supported by some device APIs (others will return\u000A * halide_error_code_device_crop_unsupported). Call\u000A * halide_device_release_crop instead of halide_device_free to clean\u000A * up resources associated with the sliced view. Do not free the\u000A * device allocation on the source buffer while the destination buffer\u000A * still lives. Note that the two buffers do not share dirty flags, so\u000A * care must be taken to update them together as needed. Note that the dst buffer\u000A * must have exactly one fewer dimension than the src buffer, and that slice_dim\u000A * and slice_pos must be valid within src. */\u000Aextern int halide_device_slice(void *user_context,\u000A                               const struct halide_buffer_t *src,\u000A                               int slice_dim, int slice_pos,\u000A                               struct halide_buffer_t *dst);\u000A\u000A/** Release any resources associated with a cropped/sliced view of another\u000A * buffer. */\u000Aextern int halide_device_release_crop(void *user_context,\u000A                                      struct halide_buffer_t *buf);\u000A\u000A/** Wait for current GPU operations to complete. Calling this explicitly\u000A * should rarely be necessary, except maybe for profiling. */\u000Aextern int halide_device_sync(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Allocate device memory to back a halide_buffer_t. */\u000Aextern int halide_device_malloc(void *user_context, struct halide_buffer_t *buf,\u000A                                const struct halide_device_interface_t *device_interface);\u000A\u000A/** Free device memory. */\u000Aextern int halide_device_free(void *user_context, struct halide_buffer_t *buf);\u000A\u000A/** Wrap or detach a native device handle, setting the device field\u000A * and device_interface field as appropriate for the given GPU\u000A * API. The meaning of the opaque handle is specific to the device\u000A * interface, so if you know the device interface in use, call the\u000A * more specific functions in the runtime headers for your specific\u000A * device API instead (e.g. HalideRuntimeCuda.h). */\u000A// @{\u000Aextern int halide_device_wrap_native(void *user_context,\u000A                                     struct halide_buffer_t *buf,\u000A                                     uint64_t handle,\u000A                                     const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_detach_native(void *user_context, struct halide_buffer_t *buf);\u000A// @}\u000A\u000A/** Versions of the above functions that accept legacy buffer_t structs. */\u000A// @{\u000Aextern int halide_copy_to_host_legacy(void *user_context, struct buffer_t *buf);\u000Aextern int halide_copy_to_device_legacy(void *user_context, struct buffer_t *buf,\u000A                                 const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_sync_legacy(void *user_context, struct buffer_t *buf);\u000Aextern int halide_device_malloc_legacy(void *user_context, struct buffer_t *buf,\u000A                                const struct halide_device_interface_t *device_interface);\u000Aextern int halide_device_free_legacy(void *user_context, struct buffer_t *buf);\u000A// @}\u000A\u000A/** Selects which gpu device to use. 0 is usually the display\u000A * device. If never called, Halide uses the environment variable\u000A * HL_GPU_DEVICE. If that variable is unset, Halide uses the last\u000A * device. Set this to -1 to use the last device. */\u000Aextern void halide_set_gpu_device(int n);\u000A\u000A/** Halide calls this to get the desired halide gpu device\u000A * setting. Implement this yourself to use a different gpu device per\u000A * user_context. The default implementation returns the value set by\u000A * halide_set_gpu_device, or the environment variable\u000A * HL_GPU_DEVICE. */\u000Aextern int halide_get_gpu_device(void *user_context);\u000A\u000A/** Set the soft maximum amount of memory, in bytes, that the LRU\u000A *  cache will use to memoize Func results.  This is not a strict\u000A *  maximum in that concurrency and simultaneous use of memoized\u000A *  reults larger than the cache size can both cause it to\u000A *  temporariliy be larger than the size specified here.\u000A */\u000Aextern void halide_memoization_cache_set_size(int64_t size);\u000A\u000A/** Given a cache key for a memoized result, currently constructed\u000A *  from the Func name and top-level Func name plus the arguments of\u000A *  the computation, determine if the result is in the cache and\u000A *  return it if so. (The internals of the cache key should be\u000A *  considered opaque by this function.) If this routine returns true,\u000A *  it is a cache miss. Otherwise, it will return false and the\u000A *  buffers passed in will be filled, via copying, with memoized\u000A *  data. The last argument is a list if halide_buffer_t pointers which\u000A *  represents the outputs of the memoized Func. If the Func does not\u000A *  return a Tuple, there will only be one halide_buffer_t in the list. The\u000A *  tuple_count parameters determines the length of the list.\u000A *\u000A * The return values are:\u000A * -1: Signals an error.\u000A *  0: Success and cache hit.\u000A *  1: Success and cache miss.\u000A */\u000Aextern int halide_memoization_cache_lookup(void *user_context, const uint8_t *cache_key, int32_t size,\u000A                                           struct halide_buffer_t *realized_bounds,\u000A                                           int32_t tuple_count, struct halide_buffer_t **tuple_buffers);\u000A\u000A/** Given a cache key for a memoized result, currently constructed\u000A *  from the Func name and top-level Func name plus the arguments of\u000A *  the computation, store the result in the cache for futre access by\u000A *  halide_memoization_cache_lookup. (The internals of the cache key\u000A *  should be considered opaque by this function.) Data is copied out\u000A *  from the inputs and inputs are unmodified. The last argument is a\u000A *  list if halide_buffer_t pointers which represents the outputs of the\u000A *  memoized Func. If the Func does not return a Tuple, there will\u000A *  only be one halide_buffer_t in the list. The tuple_count parameters\u000A *  determines the length of the list.\u000A *\u000A * If there is a memory allocation failure, the store does not store\u000A * the data into the cache.\u000A */\u000Aextern int halide_memoization_cache_store(void *user_context, const uint8_t *cache_key, int32_t size,\u000A                                          struct halide_buffer_t *realized_bounds,\u000A                                          int32_t tuple_count,\u000A                                          struct halide_buffer_t **tuple_buffers);\u000A\u000A/** If halide_memoization_cache_lookup succeeds,\u000A * halide_memoization_cache_release must be called to signal the\u000A * storage is no longer being used by the caller. It will be passed\u000A * the host pointer of one the buffers returned by\u000A * halide_memoization_cache_lookup. That is\u000A * halide_memoization_cache_release will be called multiple times for\u000A * the case where halide_memoization_cache_lookup is handling multiple\u000A * buffers.  (This corresponds to memoizing a Tuple in Halide.) Note\u000A * that the host pointer must be sufficient to get to all information\u000A * the relase operation needs. The default Halide cache impleemntation\u000A * accomplishes this by storing extra data before the start of the user\u000A * modifiable host storage.\u000A *\u000A * This call is like free and does not have a failure return.\u000A  */\u000Aextern void halide_memoization_cache_release(void *user_context, void *host);\u000A\u000A/** Free all memory and resources associated with the memoization cache.\u000A * Must be called at a time when no other threads are accessing the cache.\u000A */\u000Aextern void halide_memoization_cache_cleanup();\u000A\u000A/** Annotate that a given range of memory has been initialized;\u000A * only used when Target::MSAN is enabled.\u000A *\u000A * The default implementation uses the LLVM-provided AnnotateMemoryIsInitialized() function.\u000A */\u000Aextern int halide_msan_annotate_memory_is_initialized(void *user_context, const void *ptr, uint64_t len);\u000A\u000A/** Mark the data pointed to by the buffer_t as initialized (but *not* the buffer_t itself),\u000A * using halide_msan_annotate_memory_is_initialized() for marking.\u000A *\u000A * The default implementation takes pains to only mark the active memory ranges\u000A * (skipping padding), and sorting into ranges to always mark the smallest number of\u000A * ranges, in monotonically increasing memory order.\u000A *\u000A * Most client code should never need to replace the default implementation.\u000A */\u000Aextern int halide_msan_annotate_buffer_is_initialized(void *user_context, struct halide_buffer_t *buffer);\u000Aextern void halide_msan_annotate_buffer_is_initialized_as_destructor(void *user_context, void *buffer);\u000A\u000A/** The error codes that may be returned by a Halide pipeline. */\u000Aenum halide_error_code_t {\u000A    /** There was no error. This is the value returned by Halide on success. */\u000A    halide_error_code_success = 0,\u000A\u000A    /** An uncategorized error occurred. Refer to the string passed to halide_error. */\u000A    halide_error_code_generic_error = -1,\u000A\u000A    /** A Func was given an explicit bound via Func::bound, but this\u000A     * was not large enough to encompass the region that is used of\u000A     * the Func by the rest of the pipeline. */\u000A    halide_error_code_explicit_bounds_too_small = -2,\u000A\u000A    /** The elem_size field of a halide_buffer_t does not match the size in\u000A     * bytes of the type of that ImageParam. Probable type mismatch. */\u000A    halide_error_code_bad_type = -3,\u000A\u000A    /** A pipeline would access memory outside of the halide_buffer_t passed\u000A     * in. */\u000A    halide_error_code_access_out_of_bounds = -4,\u000A\u000A    /** A halide_buffer_t was given that spans more than 2GB of memory. */\u000A    halide_error_code_buffer_allocation_too_large = -5,\u000A\u000A    /** A halide_buffer_t was given with extents that multiply to a number\u000A     * greater than 2^31-1 */\u000A    halide_error_code_buffer_extents_too_large = -6,\u000A\u000A    /** Applying explicit constraints on the size of an input or\u000A     * output buffer shrank the size of that buffer below what will be\u000A     * accessed by the pipeline. */\u000A    halide_error_code_constraints_make_required_region_smaller = -7,\u000A\u000A    /** A constraint on a size or stride of an input or output buffer\u000A     * was not met by the halide_buffer_t passed in. */\u000A    halide_error_code_constraint_violated = -8,\u000A\u000A    /** A scalar parameter passed in was smaller than its minimum\u000A     * declared value. */\u000A    halide_error_code_param_too_small = -9,\u000A\u000A    /** A scalar parameter passed in was greater than its minimum\u000A     * declared value. */\u000A    halide_error_code_param_too_large = -10,\u000A\u000A    /** A call to halide_malloc returned NULL. */\u000A    halide_error_code_out_of_memory = -11,\u000A\u000A    /** A halide_buffer_t pointer passed in was NULL. */\u000A    halide_error_code_buffer_argument_is_null = -12,\u000A\u000A    /** debug_to_file failed to open or write to the specified\u000A     * file. */\u000A    halide_error_code_debug_to_file_failed = -13,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from device to host. Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_copy_to_host_failed = -14,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from host to device. Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_copy_to_device_failed = -15,\u000A\u000A    /** The Halide runtime encountered an error while trying to\u000A     * allocate memory on device. Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_malloc_failed = -16,\u000A\u000A    /** The Halide runtime encountered an error while trying to\u000A     * synchronize with a device. Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_sync_failed = -17,\u000A\u000A    /** The Halide runtime encountered an error while trying to free a\u000A     * device allocation. Turn on -debug in your target string to see\u000A     * more details. */\u000A    halide_error_code_device_free_failed = -18,\u000A\u000A    /** Buffer has a non-zero device but no device interface, which\u000A     * violates a Halide invariant. */\u000A    halide_error_code_no_device_interface = -19,\u000A\u000A    /** An error occurred when attempting to initialize the Matlab\u000A     * runtime. */\u000A    halide_error_code_matlab_init_failed = -20,\u000A\u000A    /** The type of an mxArray did not match the expected type. */\u000A    halide_error_code_matlab_bad_param_type = -21,\u000A\u000A    /** There is a bug in the Halide compiler. */\u000A    halide_error_code_internal_error = -22,\u000A\u000A    /** The Halide runtime encountered an error while trying to launch\u000A     * a GPU kernel. Turn on -debug in your target string to see more\u000A     * details. */\u000A    halide_error_code_device_run_failed = -23,\u000A\u000A    /** The Halide runtime encountered a host pointer that violated\u000A     * the alignment set for it by way of a call to\u000A     * set_host_alignment */\u000A    halide_error_code_unaligned_host_ptr = -24,\u000A\u000A    /** A fold_storage directive was used on a dimension that is not\u000A     * accessed in a monotonically increasing or decreasing fashion. */\u000A    halide_error_code_bad_fold = -25,\u000A\u000A    /** A fold_storage directive was used with a fold factor that was\u000A     * too small to store all the values of a producer needed by the\u000A     * consumer. */\u000A    halide_error_code_fold_factor_too_small = -26,\u000A\u000A    /** User-specified require() expression was not satisfied. */\u000A    halide_error_code_requirement_failed = -27,\u000A\u000A    /** At least one of the buffer's extents are negative. */\u000A    halide_error_code_buffer_extents_negative = -28,\u000A\u000A    /** A compiled pipeline was passed the old deprecated buffer_t\u000A     * struct, and it could not be upgraded to a halide_buffer_t. */\u000A    halide_error_code_failed_to_upgrade_buffer_t = -29,\u000A\u000A    /** A compiled pipeline was passed the old deprecated buffer_t\u000A     * struct in bounds inference mode, but the returned information\u000A     * can't be expressed in the old buffer_t. */\u000A    halide_error_code_failed_to_downgrade_buffer_t = -30,\u000A\u000A    /** A specialize_fail() schedule branch was selected at runtime. */\u000A    halide_error_code_specialize_fail = -31,\u000A\u000A    /** The Halide runtime encountered an error while trying to wrap a\u000A     * native device handle.  Turn on -debug in your target string to\u000A     * see more details. */\u000A    halide_error_code_device_wrap_native_failed = -32,\u000A\u000A    /** The Halide runtime encountered an error while trying to detach\u000A     * a native device handle.  Turn on -debug in your target string\u000A     * to see more details. */\u000A    halide_error_code_device_detach_native_failed = -33,\u000A\u000A    /** The host field on an input or output was null, the device\u000A     * field was not zero, and the pipeline tries to use the buffer on\u000A     * the host. You may be passing a GPU-only buffer to a pipeline\u000A     * which is scheduled to use it on the CPU. */\u000A    halide_error_code_host_is_null = -34,\u000A\u000A    /** A folded buffer was passed to an extern stage, but the region\u000A     * touched wraps around the fold boundary. */\u000A    halide_error_code_bad_extern_fold = -35,\u000A\u000A    /** Buffer has a non-null device_interface but device is 0, which\u000A     * violates a Halide invariant. */\u000A    halide_error_code_device_interface_no_device= -36,\u000A\u000A    /** Buffer has both host and device dirty bits set, which violates\u000A     * a Halide invariant. */\u000A    halide_error_code_host_and_device_dirty = -37,\u000A\u000A    /** The halide_buffer_t * passed to a halide runtime routine is\u000A     * nullptr and this is not allowed. */\u000A    halide_error_code_buffer_is_null = -38,\u000A\u000A    /** The Halide runtime encountered an error while trying to copy\u000A     * from one buffer to another. Turn on -debug in your target\u000A     * string to see more details. */\u000A    halide_error_code_device_buffer_copy_failed = -39,\u000A\u000A    /** Attempted to make cropped/sliced alias of a buffer with a device\u000A     * field, but the device_interface does not support cropping. */\u000A    halide_error_code_device_crop_unsupported = -40,\u000A\u000A    /** Cropping/slicing a buffer failed for some other reason. Turn on -debug\u000A     * in your target string. */\u000A    halide_error_code_device_crop_failed = -41,\u000A\u000A    /** An operation on a buffer required an allocation on a\u000A     * particular device interface, but a device allocation already\u000A     * existed on a different device interface. Free the old one\u000A     * first. */\u000A    halide_error_code_incompatible_device_interface = -42,\u000A\u000A    /** The dimensions field of a halide_buffer_t does not match the dimensions of that ImageParam. */\u000A    halide_error_code_bad_dimensions = -43,\u000A\u000A    /** An expression that would perform an integer division or modulo\u000A     * by zero was evaluated. */\u000A    halide_error_code_integer_division_by_zero = -44,\u000A\u000A};\u000A\u000A/** Halide calls the functions below on various error conditions. The\u000A * default implementations construct an error message, call\u000A * halide_error, then return the matching error code above. On\u000A * platforms that support weak linking, you can override these to\u000A * catch the errors individually. */\u000A\u000A/** A call into an extern stage for the purposes of bounds inference\u000A * failed. Returns the error code given by the extern stage. */\u000Aextern int halide_error_bounds_inference_call_failed(void *user_context, const char *extern_stage_name, int result);\u000A\u000A/** A call to an extern stage failed. Returned the error code given by\u000A * the extern stage. */\u000Aextern int halide_error_extern_stage_failed(void *user_context, const char *extern_stage_name, int result);\u000A\u000A/** Various other error conditions. See the enum above for a\u000A * description of each. */\u000A// @{\u000Aextern int halide_error_explicit_bounds_too_small(void *user_context, const char *func_name, const char *var_name,\u000A                                                      int min_bound, int max_bound, int min_required, int max_required);\u000Aextern int halide_error_bad_type(void *user_context, const char *func_name,\u000A                                 uint32_t type_given, uint32_t correct_type); // N.B. The last two args are the bit representation of a halide_type_t\u000Aextern int halide_error_bad_dimensions(void *user_context, const char *func_name,\u000A                                       int32_t dimensions_given, int32_t correct_dimensions);\u000Aextern int halide_error_access_out_of_bounds(void *user_context, const char *func_name,\u000A                                             int dimension, int min_touched, int max_touched,\u000A                                             int min_valid, int max_valid);\u000Aextern int halide_error_buffer_allocation_too_large(void *user_context, const char *buffer_name,\u000A                                                    uint64_t allocation_size, uint64_t max_size);\u000Aextern int halide_error_buffer_extents_negative(void *user_context, const char *buffer_name, int dimension, int extent);\u000Aextern int halide_error_buffer_extents_too_large(void *user_context, const char *buffer_name,\u000A                                                 int64_t actual_size, int64_t max_size);\u000Aextern int halide_error_constraints_make_required_region_smaller(void *user_context, const char *buffer_name,\u000A                                                                 int dimension,\u000A                                                                 int constrained_min, int constrained_extent,\u000A                                                                 int required_min, int required_extent);\u000Aextern int halide_error_constraint_violated(void *user_context, const char *var, int val,\u000A                                            const char *constrained_var, int constrained_val);\u000Aextern int halide_error_param_too_small_i64(void *user_context, const char *param_name,\u000A                                            int64_t val, int64_t min_val);\u000Aextern int halide_error_param_too_small_u64(void *user_context, const char *param_name,\u000A                                            uint64_t val, uint64_t min_val);\u000Aextern int halide_error_param_too_small_f64(void *user_context, const char *param_name,\u000A                                            double val, double min_val);\u000Aextern int halide_error_param_too_large_i64(void *user_context, const char *param_name,\u000A                                            int64_t val, int64_t max_val);\u000Aextern int halide_error_param_too_large_u64(void *user_context, const char *param_name,\u000A                                            uint64_t val, uint64_t max_val);\u000Aextern int halide_error_param_too_large_f64(void *user_context, const char *param_name,\u000A                                            double val, double max_val);\u000Aextern int halide_error_out_of_memory(void *user_context);\u000Aextern int halide_error_buffer_argument_is_null(void *user_context, const char *buffer_name);\u000Aextern int halide_error_debug_to_file_failed(void *user_context, const char *func,\u000A                                             const char *filename, int error_code);\u000Aextern int halide_error_unaligned_host_ptr(void *user_context, const char *func_name, int alignment);\u000Aextern int halide_error_host_is_null(void *user_context, const char *func_name);\u000Aextern int halide_error_failed_to_upgrade_buffer_t(void *user_context,\u000A                                                   const char *input_name,\u000A                                                   const char *reason);\u000Aextern int halide_error_failed_to_downgrade_buffer_t(void *user_context,\u000A                                                     const char *input_name,\u000A                                                     const char *reason);\u000Aextern int halide_error_bad_fold(void *user_context, const char *func_name, const char *var_name,\u000A                                 const char *loop_name);\u000Aextern int halide_error_bad_extern_fold(void *user_context, const char *func_name,\u000A                                        int dim, int min, int extent, int valid_min, int fold_factor);\u000A\u000Aextern int halide_error_fold_factor_too_small(void *user_context, const char *func_name, const char *var_name,\u000A                                              int fold_factor, const char *loop_name, int required_extent);\u000Aextern int halide_error_requirement_failed(void *user_context, const char *condition, const char *message);\u000Aextern int halide_error_specialize_fail(void *user_context, const char *message);\u000Aextern int halide_error_no_device_interface(void *user_context);\u000Aextern int halide_error_device_interface_no_device(void *user_context);\u000Aextern int halide_error_host_and_device_dirty(void *user_context);\u000Aextern int halide_error_buffer_is_null(void *user_context, const char *routine);\u000Aextern int halide_error_integer_division_by_zero(void *user_context);\u000A// @}\u000A\u000A/** Optional features a compilation Target can have.\u000A * Be sure to keep this in sync with the Feature enum in Target.h and the implementation of\u000A * get_runtime_compatible_target in Target.cpp if you add a new feature.\u000A */\u000Atypedef enum halide_target_feature_t {\u000A    halide_target_feature_jit = 0,  ///< Generate code that will run immediately inside the calling process.\u000A    halide_target_feature_debug,  ///< Turn on debug info and output for runtime code.\u000A    halide_target_feature_no_asserts,  ///< Disable all runtime checks, for slightly tighter code.\u000A    halide_target_feature_no_bounds_query, ///< Disable the bounds querying functionality.\u000A\u000A    halide_target_feature_sse41,  ///< Use SSE 4.1 and earlier instructions. Only relevant on x86.\u000A    halide_target_feature_avx,  ///< Use AVX 1 instructions. Only relevant on x86.\u000A    halide_target_feature_avx2,  ///< Use AVX 2 instructions. Only relevant on x86.\u000A    halide_target_feature_fma,  ///< Enable x86 FMA instruction\u000A    halide_target_feature_fma4,  ///< Enable x86 (AMD) FMA4 instruction set\u000A    halide_target_feature_f16c,  ///< Enable x86 16-bit float support\u000A\u000A    halide_target_feature_armv7s,  ///< Generate code for ARMv7s. Only relevant for 32-bit ARM.\u000A    halide_target_feature_no_neon,  ///< Avoid using NEON instructions. Only relevant for 32-bit ARM.\u000A\u000A    halide_target_feature_vsx,  ///< Use VSX instructions. Only relevant on POWERPC.\u000A    halide_target_feature_power_arch_2_07,  ///< Use POWER ISA 2.07 new instructions. Only relevant on POWERPC.\u000A\u000A    halide_target_feature_cuda,  ///< Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi)\u000A    halide_target_feature_cuda_capability30,  ///< Enable CUDA compute capability 3.0 (Kepler)\u000A    halide_target_feature_cuda_capability32,  ///< Enable CUDA compute capability 3.2 (Tegra K1)\u000A    halide_target_feature_cuda_capability35,  ///< Enable CUDA compute capability 3.5 (Kepler)\u000A    halide_target_feature_cuda_capability50,  ///< Enable CUDA compute capability 5.0 (Maxwell)\u000A\u000A    halide_target_feature_opencl,  ///< Enable the OpenCL runtime.\u000A    halide_target_size_opencl, ///<Temporary testing target placeholder marked by size>\u000A    halide_target_feature_cl_doubles,  ///< Enable double support on OpenCL targets\u000A    halide_target_feature_cl_atomic64, ///< Enable 64-bit atomics operations on OpenCL targets\u000A\u000A    halide_target_feature_opengl,  ///< Enable the OpenGL runtime.\u000A    halide_target_feature_openglcompute, ///< Enable OpenGL Compute runtime.\u000A\u000A    halide_target_feature_user_context,  ///< Generated code takes a user_context pointer as first argument\u000A\u000A    halide_target_feature_matlab,  ///< Generate a mexFunction compatible with Matlab mex libraries. See tools/mex_halide.m.\u000A\u000A    halide_target_feature_profile, ///< Launch a sampling profiler alongside the Halide pipeline that monitors and reports the runtime used by each Func\u000A    halide_target_feature_no_runtime, ///< Do not include a copy of the Halide runtime in any generated object file or assembly\u000A\u000A    halide_target_feature_metal, ///< Enable the (Apple) Metal runtime.\u000A    halide_target_feature_mingw, ///< For Windows compile to MinGW toolset rather then Visual Studio\u000A\u000A    halide_target_feature_c_plus_plus_mangling, ///< Generate C++ mangled names for result function, et al\u000A\u000A    halide_target_feature_large_buffers, ///< Enable 64-bit buffer indexing to support buffers > 2GB. Ignored if bits != 64.\u000A\u000A    halide_target_feature_hvx_64, ///< Enable HVX 64 byte mode.\u000A    halide_target_feature_hvx_128, ///< Enable HVX 128 byte mode.\u000A    halide_target_feature_hvx_v62, ///< Enable Hexagon v62 architecture.\u000A    halide_target_feature_fuzz_float_stores, ///< On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors.\u000A    halide_target_feature_soft_float_abi, ///< Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats.\u000A    halide_target_feature_msan, ///< Enable hooks for MSAN support.\u000A    halide_target_feature_avx512, ///< Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See https://en.wikipedia.org/wiki/AVX-512 for a description of each AVX subset.\u000A    halide_target_feature_avx512_knl, ///< Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER.\u000A    halide_target_feature_avx512_skylake, ///< Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors.\u000A    halide_target_feature_avx512_cannonlake, ///< Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI.\u000A    halide_target_feature_hvx_use_shared_object, ///< Deprecated\u000A    halide_target_feature_trace_loads, ///< Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func.\u000A    halide_target_feature_trace_stores, ///< Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func.\u000A    halide_target_feature_trace_realizations, ///< Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func.\u000A    halide_target_feature_trace_pipeline, ///< Trace the pipeline.\u000A    halide_target_feature_cuda_capability61,  ///< Enable CUDA compute capability 6.1 (Pascal)\u000A    halide_target_feature_hvx_v65, ///< Enable Hexagon v65 architecture.\u000A    halide_target_feature_hvx_v66, ///< Enable Hexagon v66 architecture.\u000A    halide_target_feature_cl_half,  ///< Enable half support on OpenCL targets\u000A    halide_target_feature_strict_float, ///< Turn off all non-IEEE floating-point optimization. Currently applies only to LLVM targets.\u000A    halide_target_feature_legacy_buffer_wrappers,  ///< Emit legacy wrapper code for buffer_t (vs halide_buffer_t) when AOT-compiled.\u000A    halide_target_feature_tsan, ///< Enable hooks for TSAN support.\u000A    halide_target_feature_asan, ///< Enable hooks for ASAN support.\u000A    halide_target_feature_d3d12compute, ///< Enable Direct3D 12 Compute runtime.\u000A    halide_target_feature_check_unsafe_promises, ///< Insert assertions for promises.\u000A    halide_target_feature_hexagon_dma, ///< Enable Hexagon DMA buffers.\u000A    halide_target_feature_embed_bitcode,  ///< Emulate clang -fembed-bitcode flag.\u000A    halide_target_feature_enable_llvm_loop_opt,  ///< Enable loop vectorization + unrolling in LLVM. Overrides halide_target_feature_disable_llvm_loop_opt. (Ignored for non-LLVM targets.)\u000A    halide_target_feature_disable_llvm_loop_opt,  ///< Disable loop vectorization + unrolling in LLVM. (Ignored for non-LLVM targets.)\u000A    halide_target_feature_wasm_simd128,  ///< Enable +simd128 instructions for WebAssembly codegen.\u000A    halide_target_feature_wasm_signext,  ///< Enable +sign-ext instructions for WebAssembly codegen.\u000A    halide_target_feature_sve, ///< Enable ARM Scalable Vector Extensions\u000A    halide_target_feature_sve2, ///< Enable ARM Scalable Vector Extensions v2\u000A    halide_target_feature_egl,            ///< Force use of EGL support.\u000A    halide_target_feature_intel_fpga, ///< Enable Intel FPGAs\u000A    halide_target_feature_one_api, ///< Enable Intel OneAPI dpcpp program generation\u000A    halide_target_feature_intel_gpu, ///< Enable Intel Graphics\u000A    halide_target_feature_enable_synthesis, ///< Enable synthesizing binaries. Currently used only for Intel FPGAs.\u000A    halide_target_feature_cm, ///< Enable C for metal\u000A    halide_target_feature_end ///< A sentinel. Every target is considered to have this feature, and setting this feature does nothing.\u000A} halide_target_feature_t;\u000A\u000A/** This function is called internally by Halide in some situations to determine\u000A * if the current execution environment can support the given set of\u000A * halide_target_feature_t flags. The implementation must do the following:\u000A *\u000A * -- If there are flags set in features that the function knows *cannot* be supported, return 0.\u000A * -- Otherwise, return 1.\u000A * -- Note that any flags set in features that the function doesn't know how to test should be ignored;\u000A * this implies that a return value of 1 means \"not known to be bad\" rather than \"known to be good\".\u000A *\u000A * In other words: a return value of 0 means \"It is not safe to use code compiled with these features\",\u000A * while a return value of 1 means \"It is not obviously unsafe to use code compiled with these features\".\u000A *\u000A * The default implementation simply calls halide_default_can_use_target_features.\u000A *\u000A * Note that `features` points to an array of `count` uint64_t; this array must contain enough\u000A * bits to represent all the currently known features. Any excess bits must be set to zero.\u000A */\u000A// @{\u000Aextern int halide_can_use_target_features(int count, const uint64_t *features);\u000Atypedef int (*halide_can_use_target_features_t)(int count, const uint64_t *features);\u000Aextern halide_can_use_target_features_t halide_set_custom_can_use_target_features(halide_can_use_target_features_t);\u000A// @}\u000A\u000A/**\u000A * This is the default implementation of halide_can_use_target_features; it is provided\u000A * for convenience of user code that may wish to extend halide_can_use_target_features\u000A * but continue providing existing support, e.g.\u000A *\u000A *     int halide_can_use_target_features(int count, const uint64_t *features) {\u000A *          if (features[halide_target_somefeature >> 6] & (1LL << (halide_target_somefeature & 63))) {\u000A *              if (!can_use_somefeature()) {\u000A *                  return 0;\u000A *              }\u000A *          }\u000A *          return halide_default_can_use_target_features(count, features);\u000A *     }\u000A */\u000Aextern int halide_default_can_use_target_features(int count, const uint64_t *features);\u000A\u000A\u000Atypedef struct halide_dimension_t {\u000A    int32_t min, extent, stride;\u000A\u000A    // Per-dimension flags. None are defined yet (This is reserved for future use).\u000A    uint32_t flags;\u000A\u000A#ifdef __cplusplus\u000A    HALIDE_ALWAYS_INLINE halide_dimension_t() : min(0), extent(0), stride(0), flags(0) {}\u000A    HALIDE_ALWAYS_INLINE halide_dimension_t(int32_t m, int32_t e, int32_t s, uint32_t f = 0) :\u000A        min(m), extent(e), stride(s), flags(f) {}\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator==(const halide_dimension_t &other) const {\u000A        return (min == other.min) &&\u000A            (extent == other.extent) &&\u000A            (stride == other.stride) &&\u000A            (flags == other.flags);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool operator!=(const halide_dimension_t &other) const {\u000A        return !(*this == other);\u000A    }\u000A#endif\u000A} halide_dimension_t;\u000A\u000A#ifdef __cplusplus\u000A} // extern \"C\"\u000A#endif\u000A\u000Atypedef enum {halide_buffer_flag_host_dirty = 1,\u000A              halide_buffer_flag_device_dirty = 2} halide_buffer_flags;\u000A\u000A/**\u000A * The raw representation of an image passed around by generated\u000A * Halide code. It includes some stuff to track whether the image is\u000A * not actually in main memory, but instead on a device (like a\u000A * GPU). For a more convenient C++ wrapper, use Halide::Buffer<T>. */\u000Atypedef struct halide_buffer_t {\u000A    /** A device-handle for e.g. GPU memory used to back this buffer. */\u000A    uint64_t device;\u000A\u000A    /** The interface used to interpret the above handle. */\u000A    const struct halide_device_interface_t *device_interface;\u000A\u000A    /** A pointer to the start of the data in main memory. In terms of\u000A     * the Halide coordinate system, this is the address of the min\u000A     * coordinates (defined below). */\u000A    uint8_t* host;\u000A\u000A    /** flags with various meanings. */\u000A    uint64_t flags;\u000A\u000A    /** The type of each buffer element. */\u000A    struct halide_type_t type;\u000A\u000A    /** The dimensionality of the buffer. */\u000A    int32_t dimensions;\u000A\u000A    /** The shape of the buffer. Halide does not own this array - you\u000A     * must manage the memory for it yourself. */\u000A    halide_dimension_t *dim;\u000A\u000A    /** Pads the buffer up to a multiple of 8 bytes */\u000A    void *padding;\u000A\u000A#ifdef __cplusplus\u000A    /** Convenience methods for accessing the flags */\u000A    // @{\u000A    HALIDE_ALWAYS_INLINE bool get_flag(halide_buffer_flags flag) const {\u000A        return (flags & flag) != 0;\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_flag(halide_buffer_flags flag, bool value) {\u000A        if (value) {\u000A            flags |= flag;\u000A        } else {\u000A            flags &= ~flag;\u000A        }\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool host_dirty() const {\u000A        return get_flag(halide_buffer_flag_host_dirty);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE bool device_dirty() const {\u000A        return get_flag(halide_buffer_flag_device_dirty);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_host_dirty(bool v = true) {\u000A        set_flag(halide_buffer_flag_host_dirty, v);\u000A    }\u000A\u000A    HALIDE_ALWAYS_INLINE void set_device_dirty(bool v = true) {\u000A        set_flag(halide_buffer_flag_device_dirty, v);\u000A    }\u000A    // @}\u000A\u000A    /** The total number of elements this buffer represents. Equal to\u000A     * the product of the extents */\u000A    HALIDE_ALWAYS_INLINE size_t number_of_elements() const {\u000A        size_t s = 1;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            s *= dim[i].extent;\u000A        }\u000A        return s;\u000A    }\u000A\u000A    /** A pointer to the element with the lowest address. If all\u000A     * strides are positive, equal to the host pointer. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *begin() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            if (dim[i].stride < 0) {\u000A                index += dim[i].stride * (dim[i].extent - 1);\u000A            }\u000A        }\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** A pointer to one beyond the element with the highest address. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *end() const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            if (dim[i].stride > 0) {\u000A                index += dim[i].stride * (dim[i].extent - 1);\u000A            }\u000A        }\u000A        index += 1;\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** The total number of bytes spanned by the data in memory. */\u000A    HALIDE_ALWAYS_INLINE size_t size_in_bytes() const {\u000A        return (size_t)(end() - begin());\u000A    }\u000A\u000A    /** A pointer to the element at the given location. */\u000A    HALIDE_ALWAYS_INLINE uint8_t *address_of(const int *pos) const {\u000A        ptrdiff_t index = 0;\u000A        for (int i = 0; i < dimensions; i++) {\u000A            index += dim[i].stride * (pos[i] - dim[i].min);\u000A        }\u000A        return host + index * type.bytes();\u000A    }\u000A\u000A    /** Attempt to call device_sync for the buffer. If the buffer\u000A     * has no device_interface (or no device_sync), this is a quiet no-op.\u000A     * Calling this explicitly should rarely be necessary, except for profiling. */\u000A    HALIDE_ALWAYS_INLINE int device_sync(void *ctx = NULL) {\u000A        if (device_interface && device_interface->device_sync) {\u000A            return device_interface->device_sync(ctx, this);\u000A        }\u000A        return 0;\u000A    }\u000A\u000A    /** Check if an input buffer passed extern stage is a querying\u000A     * bounds. Compared to doing the host pointer check directly,\u000A     * this both adds clarity to code and will facilitate moving to\u000A     * another representation for bounds query arguments. */\u000A    HALIDE_ALWAYS_INLINE bool is_bounds_query() const {\u000A        return host == NULL && device == 0;\u000A    }\u000A\u000A#endif\u000A} halide_buffer_t;\u000A\u000A#ifdef __cplusplus\u000Aextern \"C\" {\u000A#endif\u000A\u000A#ifndef HALIDE_ATTRIBUTE_DEPRECATED\u000A#ifdef HALIDE_ALLOW_DEPRECATED\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x)\u000A#else\u000A#ifdef _MSC_VER\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x) __declspec(deprecated(x))\u000A#else\u000A#define HALIDE_ATTRIBUTE_DEPRECATED(x) __attribute__((deprecated(x)))\u000A#endif\u000A#endif\u000A#endif\u000A\u000A/** The old buffer_t, included for compatibility with old code. Don't\u000A * use it. */\u000A#ifndef BUFFER_T_DEFINED\u000A#define BUFFER_T_DEFINED\u000Atypedef struct buffer_t {\u000A    uint64_t dev;\u000A    uint8_t* host;\u000A    int32_t extent[4];\u000A    int32_t stride[4];\u000A    int32_t min[4];\u000A    int32_t elem_size;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) bool host_dirty;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) bool dev_dirty;\u000A    HALIDE_ATTRIBUTE_ALIGN(1) uint8_t _padding[10 - sizeof(void *)];\u000A} buffer_t;\u000A#endif // BUFFER_T_DEFINED\u000A\u000A/** Copies host pointer, mins, extents, strides, and device state from\u000A * an old-style buffer_t into a new-style halide_buffer_t. If bounds_query_only is nonzero,\u000A * the copy is only done if the old_buf has null host and dev (ie, a bounds query is being\u000A * performed); otherwise new_buf is left untouched. (This is used for input buffers to avoid\u000A * benign data races.) The dimensions and type fields of the new buffer_t should already be\u000A * set. Returns an error code if the upgrade could not be performed. */\u000Aextern int halide_upgrade_buffer_t(void *user_context, const char *name,\u000A                                   const buffer_t *old_buf, halide_buffer_t *new_buf,\u000A                                   int bounds_query_only);\u000A\u000A/** Copies the host pointer, mins, extents, strides, and device state\u000A * from a halide_buffer_t to a buffer_t. Also sets elem_size. Useful\u000A * for backporting the results of bounds inference. */\u000Aextern int halide_downgrade_buffer_t(void *user_context, const char *name,\u000A                                     const halide_buffer_t *new_buf, buffer_t *old_buf);\u000A\u000A/** Copies the dirty flags and device allocation state from a new\u000A * buffer_t back to a legacy buffer_t. */\u000Aextern int halide_downgrade_buffer_t_device_fields(void *user_context, const char *name,\u000A                                                   const halide_buffer_t *new_buf, buffer_t *old_buf);\u000A\u000A/** halide_scalar_value_t is a simple union able to represent all the well-known\u000A * scalar values in a filter argument. Note that it isn't tagged with a type;\u000A * you must ensure you know the proper type before accessing. Most user\u000A * code will never need to create instances of this struct; its primary use\u000A * is to hold def/min/max values in a halide_filter_argument_t. (Note that\u000A * this is conceptually just a union; it's wrapped in a struct to ensure\u000A * that it doesn't get anonymized by LLVM.)\u000A */\u000Astruct halide_scalar_value_t {\u000A    union {\u000A        bool b;\u000A        int8_t i8;\u000A        int16_t i16;\u000A        int32_t i32;\u000A        int64_t i64;\u000A        uint8_t u8;\u000A        uint16_t u16;\u000A        uint32_t u32;\u000A        uint64_t u64;\u000A        float f32;\u000A        double f64;\u000A        void *handle;\u000A    } u;\u000A    #ifdef __cplusplus\u000A    HALIDE_ALWAYS_INLINE halide_scalar_value_t() {u.u64 = 0;}\u000A    #endif\u000A};\u000A\u000Aenum halide_argument_kind_t {\u000A    halide_argument_kind_input_scalar = 0,\u000A    halide_argument_kind_input_buffer = 1,\u000A    halide_argument_kind_output_buffer = 2\u000A};\u000A\u000A/*\u000A    These structs must be robust across different compilers and settings; when\u000A    modifying them, strive for the following rules:\u000A\u000A    1) All fields are explicitly sized. I.e. must use int32_t and not \"int\"\u000A    2) All fields must land on an alignment boundary that is the same as their size\u000A    3) Explicit padding is added to make that so\u000A    4) The sizeof the struct is padded out to a multiple of the largest natural size thing in the struct\u000A    5) don't forget that 32 and 64 bit pointers are different sizes\u000A*/\u000A\u000A/**\u000A * Obsolete version of halide_filter_argument_t; only present in\u000A * code that wrote halide_filter_metadata_t version 0.\u000A */\u000Astruct halide_filter_argument_t_v0 {\u000A    const char *name;\u000A    int32_t kind;\u000A    int32_t dimensions;\u000A    struct halide_type_t type;\u000A    const struct halide_scalar_value_t *def, *min, *max;\u000A};\u000A\u000A/**\u000A * halide_filter_argument_t is essentially a plain-C-struct equivalent to\u000A * Halide::Argument; most user code will never need to create one.\u000A */\u000Astruct halide_filter_argument_t {\u000A    const char *name;       // name of the argument; will never be null or empty.\u000A    int32_t kind;           // actually halide_argument_kind_t\u000A    int32_t dimensions;     // always zero for scalar arguments\u000A    struct halide_type_t type;\u000A    // These pointers should always be null for buffer arguments,\u000A    // and *may* be null for scalar arguments. (A null value means\u000A    // there is no def/min/max/estimate specified for this argument.)\u000A    const struct halide_scalar_value_t *scalar_def, *scalar_min, *scalar_max, *scalar_estimate;\u000A    // This pointer should always be null for scalar arguments,\u000A    // and *may* be null for buffer arguments. If not null, it should always\u000A    // point to an array of dimensions*2 pointers, which will be the (min, extent)\u000A    // estimates for each dimension of the buffer. (Note that any of the pointers\u000A    // may be null as well.)\u000A    int64_t const* const* buffer_estimates;\u000A};\u000A\u000Astruct halide_filter_metadata_t {\u000A#ifdef __cplusplus\u000A    static const int32_t VERSION = 1;\u000A#endif\u000A\u000A    /** version of this metadata; currently always 1. */\u000A    int32_t version;\u000A\u000A    /** The number of entries in the arguments field. This is always >= 1. */\u000A    int32_t num_arguments;\u000A\u000A    /** An array of the filters input and output arguments; this will never be\u000A     * null. The order of arguments is not guaranteed (input and output arguments\u000A     * may come in any order); however, it is guaranteed that all arguments\u000A     * will have a unique name within a given filter. */\u000A    const struct halide_filter_argument_t* arguments;\u000A\u000A    /** The Target for which the filter was compiled. This is always\u000A     * a canonical Target string (ie a product of Target::to_string). */\u000A    const char* target;\u000A\u000A    /** The function name of the filter. */\u000A    const char* name;\u000A};\u000A\u000A/** halide_register_argv_and_metadata() is a **user-defined** function that\u000A * must be provided in order to use the registration.cc files produced\u000A * by Generators when the 'registration' output is requested. Each registration.cc\u000A * file provides a static initializer that calls this function with the given\u000A * filter's argv-call variant, its metadata, and (optionally) and additional\u000A * textual data that the build system chooses to tack on for its own purposes.\u000A * Note that this will be called at static-initializer time (i.e., before\u000A * main() is called), and in an unpredictable order. Note that extra_key_value_pairs\u000A * may be nullptr; if it's not null, it's expected to be a null-terminated list\u000A * of strings, with an even number of entries. */\u000Avoid halide_register_argv_and_metadata(\u000A    int (*filter_argv_call)(void **),\u000A    const struct halide_filter_metadata_t *filter_metadata,\u000A    const char * const *extra_key_value_pairs\u000A);\u000A\u000A/** The functions below here are relevant for pipelines compiled with\u000A * the -profile target flag, which runs a sampling profiler thread\u000A * alongside the pipeline. */\u000A\u000A/** Per-Func state tracked by the sampling profiler. */\u000Astruct halide_profiler_func_stats {\u000A    /** Total time taken evaluating this Func (in nanoseconds). */\u000A    uint64_t time;\u000A\u000A    /** The current memory allocation of this Func. */\u000A    uint64_t memory_current;\u000A\u000A    /** The peak memory allocation of this Func. */\u000A    uint64_t memory_peak;\u000A\u000A    /** The total memory allocation of this Func. */\u000A    uint64_t memory_total;\u000A\u000A    /** The peak stack allocation of this Func's threads. */\u000A    uint64_t stack_peak;\u000A\u000A    /** The average number of thread pool worker threads active while computing this Func. */\u000A    uint64_t active_threads_numerator, active_threads_denominator;\u000A\u000A    /** The name of this Func. A global constant string. */\u000A    const char *name;\u000A\u000A    /** The total number of memory allocation of this Func. */\u000A    int num_allocs;\u000A};\u000A\u000A/** Per-pipeline state tracked by the sampling profiler. These exist\u000A * in a linked list. */\u000Astruct halide_profiler_pipeline_stats {\u000A    /** Total time spent inside this pipeline (in nanoseconds) */\u000A    uint64_t time;\u000A\u000A    /** The current memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_current;\u000A\u000A    /** The peak memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_peak;\u000A\u000A    /** The total memory allocation of funcs in this pipeline. */\u000A    uint64_t memory_total;\u000A\u000A    /** The average number of thread pool worker threads doing useful\u000A     * work while computing this pipeline. */\u000A    uint64_t active_threads_numerator, active_threads_denominator;\u000A\u000A    /** The name of this pipeline. A global constant string. */\u000A    const char *name;\u000A\u000A    /** An array containing states for each Func in this pipeline. */\u000A    struct halide_profiler_func_stats *funcs;\u000A\u000A    /** The next pipeline_stats pointer. It's a void * because types\u000A     * in the Halide runtime may not currently be recursive. */\u000A    void *next;\u000A\u000A    /** The number of funcs in this pipeline. */\u000A    int num_funcs;\u000A\u000A    /** An internal base id used to identify the funcs in this pipeline. */\u000A    int first_func_id;\u000A\u000A    /** The number of times this pipeline has been run. */\u000A    int runs;\u000A\u000A    /** The total number of samples taken inside of this pipeline. */\u000A    int samples;\u000A\u000A    /** The total number of memory allocation of funcs in this pipeline. */\u000A    int num_allocs;\u000A};\u000A\u000A/** The global state of the profiler. */\u000A\u000Astruct halide_profiler_state {\u000A    /** Guards access to the fields below. If not locked, the sampling\u000A     * profiler thread is free to modify things below (including\u000A     * reordering the linked list of pipeline stats). */\u000A    struct halide_mutex lock;\u000A\u000A    /** The amount of time the profiler thread sleeps between samples\u000A     * in milliseconds. Defaults to 1 */\u000A    int sleep_time;\u000A\u000A    /** An internal id used for bookkeeping. */\u000A    int first_free_id;\u000A\u000A    /** The id of the current running Func. Set by the pipeline, read\u000A     * periodically by the profiler thread. */\u000A    int current_func;\u000A\u000A    /** The number of threads currently doing work. */\u000A    int active_threads;\u000A\u000A    /** A linked list of stats gathered for each pipeline. */\u000A    struct halide_profiler_pipeline_stats *pipelines;\u000A\u000A    /** Retrieve remote profiler state. Used so that the sampling\u000A     * profiler can follow along with execution that occurs elsewhere,\u000A     * e.g. on a DSP. If null, it reads from the int above instead. */\u000A    void (*get_remote_profiler_state)(int *func, int *active_workers);\u000A\u000A    /** Sampling thread reference to be joined at shutdown. */\u000A    struct halide_thread *sampling_thread;\u000A};\u000A\u000A/** Profiler func ids with special meanings. */\u000Aenum {\u000A    /// current_func takes on this value when not inside Halide code\u000A    halide_profiler_outside_of_halide = -1,\u000A    /// Set current_func to this value to tell the profiling thread to\u000A    /// halt. It will start up again next time you run a pipeline with\u000A    /// profiling enabled.\u000A    halide_profiler_please_stop = -2\u000A};\u000A\u000A/** Get a pointer to the global profiler state for programmatic\u000A * inspection. Lock it before using to pause the profiler. */\u000Aextern struct halide_profiler_state *halide_profiler_get_state();\u000A\u000A/** Get a pointer to the pipeline state associated with pipeline_name.\u000A * This function grabs the global profiler state's lock on entry. */\u000Aextern struct halide_profiler_pipeline_stats *halide_profiler_get_pipeline_state(const char *pipeline_name);\u000A\u000A/** Reset profiler state cheaply. May leave threads running or some\u000A * memory allocated but all accumluated statistics are reset.\u000A * WARNING: Do NOT call this method while any halide pipeline is\u000A * running; halide_profiler_memory_allocate/free and\u000A * halide_profiler_stack_peak_update update the profiler pipeline's\u000A * state without grabbing the global profiler state's lock. */\u000Aextern void halide_profiler_reset();\u000A\u000A/** Reset all profiler state.\u000A * WARNING: Do NOT call this method while any halide pipeline is\u000A * running; halide_profiler_memory_allocate/free and\u000A * halide_profiler_stack_peak_update update the profiler pipeline's\u000A * state without grabbing the global profiler state's lock. */\u000Avoid halide_profiler_shutdown();\u000A\u000A/** Print out timing statistics for everything run since the last\u000A * reset. Also happens at process exit. */\u000Aextern void halide_profiler_report(void *user_context);\u000A\u000A/// \\name \"Float16\" functions\u000A/// These functions operate of bits (``uint16_t``) representing a half\u000A/// precision floating point number (IEEE-754 2008 binary16).\u000A//{@\u000A\u000A/** Read bits representing a half precision floating point number and return\u000A *  the float that represents the same value */\u000Aextern float halide_float16_bits_to_float(uint16_t);\u000A\u000A/** Read bits representing a half precision floating point number and return\u000A *  the double that represents the same value */\u000Aextern double halide_float16_bits_to_double(uint16_t);\u000A\u000A// TODO: Conversion functions to half\u000A\u000A//@}\u000A\u000A// Allocating and freeing device memory is often very slow. The\u000A// methods below give Halide's runtime permission to hold onto device\u000A// memory to service future requests instead of returning it to the\u000A// underlying device API. The API does not manage an allocation pool,\u000A// all it does is provide access to a shared counter that acts as a\u000A// limit on the unused memory not yet returned to the underlying\u000A// device API. It makes callbacks to participants when memory needs to\u000A// be released because the limit is about to be exceeded (either\u000A// because the limit has been reduced, or because the memory owned by\u000A// some participant becomes unused).\u000A\u000A/** Tell Halide whether or not it is permitted to hold onto device\u000A * allocations to service future requests instead of returning them\u000A * eagerly to the underlying device API. Many device allocators are\u000A * quite slow, so it can be beneficial to set this to true. The\u000A * default value for now is false.\u000A *\u000A * Note that if enabled, the eviction policy is very simplistic. The\u000A * 32 most-recently used allocations are preserved, regardless of\u000A * their size. Additionally, if a call to cuMalloc results in an\u000A * out-of-memory error, the entire cache is flushed and the allocation\u000A * is retried. See https://github.com/halide/Halide/issues/4093\u000A *\u000A * If set to false, releases all unused device allocations back to the\u000A * underlying device APIs. For finer-grained control, see specific\u000A * methods in each device api runtime. */\u000Aextern int halide_reuse_device_allocations(void *user_context, bool);\u000A\u000A/** Determines whether on device_free the memory is returned\u000A * immediately to the device API, or placed on a free list for future\u000A * use. Override and switch based on the user_context for\u000A * finer-grained control. By default just returns the value most\u000A * recently set by the method above. */\u000Aextern bool halide_can_reuse_device_allocations(void *user_context);\u000A\u000Astruct halide_device_allocation_pool {\u000A    int (*release_unused)(void *user_context);\u000A    struct halide_device_allocation_pool *next;\u000A};\u000A\u000A/** Register a callback to be informed when\u000A * halide_reuse_device_allocations(false) is called, and all unused\u000A * device allocations must be released. The object passed should have\u000A * global lifetime, and its next field will be clobbered. */\u000Aextern void halide_register_device_allocation_pool(struct halide_device_allocation_pool *);\u000A\u000A#ifdef __cplusplus\u000A} // End extern \"C\"\u000A#endif\u000A\u000A#ifdef __cplusplus\u000A\u000Anamespace {\u000Atemplate<typename T> struct check_is_pointer;\u000Atemplate<typename T> struct check_is_pointer<T *> {};\u000A}\u000A\u000A/** Construct the halide equivalent of a C type */\u000Atemplate<typename T>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of() {\u000A    // Create a compile-time error if T is not a pointer (without\u000A    // using any includes - this code goes into the runtime).\u000A    check_is_pointer<T> check;\u000A    (void)check;\u000A    return halide_type_t(halide_type_handle, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<float>() {\u000A    return halide_type_t(halide_type_float, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<double>() {\u000A    return halide_type_t(halide_type_float, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<bool>() {\u000A    return halide_type_t(halide_type_uint, 1);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint8_t>() {\u000A    return halide_type_t(halide_type_uint, 8);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint16_t>() {\u000A    return halide_type_t(halide_type_uint, 16);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint32_t>() {\u000A    return halide_type_t(halide_type_uint, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<uint64_t>() {\u000A    return halide_type_t(halide_type_uint, 64);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int8_t>() {\u000A    return halide_type_t(halide_type_int, 8);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int16_t>() {\u000A    return halide_type_t(halide_type_int, 16);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int32_t>() {\u000A    return halide_type_t(halide_type_int, 32);\u000A}\u000A\u000Atemplate<>\u000AHALIDE_ALWAYS_INLINE halide_type_t halide_type_of<int64_t>() {\u000A    return halide_type_t(halide_type_int, 64);\u000A}\u000A\u000A#endif\u000A\u000A#endif // HALIDE_HALIDERUNTIME_H\u000A\u000A#ifdef COMPILING_HALIDE_RUNTIME\u000A#include \"HalideRuntime.h\"\u000A#define HALIDE_BUFFER_HELPER_ATTRS __attribute__((always_inline, weak))\u000A#else\u000A#define HALIDE_BUFFER_HELPER_ATTRS inline\u000A#endif\u000A\u000A// Structs are annoying to deal with from within Halide Stmts. These\u000A// utility functions are for dealing with buffer_t in that\u000A// context. They are not intended for use outside of Halide code, and\u000A// not exposed in HalideRuntime.h. The symbols are private to the\u000A// module and should be inlined and then stripped. This blob of code\u000A// also gets copy-pasted into C outputs.\u000A\u000Aextern \"C\" {\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_get_dimensions(const halide_buffer_t *buf) {\u000A    return buf->dimensions;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Auint8_t *_halide_buffer_get_host(const halide_buffer_t *buf) {\u000A    return buf->host;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Auint64_t _halide_buffer_get_device(const halide_buffer_t *buf) {\u000A    return buf->device;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aconst struct halide_device_interface_t *_halide_buffer_get_device_interface(const halide_buffer_t *buf) {\u000A    return buf->device_interface;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_get_min(const halide_buffer_t *buf, int d) {\u000A    return buf->dim[d].min;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_get_max(const halide_buffer_t *buf, int d) {\u000A    return buf->dim[d].min + buf->dim[d].extent - 1;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_get_extent(const halide_buffer_t *buf, int d) {\u000A    return buf->dim[d].extent;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_get_stride(const halide_buffer_t *buf, int d) {\u000A    return buf->dim[d].stride;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_set_host_dirty(halide_buffer_t *buf, bool val) {\u000A    buf->set_host_dirty(val);\u000A    return 0;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_set_device_dirty(halide_buffer_t *buf, bool val) {\u000A    buf->set_device_dirty(val);\u000A    return 0;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Abool _halide_buffer_get_host_dirty(const halide_buffer_t *buf) {\u000A    return buf->host_dirty();\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Abool _halide_buffer_get_device_dirty(const halide_buffer_t *buf) {\u000A    return buf->device_dirty();\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Ahalide_dimension_t *_halide_buffer_get_shape(halide_buffer_t *buf) {\u000A    return buf->dim;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Abool _halide_buffer_is_bounds_query(const halide_buffer_t *buf) {\u000A    return buf->host == NULL && buf->device == 0;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Auint32_t _halide_buffer_get_type(const halide_buffer_t *buf) {\u000A    return buf->type.as_u32();\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Ahalide_buffer_t *_halide_buffer_init(halide_buffer_t *dst,\u000A                                     halide_dimension_t *dst_shape,\u000A                                     void *host,\u000A                                     uint64_t device,\u000A                                     const halide_device_interface_t *device_interface,\u000A                                     int type_code, int type_bits,\u000A                                     int dimensions,\u000A                                     halide_dimension_t *shape,\u000A                                     uint64_t flags) {\u000A    dst->host = (uint8_t *)host;\u000A    dst->device = device;\u000A    dst->device_interface = device_interface;\u000A    dst->type.code = (halide_type_code_t)type_code;\u000A    dst->type.bits = (uint8_t)type_bits;\u000A    dst->type.lanes = 1;\u000A    dst->dimensions = dimensions;\u000A    dst->dim = dst_shape;\u000A    if (shape != dst->dim) {\u000A        for (int i = 0; i < dimensions; i++) {\u000A            dst->dim[i] = shape[i];\u000A        }\u000A    }\u000A    dst->flags = flags;\u000A    return dst;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Ahalide_buffer_t *_halide_buffer_init_from_buffer(halide_buffer_t *dst,\u000A                                                 halide_dimension_t *dst_shape,\u000A                                                 const halide_buffer_t *src) {\u000A    dst->host = src->host;\u000A    dst->device = src->device;\u000A    dst->device_interface = src->device_interface;\u000A    dst->type = src->type;\u000A    dst->dimensions = src->dimensions;\u000A    dst->dim = dst_shape;\u000A    dst->flags = src->flags;\u000A    for (int i = 0; i < dst->dimensions; i++) {\u000A        dst->dim[i] = src->dim[i];\u000A    }\u000A    return dst;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Ahalide_buffer_t *_halide_buffer_crop(void *user_context,\u000A                                     halide_buffer_t *dst,\u000A                                     halide_dimension_t *dst_shape,\u000A                                     const halide_buffer_t *src,\u000A                                     const int *min, const int *extent) {\u000A    *dst = *src;\u000A    dst->dim = dst_shape;\u000A    int64_t offset = 0;\u000A    for (int i = 0; i < dst->dimensions; i++) {\u000A        dst->dim[i] = src->dim[i];\u000A        dst->dim[i].min = min[i];\u000A        dst->dim[i].extent = extent[i];\u000A        offset += (min[i] - src->dim[i].min) * src->dim[i].stride;\u000A    }\u000A    if (dst->host) {\u000A        dst->host += offset * src->type.bytes();\u000A    }\u000A    dst->device_interface = 0;\u000A    dst->device = 0;\u000A    if (src->device_interface) {\u000A        src->device_interface->device_crop(user_context, src, dst);\u000A    }\u000A    return dst;\u000A}\u000A\u000A\u000A// Called on return from an extern stage where the output buffer was a\u000A// crop of some other larger buffer. This happens for extern stages\u000A// with distinct store_at/compute_at levels. Each call to the stage\u000A// only fills in part of the buffer.\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_retire_crop_after_extern_stage(void *user_context,\u000A                                                   void *obj) {\u000A    halide_buffer_t **buffers = (halide_buffer_t **)obj;\u000A    halide_buffer_t *crop = buffers[0];\u000A    halide_buffer_t *parent = buffers[1];\u000A\u000A    if (crop->device) {\u000A        if (!parent->device) {\u000A            // We have been given a device allocation by the extern\u000A            // stage. It only represents the cropped region, so we\u000A            // can't just give it to the parent.\u000A            if (crop->device_dirty()) {\u000A                crop->device_interface->copy_to_host(user_context, crop);\u000A            }\u000A            crop->device_interface->device_free(user_context, crop);\u000A        } else {\u000A            // We are a crop of an existing device allocation.\u000A            if (crop->device_dirty()) {\u000A                parent->set_device_dirty();\u000A            }\u000A            crop->device_interface->device_release_crop(user_context, crop);\u000A        }\u000A    }\u000A    if (crop->host_dirty()) {\u000A        parent->set_host_dirty();\u000A    }\u000A    return 0;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Aint _halide_buffer_retire_crops_after_extern_stage(void *user_context,\u000A                                                    void *obj) {\u000A    halide_buffer_t **buffers = (halide_buffer_t **)obj;\u000A    while (*buffers) {\u000A        _halide_buffer_retire_crop_after_extern_stage(user_context, buffers);\u000A        buffers += 2;\u000A    }\u000A    return 0;\u000A}\u000A\u000AHALIDE_BUFFER_HELPER_ATTRS\u000Ahalide_buffer_t *_halide_buffer_set_bounds(halide_buffer_t *buf,\u000A                                           int dim, int min, int extent) {\u000A    buf->dim[dim].min = min;\u000A    buf->dim[dim].extent = extent;\u000A    return buf;\u000A}\u000A\u000A}\u000A\u000A#undef HALIDE_BUFFER_HELPER_ATTRS\u000A\u000A\u000A// ll suffix in OpenCL is reserved for 128-bit integers.\u000A#if defined __OPENCL_VERSION__\u000A#define ADD_INT64_T_SUFFIX(x) x##l\u000A#define ADD_UINT64_T_SUFFIX(x) x##ul\u000A// HLSL doesn't have any suffixes.\u000A#elif defined HLSL_VERSION\u000A#define ADD_INT64_T_SUFFIX(x) x\u000A#define ADD_UINT64_T_SUFFIX(x) x\u000A#else\u000A#define ADD_INT64_T_SUFFIX(x) x##ll\u000A#define ADD_UINT64_T_SUFFIX(x) x##ull\u000A#endif\u000A\u000A#ifndef HALIDE_MUST_USE_RESULT\u000A#ifdef __has_attribute\u000A#if __has_attribute(nodiscard)\u000A#define HALIDE_MUST_USE_RESULT [[nodiscard]]\u000A#elif __has_attribute(warn_unused_result)\u000A#define HALIDE_MUST_USE_RESULT __attribute__((warn_unused_result))\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#else\u000A#define HALIDE_MUST_USE_RESULT\u000A#endif\u000A#endif\u000A\u000A#ifndef HALIDE_FUNCTION_ATTRS\u000A#define HALIDE_FUNCTION_ATTRS\u000A#endif\u000A\u000Avoid halide_device_and_host_free_as_destructor(void *user_context, void *obj) {\u000A}\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/hardware_demo.cpp", "name":"hardware_demo.cpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/hardware_demo.cpp", "content":"#include <cstdlib>\u000A#include <iostream>\u000A#include <vector>\u000A\u000A#include \"./sgemm.sycl.h\"\u000A#include \"parameters.h\"\u000A#include \"HalideBuffer.h\"\u000A\u000Aint main() {\u000A    using Halide::Runtime::Buffer;\u000A    constexpr int M = III * II * 32;\u000A    constexpr int N = JJJ * JJ * 32;\u000A    constexpr int K = KKK * KK * 32;\u000A\u000A    constexpr auto alpha = 2.0f;\u000A    constexpr auto beta = 3.0f; \u000A\u000A    Buffer<float> a(K, M);\u000A    Buffer<float> b(N, K);\u000A    Buffer<float> c(N, M);\u000A    Buffer<float> out(JJJ, JJ, II, III, 32, 32);\u000A    for (size_t i = 0; i < M; i++)\u000A        for (size_t k = 0; k < K; k++)\u000A            a(k, i) = float(std::rand()) / RAND_MAX - 0.5f; \u000A\u000A    for (size_t k = 0; k < K; k++)\u000A        for (size_t j = 0; j < N; j++)\u000A            b(j, k) = float(std::rand()) / RAND_MAX - 0.5f; \u000A\u000A    for (size_t i = 0; i < M; i++)\u000A        for (size_t j = 0; j < N; j++)\u000A            c(j, i) = float(std::rand()) / RAND_MAX - 0.5f;\u000A\u000A#if defined(SYCL_LANGUAGE_VERSION) && SYCL_LANGUAGE_VERSION >= 202001\u000A#if defined(FPGA_EMULATOR) || defined(TEST)\u000A    auto device_selector = +[](const sycl::device &device){\u000A        return device.get_platform().get_info<sycl::info::platform::name>()\u000A            == sycl::ext::intel::EMULATION_PLATFORM_NAME ? 10000 : -1;\u000A    };\u000A#else\u000A    auto device_selector = +[](const sycl::device &device){\u000A        return device.get_platform().get_info<sycl::info::platform::name>()\u000A            == sycl::ext::intel::HARDWARE_PLATFORM_NAME ? 10000 : -1;\u000A    };\u000A#endif\u000A#else\u000A#if defined(FPGA_EMULATOR) || defined(TEST)\u000A    sycl::ext::intel::fpga_emulator_selector device_selector{};\u000A#else\u000A    sycl::ext::intel::fpga_selector device_selector{};\u000A#endif\u000A#endif\u000A\u000A    auto exec_time = t2sp::sgemm::sgemm(device_selector, false, false, alpha, beta, a, b, c, out); \u000A\u000A    double number_ops = 2.0 * M * N * K + M * N;\u000A    std::cout << \"GFlops: \" << number_ops / exec_time << \"\\n\";\u000A    std::cout << \"Size of matrix A: \" << M << \" * \" << K << \"\\n\";\u000A    std::cout << \"Size of matrix B: \" << K << \" * \" << N << \"\\n\";\u000A    std::cout << \"Size of matrix C: \" << M << \" * \" << N << \"\\n\";\u000A    return 0;\u000A}\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/metaprogramming_utils.hpp", "name":"metaprogramming_utils.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/metaprogramming_utils.hpp", "content":"#ifndef __METAPROGRAMMING_UTILS_HPP__\u000A#define __METAPROGRAMMING_UTILS_HPP__\u000A\u000A#include <type_traits>\u000A\u000Anamespace fpga_tools {\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_range'\u000A// and 'make_index_range' these are akin to 'std::make_integer_sequence'\u000A// and 'std::make_index_sequence', respectively.\u000A// However they allow you to specificy a range and can either increment\u000A// or decrement, rather than a strict increasing sequence\u000A//\u000Atemplate <typename T, typename, T begin, bool increase>\u000Astruct integer_range_impl;\u000A\u000A// incrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, true> {\u000A  using type = std::integer_sequence<T, N + begin...>;\u000A};\u000A\u000A// decrementing case\u000Atemplate <typename T, T... N, T begin>\u000Astruct integer_range_impl<T, std::integer_sequence<T, N...>, begin, false> {\u000A  using type = std::integer_sequence<T, begin - N...>;\u000A};\u000A\u000A// integer_range\u000Atemplate <typename T, T begin, T end>\u000Ausing integer_range = typename integer_range_impl<\u000A    T, std::make_integer_sequence<T, (begin < end) ? end - begin : begin - end>,\u000A    begin, (begin < end)>::type;\u000A\u000A//\u000A// make_integer_range\u000A//\u000A// USAGE:\u000A//    make_integer_range<int,1,10>{} ==> 1,2,...,9\u000A//    make_integer_range<int,10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <class T, T begin, T end>\u000Ausing make_integer_range = integer_range<T, begin, end>;\u000A\u000A//\u000A// make_index_range\u000A//\u000A// USAGE:\u000A//    make_index_range<1,10>{} ==> 1,2,...,9\u000A//    make_index_range<10,1>{} ==> 10,9,...,2\u000A//\u000Atemplate <std::size_t begin, std::size_t end>\u000Ausing make_index_range = integer_range<std::size_t, begin, end>;\u000A\u000A//\u000A// The code below creates the constexprs 'make_integer_pow2_sequence'\u000A// and 'make_index_pow2_sequence'. These generate the sequence\u000A// 2^0, 2^1, 2^2, ... , 2^(N-1) = 1,2,4,...,2^(N-1)\u000A//\u000Atemplate <typename T, typename>\u000Astruct integer_pow2_sequence_impl;\u000A\u000Atemplate <typename T, T... Pows>\u000Astruct integer_pow2_sequence_impl<T, std::integer_sequence<T, Pows...>> {\u000A  using type = std::integer_sequence<T, (T(1) << Pows)...>;\u000A};\u000A\u000A// integer_pow2_sequence\u000Atemplate <typename T, T N>\u000Ausing integer_pow2_sequence =\u000A    typename integer_pow2_sequence_impl<T,\u000A                                        std::make_integer_sequence<T, N>>::type;\u000A\u000A//\u000A// make_integer_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_integer_pow2_sequence<int,5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <class T, T N>\u000Ausing make_integer_pow2_sequence = integer_pow2_sequence<T, N>;\u000A\u000A//\u000A// make_index_pow2_sequence\u000A//\u000A// USAGE:\u000A//    make_index_pow2_sequence<5>{} ==> 1,2,4,8,16\u000A//\u000Atemplate <std::size_t N>\u000Ausing make_index_pow2_sequence = integer_pow2_sequence<std::size_t, N>;\u000A\u000A//\u000A// Checks for existence of subscript operator\u000A//\u000Anamespace detail {\u000Atemplate <typename... >\u000Ausing void_t = void;\u000A\u000Atemplate<class T, typename = void>\u000Astruct has_subscript_impl : std::false_type { };\u000A\u000Atemplate<typename T>\u000Astruct has_subscript_impl<T, void_t<decltype(std::declval<T>()[1])>> \u000A  : std::true_type { };\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct has_subscript {\u000A  static constexpr bool value =\u000A    std::is_same_v<typename detail::has_subscript_impl<T>::type, std::true_type>;\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool has_subscript_v = has_subscript<T>::value;\u000A\u000A//\u000A// checks if a type is any instance of SYCL pipe\u000A//\u000Anamespace detail {\u000A\u000Atemplate<typename T>\u000Astruct is_sycl_pipe_impl : std::false_type {};\u000A\u000Atemplate<typename Id, typename T, std::size_t N>\u000Astruct is_sycl_pipe_impl<sycl::ext::intel::pipe<Id, T, N>> : std::true_type {};\u000A\u000A}  // namespace detail\u000A\u000Atemplate <typename T>\u000Astruct is_sycl_pipe {\u000A  static constexpr bool value = detail::is_sycl_pipe_impl<T>{};\u000A};\u000A\u000Atemplate <typename T>\u000Ainline constexpr bool is_sycl_pipe_v = is_sycl_pipe<T>::value;\u000A\u000A} // namespace fpga_tools\u000A\u000A#endif  /* __METAPROGRAMMING_UTILS_HPP__ */"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/parameters.h", "name":"parameters.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/parameters.h", "content":"/*******************************************************************************\u000A* Copyright 2021 Intel Corporation\u000A*\u000A* Licensed under the BSD-2-Clause Plus Patent License (the \"License\");\u000A* you may not use this file except in compliance with the License.\u000A* You may obtain a copy of the License at\u000A*\u000A* https://opensource.org/licenses/BSDplusPatent\u000A*\u000A* Unless required by applicable law or agreed to in writing,\u000A* software distributed under the License is distributed on an \"AS IS\" BASIS,\u000A* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A* See the License for the specific language governing permissions\u000A* and limitations under the License.\u000A*\u000A*\u000A* SPDX-License-Identifier: BSD-2-Clause-Patent\u000A*******************************************************************************/\u000A#ifndef GEMM_CONST_PARAMS_H\u000A#define GEMM_CONST_PARAMS_H\u000A\u000A// Inner loop bounds, which are static constant parameters of the design\u000A#ifdef TINY // For verifying correctness only\u000A    #define KKK         4\u000A    #define JJJ         4\u000A    #define III         4\u000A    #define JJ          4\u000A    #define II          4\u000A    #define KK          4\u000A#else // LARGE\u000A    #ifdef GPU\u000A        #define KKK         8\u000A        #define JJJ         8\u000A        #define III         32\u000A        #define JJ          8\u000A        #define II          2\u000A        #define KK          1\u000A    #elif defined(S10)\u000A        #ifdef T2SP_SGEMM\u000A            #define KKK         16\u000A            #define JJJ         16\u000A            #define III         14\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #elif defined(T2SP_DGEMM)\u000A            #define KKK         8\u000A            #define JJJ         4\u000A            #define III         8\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #elif defined(T2SP_CGEMM)\u000A            #define KKK         16\u000A            #define JJJ         16\u000A            #define III         14\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #else\u000A            #define KKK         4\u000A            #define JJJ         6\u000A            #define III         4\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #endif\u000A    #else   // TARGET == A10\u000A        #ifdef T2SP_SGEMM\u000A            #define KKK         16\u000A            #define JJJ         8\u000A            #define III         10\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #elif defined(T2SP_DGEMM)\u000A            #define KKK         8\u000A            #define JJJ         4\u000A            #define III         8\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #elif defined(T2SP_CGEMM)\u000A            #define KKK         8\u000A            #define JJJ         4\u000A            #define III         10\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32\u000A        #else\u000A            #define KKK         4\u000A            #define JJJ         4\u000A            #define III         4\u000A            #define JJ          32\u000A            #define II          32\u000A            #define KK          32        \u000A        #endif\u000A    #endif\u000A#endif\u000A\u000A#if defined(T2SP_SGEMM)\u000A    #define ZERO 0\u000A    #define CONST_TYPE float\u000A    #define TTYPE Float(32)\u000A    #define KERNEL \"sgemm\"\u000A#elif defined(T2SP_DGEMM)\u000A    #define ZERO 0\u000A    #define CONST_TYPE double\u000A    #define TTYPE Float(64) \u000A    #define KERNEL \"dgemm\"\u000A#elif defined(T2SP_CGEMM)\u000A    #define ZERO complex32_t(0.0f, 0.0f)\u000A    #define CONST_TYPE complex32_t\u000A    #define TTYPE Complex(32)\u000A    #define KERNEL \"cgemm\"\u000A#elif defined(T2SP_ZGEMM)\u000A    #define ZERO complex64_t(0.0, 0.0)\u000A    #define CONST_TYPE complex64_t\u000A    #define TTYPE Complex(64) \u000A    #define KERNEL \"zgemm\"\u000A#endif\u000A\u000A#endif \u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/pipe_wrapper.hpp", "name":"pipe_wrapper.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/include/pipe_wrapper.hpp", "content":"#pragma once\u000A#include <cstdint>\u000A#if __has_include(<sycl/sycl.hpp>)\u000A#include <sycl/sycl.hpp>\u000A#else\u000A#include <CL/sycl.hpp>\u000A#endif\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// The SYCL 1.2.1 device_selector class is deprecated in SYCL 2020.\u000A// Use the callable selector object instead.\u000A#if SYCL_LANGUAGE_VERSION >= 202001\u000Ausing device_selector_t = int(*)(const sycl::device&);\u000A#else\u000Ausing device_selector_t = const sycl::device_selector &;\u000A#endif\u000A\u000Astruct device_handle {\u000A  // Important: order these to avoid any padding between fields;\u000A  // some Win32 compiler optimizer configurations can inconsistently\u000A  // insert padding otherwise.\u000A  uint64_t offset;\u000A  void *mem;\u000A};\u000A\u000Atemplate <typename name, typename data_type, int32_t min_capacity, int32_t... dims>\u000Astruct pipe_wrapper {\u000A  template <int32_t...> struct unique_id;\u000A  template <int32_t... idxs>\u000A  static data_type read() {\u000A    static_assert(((idxs >= 0) && ...), \"Negative index\");\u000A    static_assert(((idxs < dims) && ...), \"Index out of bounds\");\u000A    return sycl::ext::intel::pipe<unique_id<idxs...>, data_type, min_capacity>::read();\u000A  }\u000A  template <int32_t... idxs>\u000A  static void write(const data_type &t) {\u000A    static_assert(((idxs >= 0) && ...), \"Negative index\");\u000A    static_assert(((idxs < dims) && ...), \"Index out of bounds\");\u000A    sycl::ext::intel::pipe<unique_id<idxs...>, data_type, min_capacity>::write(t);\u000A  }\u000A};"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/sgemm.sycl.h", "name":"sgemm.sycl.h", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/ReferenceDesigns/productive_libraries/blas/gemm/4x4-16ResultsPerPE/signal-generator/sgemm.sycl.h", "content":"#pragma once\u000A#include \"halide_runtime_etc.h\"\u000A#if __has_include(<sycl/sycl.hpp>)\u000A#include <sycl/sycl.hpp>\u000A#else\u000A#include <CL/sycl.hpp>\u000A#endif\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A#include \"pipe_wrapper.hpp\"\u000A#include \"complex_helper.hpp\"\u000A#include \"constexpr_math.hpp\"\u000A#include \"tuple.hpp\"\u000A#include \"unrolled_loop.hpp\"\u000A\u000Ausing namespace sycl;\u000Anamespace t2sp::sgemm {\u000A\u000Atypedef union {\u000Abool __attribute__ ((aligned(4))) s[4];\u000Astruct {bool s0,  s1,  s2,  s3;};\u000A} bool4;\u000Ausing aLoader_channel = pipe_wrapper<class aLoader_channel_pipe, float4, 256>;\u000Ausing aFeeder_channel_array_t = fpga_tools::NTuple<float4, 4>;\u000Ausing aFeeder_channel = pipe_wrapper<class aFeeder_channel_pipe, aFeeder_channel_array_t, 256>;\u000Ausing bLoader_channel = pipe_wrapper<class bLoader_channel_pipe, float4, 256>;\u000Ausing bFeeder_channel_array_t = fpga_tools::NTuple<float4, 4>;\u000Ausing bFeeder_channel = pipe_wrapper<class bFeeder_channel_pipe, bFeeder_channel_array_t, 256>;\u000Atypedef struct {\u000A    bool s[4];\u000A} signals_t;\u000Ausing SignalGenerator_channel = sycl::ext::intel::pipe<class _SignalGenerator_channel_pipe, signals_t, 256>;\u000Ausing Product_channel = pipe_wrapper<class Product_channel_pipe, float4, 256>;\u000Ausing cLoader_channel = pipe_wrapper<class cLoader_channel_pipe, float4, 256>;\u000Ausing Out_channel = pipe_wrapper<class Out_channel_pipe, float4, 256>;\u000Aauto sgemm(device_selector_t device_selector_v, bool p0, bool p1, float p2, float p3, struct halide_buffer_t *A_buffer, struct halide_buffer_t *B_buffer, struct halide_buffer_t *C_buffer, struct halide_buffer_t *Output_buffer) {\u000A  std::vector<sycl::event> oneapi_kernel_events{};\u000A  std::vector<size_t> kernels_used_to_measure_time{};\u000A  auto exception_handler = [](sycl::exception_list exceptions) {\u000A    for (std::exception_ptr const &e : exceptions) {\u000A      try {\u000A        std::rethrow_exception(e);\u000A      } catch (sycl::exception const &e) {\u000A        std::cout << \"Caught asynchronous SYCL exception:\\n\"\u000A                  << e.what() << std::endl;\u000A      }\u000A    }\u000A  };\u000A  #ifndef T2SP_NDEBUG\u000A  std::cout << \"// creating device queues\\n\";\u000A  #endif\u000A  sycl::queue q_host(sycl::cpu_selector_v, exception_handler, sycl::property::queue::enable_profiling());\u000A  sycl::queue q_device(device_selector_v, exception_handler, sycl::property::queue::enable_profiling());\u000A  #ifndef T2SP_NDEBUG\u000A  std::cout << \"// Host: \" << q_host.get_device().get_info<sycl::info::device::name>() << \"\\n\";\u000A  std::cout << \"// Device: \" << q_device.get_device().get_info<sycl::info::device::name>() << \"\\n\";\u000A  #endif\u000A  sycl::device dev = q_device.get_device();\u000A  void * const _ucon = nullptr;\u000A  void * A = _halide_buffer_get_host(A_buffer);\u000A  uint32_t A_type = _halide_buffer_get_type(A_buffer);\u000A  int32_t A_dimensions = _halide_buffer_get_dimensions(A_buffer);\u000A  int32_t A_min_0 = _halide_buffer_get_min(A_buffer, 0);\u000A  int32_t A_extent_0 = _halide_buffer_get_extent(A_buffer, 0);\u000A  int32_t A_stride_0 = _halide_buffer_get_stride(A_buffer, 0);\u000A  int32_t A_min_1 = _halide_buffer_get_min(A_buffer, 1);\u000A  int32_t A_extent_1 = _halide_buffer_get_extent(A_buffer, 1);\u000A  int32_t A_stride_1 = _halide_buffer_get_stride(A_buffer, 1);\u000A  void * B = _halide_buffer_get_host(B_buffer);\u000A  uint32_t B_type = _halide_buffer_get_type(B_buffer);\u000A  int32_t B_dimensions = _halide_buffer_get_dimensions(B_buffer);\u000A  int32_t B_min_0 = _halide_buffer_get_min(B_buffer, 0);\u000A  int32_t B_extent_0 = _halide_buffer_get_extent(B_buffer, 0);\u000A  int32_t B_stride_0 = _halide_buffer_get_stride(B_buffer, 0);\u000A  int32_t B_min_1 = _halide_buffer_get_min(B_buffer, 1);\u000A  int32_t B_extent_1 = _halide_buffer_get_extent(B_buffer, 1);\u000A  int32_t B_stride_1 = _halide_buffer_get_stride(B_buffer, 1);\u000A  void * C = _halide_buffer_get_host(C_buffer);\u000A  uint32_t C_type = _halide_buffer_get_type(C_buffer);\u000A  int32_t C_dimensions = _halide_buffer_get_dimensions(C_buffer);\u000A  int32_t C_min_0 = _halide_buffer_get_min(C_buffer, 0);\u000A  int32_t C_extent_0 = _halide_buffer_get_extent(C_buffer, 0);\u000A  int32_t C_stride_0 = _halide_buffer_get_stride(C_buffer, 0);\u000A  int32_t C_min_1 = _halide_buffer_get_min(C_buffer, 1);\u000A  int32_t C_extent_1 = _halide_buffer_get_extent(C_buffer, 1);\u000A  int32_t C_stride_1 = _halide_buffer_get_stride(C_buffer, 1);\u000A  void * Output = _halide_buffer_get_host(Output_buffer);\u000A  uint32_t Output_type = _halide_buffer_get_type(Output_buffer);\u000A  int32_t Output_dimensions = _halide_buffer_get_dimensions(Output_buffer);\u000A  int32_t Output_min_0 = _halide_buffer_get_min(Output_buffer, 0);\u000A  int32_t Output_extent_0 = _halide_buffer_get_extent(Output_buffer, 0);\u000A  int32_t Output_stride_0 = _halide_buffer_get_stride(Output_buffer, 0);\u000A  int32_t Output_min_1 = _halide_buffer_get_min(Output_buffer, 1);\u000A  int32_t Output_extent_1 = _halide_buffer_get_extent(Output_buffer, 1);\u000A  int32_t Output_stride_1 = _halide_buffer_get_stride(Output_buffer, 1);\u000A  int32_t Output_min_2 = _halide_buffer_get_min(Output_buffer, 2);\u000A  int32_t Output_extent_2 = _halide_buffer_get_extent(Output_buffer, 2);\u000A  int32_t Output_stride_2 = _halide_buffer_get_stride(Output_buffer, 2);\u000A  int32_t Output_min_3 = _halide_buffer_get_min(Output_buffer, 3);\u000A  int32_t Output_extent_3 = _halide_buffer_get_extent(Output_buffer, 3);\u000A  int32_t Output_stride_3 = _halide_buffer_get_stride(Output_buffer, 3);\u000A  int32_t Output_min_4 = _halide_buffer_get_min(Output_buffer, 4);\u000A  int32_t Output_extent_4 = _halide_buffer_get_extent(Output_buffer, 4);\u000A  int32_t Output_stride_4 = _halide_buffer_get_stride(Output_buffer, 4);\u000A  int32_t Output_min_5 = _halide_buffer_get_min(Output_buffer, 5);\u000A  int32_t Output_extent_5 = _halide_buffer_get_extent(Output_buffer, 5);\u000A  int32_t Output_stride_5 = _halide_buffer_get_stride(Output_buffer, 5);\u000A  if (_halide_buffer_is_bounds_query(A_buffer)) {\u000A    struct halide_dimension_t s0[2] = {\u000A      {A_min_0, A_extent_0, 1, 0},\u000A      {A_min_1, A_extent_1, A_extent_0, 0},\u000A    };\u000A  }\u000A  if (_halide_buffer_is_bounds_query(B_buffer)) {\u000A    struct halide_dimension_t s1[2] = {\u000A      {B_min_0, B_extent_0, 1, 0},\u000A      {B_min_1, B_extent_1, B_extent_0, 0},\u000A    };\u000A  }\u000A  if (_halide_buffer_is_bounds_query(C_buffer)) {\u000A    struct halide_dimension_t s2[2] = {\u000A      {C_min_0, C_extent_0, 1, 0},\u000A      {C_min_1, C_extent_1, C_extent_0, 0},\u000A    };\u000A  }\u000A  if (_halide_buffer_is_bounds_query(Output_buffer)) {\u000A    struct halide_dimension_t s3[6] = {\u000A      {0, 4, 1, 0},\u000A      {0, 4, 4, 0},\u000A      {0, 4, 16, 0},\u000A      {0, 4, 64, 0},\u000A      {0, (B_extent_0 + 15) / 16, 256, 0},\u000A      {0, (A_extent_1 + 15) / 16, (B_extent_0 + 15) / 16 * 256, 0},\u000A    };\u000A  }\u000A  if (!(_halide_buffer_is_bounds_query(Output_buffer) || (_halide_buffer_is_bounds_query(C_buffer) || (_halide_buffer_is_bounds_query(A_buffer) || _halide_buffer_is_bounds_query(B_buffer))))) {\u000A    int64_t A_total_extent_1 = (int64_t)(A_extent_1) * (int64_t)(A_extent_0);\u000A    int64_t B_total_extent_1 = (int64_t)(B_extent_1) * (int64_t)(B_extent_0);\u000A    int64_t C_total_extent_1 = (int64_t)(C_extent_1) * (int64_t)(C_extent_0);\u000A    int64_t Output_total_extent_1 = (int64_t)(Output_extent_1) * (int64_t)(Output_extent_0);\u000A    int64_t Output_total_extent_2 = Output_total_extent_1 * (int64_t)(Output_extent_2);\u000A    int64_t Output_total_extent_3 = Output_total_extent_2 * (int64_t)(Output_extent_3);\u000A    int64_t Output_total_extent_4 = Output_total_extent_3 * (int64_t)(Output_extent_4);\u000A    int64_t Output_total_extent_5 = Output_total_extent_4 * (int64_t)(Output_extent_5);\u000A    halide_buffer_t b0;\u000A    struct halide_dimension_t s4[9] = {\u000A      {0, 4, 1, 0},\u000A      {0, 1, 4, 0},\u000A      {0, 4, 4, 0},\u000A      {0, 1, 16, 0},\u000A      {0, 4, 16, 0},\u000A      {0, 4, 64, 0},\u000A      {0, (B_extent_1 + 15) / 16, 256, 0},\u000A      {0, 1, (B_extent_1 + 15) / 16 * 256, 0},\u000A      {0, (A_extent_1 + 15) / 16, (B_extent_1 + 15) / 16 * 256, 0},\u000A    };\u000A    struct halide_dimension_t s5[9] = {\u000A      {0, 4, 1, 0},\u000A      {0, 1, 4, 0},\u000A      {0, 4, 4, 0},\u000A      {0, 1, 16, 0},\u000A      {0, 4, 16, 0},\u000A      {0, 4, 64, 0},\u000A      {0, (B_extent_1 + 15) / 16, 256, 0},\u000A      {0, 1, (B_extent_1 + 15) / 16 * 256, 0},\u000A      {0, (A_extent_1 + 15) / 16, (B_extent_1 + 15) / 16 * 256, 0},\u000A    };\u000A    struct halide_buffer_t * A_serializer_mem_channel_buffer = _halide_buffer_init(&b0, s4, (void *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), (uint64_t)(ADD_UINT64_T_SUFFIX(0)), (struct halide_device_interface_t *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), 2, 32, 9, s5, (uint64_t)(ADD_UINT64_T_SUFFIX(0)));\u000A    int32_t halide_device_and_host_malloc_result_3 = 0; // halide_device_and_host_malloc(A_serializer_mem_channel_buffer, NULL /* halide_oneapi_device_interface() replaced */) replaced with line(s) below \u000A    if (!A_serializer_mem_channel_buffer->device) { // device malloc\u000A      #ifndef T2SP_NDEBUG\u000A      std::cout << \"//\t device malloc A_serializer_mem_channel_buffer\\n\";\u000A      #endif\u000A      assert(A_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A      uint64_t lowest_index = 0;\u000A      uint64_t highest_index = 0;\u000A      for (int i = 0; i < A_serializer_mem_channel_buffer->dimensions; i++) {\u000A        if (A_serializer_mem_channel_buffer->dim[i].stride < 0) {\u000A          lowest_index += (uint64_t)(A_serializer_mem_channel_buffer->dim[i].stride) * (A_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A        }\u000A        if (A_serializer_mem_channel_buffer->dim[i].stride > 0) {\u000A          highest_index += (uint64_t)(A_serializer_mem_channel_buffer->dim[i].stride) * (A_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A        }\u000A      }\u000A      device_handle *dev_handle = (device_handle *)std::malloc(sizeof(device_handle));\u000A      dev_handle->mem = (void*)sycl::malloc_device(A_serializer_mem_channel_buffer->size_in_bytes(), q_device);\u000A      dev_handle->offset = 0;\u000A      A_serializer_mem_channel_buffer->device = (uint64_t)dev_handle;\u000A    };\u000A    { // host malloc\u000A      #ifndef T2SP_NDEBUG\u000A      std::cout << \"//\\t host malloc A_serializer_mem_channel_buffer\\n\";\u000A      #endif\u000A      assert(A_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A      A_serializer_mem_channel_buffer->host = (uint8_t*)std::malloc(A_serializer_mem_channel_buffer->size_in_bytes());\u000A      assert(A_serializer_mem_channel_buffer->host != NULL);\u000A    };\u000A    struct s6 { void * const ucon; void * const arg; s6(void *ucon, void *a) : ucon(ucon), arg((void *)a) {} ~s6() { halide_device_and_host_free_as_destructor(ucon, arg); } } d0(_ucon, A_serializer_mem_channel_buffer);\u000A    {\u000A      float *A_serializer_mem_channel = (float *)(_halide_buffer_get_host(A_serializer_mem_channel_buffer));\u000A      if (!A_serializer_mem_channel)\u000A      {\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"Condition 'A_serializer_mem_channel' failed with error id_msg: None\\n\";\u000A        #endif\u000A        assert(false);\u000A      }\u000A      {\u000A        int32_t addr_temp;\u000A        addr_temp = 0;\u000A        int32_t halide_copy_to_host_result_1 = 0; // halide_copy_to_host(A_buffer) replaced with line(s) below \u000A        { // memcpy \u000A          bool from_host = (A_buffer->device == 0) || (A_buffer->host_dirty() && A_buffer->host != NULL);\u000A          bool to_host = 1;\u000A          if (!from_host && to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy device->host A_buffer\\n\";\u000A            #endif\u000A            q_device.submit([&](handler& h){ h.memcpy((void *)A_buffer->host, (void *)(((device_handle*)A_buffer->device)->mem), A_buffer->size_in_bytes()); }).wait();\u000A          } else if (from_host && !to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy host->device A_buffer\\n\";\u000A            #endif\u000A            q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)A_buffer->device)->mem), (void *)A_buffer->host, A_buffer->size_in_bytes()); }).wait();\u000A          } else if (!from_host && !to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A            #endif\u000A            assert(false);\u000A          } else {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy A_buffer Do nothing.\\n\";\u000A            #endif\u000A          }\u000A        };\u000A        // kernel_A_serializer\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"// kernel kernel_A_serializer\\n\";\u000A        #endif\u000A        float *A = (float*)(A_buffer->host);\u000A        A_serializer_mem_channel = (float*)(A_serializer_mem_channel_buffer->host);\u000A        {\u000A          for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A            for (int k = 0; k < (B_extent_1 + 15) / 16; k++) {\u000A              for (int kk_ii_iii_kkk = 0; kk_ii_iii_kkk < 256; kk_ii_iii_kkk++) {\u000A                if (i * 16 + (kk_ii_iii_kkk % 16 / 4 + kk_ii_iii_kkk % 64 / 16 * 4) < A_extent_1 && (kk_ii_iii_kkk / 64 + k * 4) * 4 < B_extent_1) {\u000A                  auto _D0 = (!p0 ? k * 16 + (kk_ii_iii_kkk / 64 * 4 + kk_ii_iii_kkk % 4) : i * 16 + (kk_ii_iii_kkk % 16 / 4 + kk_ii_iii_kkk % 64 / 16 * 4)) + (!p0 ? i * 16 + (kk_ii_iii_kkk % 16 / 4 + kk_ii_iii_kkk % 64 / 16 * 4) : k * 16 + (kk_ii_iii_kkk / 64 * 4 + kk_ii_iii_kkk % 4)) * A_stride_1 - (A_min_1 * A_stride_1 + A_min_0);\u000A                  A_serializer_mem_channel[addr_temp] = ((float *)A)[_D0];\u000A                }\u000A                addr_temp = addr_temp + 1;\u000A              }\u000A            }\u000A          }\u000A        }\u000A        _halide_buffer_set_host_dirty(A_serializer_mem_channel_buffer, (bool)(ADD_UINT64_T_SUFFIX(1)));\u000A      }\u000A      { // memcpy \u000A        bool from_host = (A_serializer_mem_channel_buffer->device == 0) || (A_serializer_mem_channel_buffer->host_dirty() && A_serializer_mem_channel_buffer->host != NULL);\u000A        bool to_host = 0;\u000A        if (!from_host && to_host) {\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\t memcpy device->host A_serializer_mem_channel_buffer\\n\";\u000A          #endif\u000A          q_device.submit([&](handler& h){ h.memcpy((void *)A_serializer_mem_channel_buffer->host, (void *)(((device_handle*)A_serializer_mem_channel_buffer->device)->mem), A_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A        } else if (from_host && !to_host) {\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\t memcpy host->device A_serializer_mem_channel_buffer\\n\";\u000A          #endif\u000A          q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)A_serializer_mem_channel_buffer->device)->mem), (void *)A_serializer_mem_channel_buffer->host, A_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A        } else if (!from_host && !to_host) {\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A          #endif\u000A          assert(false);\u000A        } else {\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\t memcpy A_serializer_mem_channel_buffer Do nothing.\\n\";\u000A          #endif\u000A        }\u000A      }\u000A      kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A      // kernel_aLoader\u000A      #ifndef T2SP_NDEBUG\u000A      std::cout << \"// kernel kernel_aLoader\\n\";\u000A      #endif\u000A      A_serializer_mem_channel = (float*)(((device_handle*) A_serializer_mem_channel_buffer->device)->mem);\u000A      oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A        h.single_task<class kernel_aLoader_class>([=](){\u000A          int addr_temp;\u000A          addr_temp = 0;\u000A          for (int i = 0; i < (A_extent_1 + 31) / 16; i++) {\u000A            for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A              for (int k = 0; k < (B_extent_1 + 15) / 16; k++) {\u000A                for (int kk_ii_iii = 0; kk_ii_iii < 64; kk_ii_iii++) {\u000A                  if (j == 0 && k == 0 || i < (A_extent_1 + 15) / 16) {\u000A                    auto _D1 = (addr_temp / ((B_extent_0 + 15) / 16 * ((B_extent_1 + 15) / 16) * 64) * ((B_extent_1 + 15) / 16) * 64 + addr_temp % ((B_extent_1 + 15) / 16 * 64)) * 4;\u000A                    aLoader_channel::write<>(i * 16 + (kk_ii_iii % 16 / 4 * 4 + kk_ii_iii % 4) < A_extent_1 && (kk_ii_iii / 16 + k * 4) * 4 < B_extent_1 && i < (A_extent_1 + 15) / 16 ? float4{\u000A                      A_serializer_mem_channel[_D1 + 0],\u000A                      A_serializer_mem_channel[_D1 + 1],\u000A                      A_serializer_mem_channel[_D1 + 2],\u000A                      A_serializer_mem_channel[_D1 + 3]\u000A                    } : float4{float_from_bits(0)});\u000A                  }\u000A                  addr_temp = addr_temp + 1;\u000A                }\u000A              }\u000A            }\u000A          }\u000A        }); //  h.single_task kernel_aLoader_class\u000A      })); // q_device.submit\u000A      // kernel_aFeeder\u000A      #ifndef T2SP_NDEBUG\u000A      std::cout << \"// kernel kernel_aFeeder\\n\";\u000A      #endif\u000A      oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A        h.single_task<class kernel_aFeeder_class>([=](){\u000A          aFeeder_channel_array_t aFeeder_channel_array;\u000A          float4 aFeeder_value_shreg;\u000A          uint32_t aFeeder_time_stamp_shreg;\u000A          float4 aFeeder_in_v;\u000A          uint aFeeder_cycle;\u000A          // OpenCL's __attribute__((memory, numbanks(4), singlepump, numwriteports(1), numreadports(1)))DB[2][4][4][4]\u000A          [[intel::fpga_memory(), intel::numbanks(4), intel::singlepump, intel::simple_dual_port]]\u000A          float4 DB[2][4][4][4];\u000A          fpga_tools::UnrolledLoop<4>([&](auto jjj_init) {\u000A            if (jjj_init == 0) {\u000A              aFeeder_cycle = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A            }\u000A          });\u000A          while(1) {\u000A            aFeeder_in_v = aLoader_channel::read<>();\u000A            fpga_tools::UnrolledLoop<4>([&](auto buf) {\u000A              if (buf == 0) {\u000A                aFeeder_value_shreg = aFeeder_in_v;\u000A                aFeeder_time_stamp_shreg = aFeeder_cycle;\u000A              } else {\u000A                aFeeder_value_shreg = aFeeder_value_shreg;\u000A                aFeeder_time_stamp_shreg = aFeeder_time_stamp_shreg;\u000A              }\u000A              aFeeder_value_shreg = float4{\u000A              sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[0])),\u000A              sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[1])),\u000A              sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[2])),\u000A              sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_value_shreg[3]))\u000A              };\u000A              aFeeder_time_stamp_shreg = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(aFeeder_time_stamp_shreg));\u000A              if (buf == (int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(4)))) {\u000A                DB[(bool)(aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf] = aFeeder_value_shreg;\u000A              }\u000A              if ((uint)(ADD_UINT64_T_SUFFIX(0)) < aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                aFeeder_channel_array.template get<buf>() = DB[!(bool)(aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(aFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf];\u000A              }\u000A            });\u000A            if ((uint)(ADD_UINT64_T_SUFFIX(0)) < aFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A              aFeeder_channel::write<>(aFeeder_channel_array);\u000A            }\u000A            aFeeder_cycle = aFeeder_cycle + (uint)(ADD_UINT64_T_SUFFIX(1));\u000A          }\u000A        }); //  h.single_task kernel_aFeeder_class\u000A      })); // q_device.submit\u000A      int32_t B_serializer_mem_channel_stride_8_s = (B_extent_0 + 15) / 16 * ((B_extent_1 + 15) / 16);\u000A      halide_buffer_t b1;\u000A      struct halide_dimension_t s7[9] = {\u000A        {0, 4, 1, 0},\u000A        {0, 4, 4, 0},\u000A        {0, 1, 16, 0},\u000A        {0, 4, 16, 0},\u000A        {0, 1, 64, 0},\u000A        {0, 4, 64, 0},\u000A        {0, (B_extent_1 + 15) / 16, 256, 0},\u000A        {0, (B_extent_0 + 15) / 16, (B_extent_1 + 15) / 16 * 256, 0},\u000A        {0, 1, B_serializer_mem_channel_stride_8_s * 256, 0},\u000A      };\u000A      struct halide_dimension_t s8[9] = {\u000A        {0, 4, 1, 0},\u000A        {0, 4, 4, 0},\u000A        {0, 1, 16, 0},\u000A        {0, 4, 16, 0},\u000A        {0, 1, 64, 0},\u000A        {0, 4, 64, 0},\u000A        {0, (B_extent_1 + 15) / 16, 256, 0},\u000A        {0, (B_extent_0 + 15) / 16, (B_extent_1 + 15) / 16 * 256, 0},\u000A        {0, 1, B_serializer_mem_channel_stride_8_s * 256, 0},\u000A      };\u000A      struct halide_buffer_t * B_serializer_mem_channel_buffer = _halide_buffer_init(&b1, s7, (void *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), (uint64_t)(ADD_UINT64_T_SUFFIX(0)), (struct halide_device_interface_t *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), 2, 32, 9, s8, (uint64_t)(ADD_UINT64_T_SUFFIX(0)));\u000A      int32_t halide_device_and_host_malloc_result_2 = 0; // halide_device_and_host_malloc(B_serializer_mem_channel_buffer, NULL /* halide_oneapi_device_interface() replaced */) replaced with line(s) below \u000A      if (!B_serializer_mem_channel_buffer->device) { // device malloc\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"//\t device malloc B_serializer_mem_channel_buffer\\n\";\u000A        #endif\u000A        assert(B_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A        uint64_t lowest_index = 0;\u000A        uint64_t highest_index = 0;\u000A        for (int i = 0; i < B_serializer_mem_channel_buffer->dimensions; i++) {\u000A          if (B_serializer_mem_channel_buffer->dim[i].stride < 0) {\u000A            lowest_index += (uint64_t)(B_serializer_mem_channel_buffer->dim[i].stride) * (B_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A          }\u000A          if (B_serializer_mem_channel_buffer->dim[i].stride > 0) {\u000A            highest_index += (uint64_t)(B_serializer_mem_channel_buffer->dim[i].stride) * (B_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A          }\u000A        }\u000A        device_handle *dev_handle = (device_handle *)std::malloc(sizeof(device_handle));\u000A        dev_handle->mem = (void*)sycl::malloc_device(B_serializer_mem_channel_buffer->size_in_bytes(), q_device);\u000A        dev_handle->offset = 0;\u000A        B_serializer_mem_channel_buffer->device = (uint64_t)dev_handle;\u000A      };\u000A      { // host malloc\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"//\\t host malloc B_serializer_mem_channel_buffer\\n\";\u000A        #endif\u000A        assert(B_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A        B_serializer_mem_channel_buffer->host = (uint8_t*)std::malloc(B_serializer_mem_channel_buffer->size_in_bytes());\u000A        assert(B_serializer_mem_channel_buffer->host != NULL);\u000A      };\u000A      struct s9 { void * const ucon; void * const arg; s9(void *ucon, void *a) : ucon(ucon), arg((void *)a) {} ~s9() { halide_device_and_host_free_as_destructor(ucon, arg); } } d1(_ucon, B_serializer_mem_channel_buffer);\u000A      {\u000A        float *B_serializer_mem_channel = (float *)(_halide_buffer_get_host(B_serializer_mem_channel_buffer));\u000A        if (!B_serializer_mem_channel)\u000A        {\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"Condition 'B_serializer_mem_channel' failed with error id_msg: None\\n\";\u000A          #endif\u000A          assert(false);\u000A        }\u000A        {\u000A          int32_t addr_temp;\u000A          addr_temp = 0;\u000A          int32_t halide_copy_to_host_result_2 = 0; // halide_copy_to_host(B_buffer) replaced with line(s) below \u000A          { // memcpy \u000A            bool from_host = (B_buffer->device == 0) || (B_buffer->host_dirty() && B_buffer->host != NULL);\u000A            bool to_host = 1;\u000A            if (!from_host && to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy device->host B_buffer\\n\";\u000A              #endif\u000A              q_device.submit([&](handler& h){ h.memcpy((void *)B_buffer->host, (void *)(((device_handle*)B_buffer->device)->mem), B_buffer->size_in_bytes()); }).wait();\u000A            } else if (from_host && !to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy host->device B_buffer\\n\";\u000A              #endif\u000A              q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)B_buffer->device)->mem), (void *)B_buffer->host, B_buffer->size_in_bytes()); }).wait();\u000A            } else if (!from_host && !to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A              #endif\u000A              assert(false);\u000A            } else {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy B_buffer Do nothing.\\n\";\u000A              #endif\u000A            }\u000A          };\u000A          // kernel_B_serializer\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"// kernel kernel_B_serializer\\n\";\u000A          #endif\u000A          float *B = (float*)(B_buffer->host);\u000A          B_serializer_mem_channel = (float*)(B_serializer_mem_channel_buffer->host);\u000A          {\u000A            for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A              for (int k = 0; k < (B_extent_1 + 15) / 16; k++) {\u000A                for (int kk_jj_jjj = 0; kk_jj_jjj < 64; kk_jj_jjj++) {\u000A                  if ((kk_jj_jjj / 16 + k * 4) * 4 < B_extent_1 && j * 16 + (kk_jj_jjj % 16 / 4 * 4 + kk_jj_jjj % 4) < B_extent_0) {\u000A                    auto _D2 = (!p1 ? int4{j * 16 + (kk_jj_jjj % 16 / 4 * 4 + kk_jj_jjj % 4)} : (kk_jj_jjj / 16 + k * 4) * 4 + 1 * int4{0, 1, 2, 3}) + (!p1 ? (kk_jj_jjj / 16 + k * 4) * 4 + 1 * int4{0, 1, 2, 3} : int4{j * 16 + (kk_jj_jjj % 16 / 4 * 4 + kk_jj_jjj % 4)}) * int4{B_stride_1} - (int4{B_min_1 * B_stride_1 + B_min_0});\u000A                    float4 _V0;\u000A                    _V0[0] = ((float*)B)[_D2[0]];\u000A                    _V0[1] = ((float*)B)[_D2[1]];\u000A                    _V0[2] = ((float*)B)[_D2[2]];\u000A                    _V0[3] = ((float*)B)[_D2[3]];\u000A                    B_serializer_mem_channel[addr_temp * 4 + 0] = _V0[0];\u000A                    B_serializer_mem_channel[addr_temp * 4 + 1] = _V0[1];\u000A                    B_serializer_mem_channel[addr_temp * 4 + 2] = _V0[2];\u000A                    B_serializer_mem_channel[addr_temp * 4 + 3] = _V0[3];\u000A                  }\u000A                  addr_temp = addr_temp + 1;\u000A                }\u000A              }\u000A            }\u000A          }\u000A          _halide_buffer_set_host_dirty(B_serializer_mem_channel_buffer, (bool)(ADD_UINT64_T_SUFFIX(1)));\u000A        }\u000A        { // memcpy \u000A          bool from_host = (B_serializer_mem_channel_buffer->device == 0) || (B_serializer_mem_channel_buffer->host_dirty() && B_serializer_mem_channel_buffer->host != NULL);\u000A          bool to_host = 0;\u000A          if (!from_host && to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy device->host B_serializer_mem_channel_buffer\\n\";\u000A            #endif\u000A            q_device.submit([&](handler& h){ h.memcpy((void *)B_serializer_mem_channel_buffer->host, (void *)(((device_handle*)B_serializer_mem_channel_buffer->device)->mem), B_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A          } else if (from_host && !to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy host->device B_serializer_mem_channel_buffer\\n\";\u000A            #endif\u000A            q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)B_serializer_mem_channel_buffer->device)->mem), (void *)B_serializer_mem_channel_buffer->host, B_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A          } else if (!from_host && !to_host) {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A            #endif\u000A            assert(false);\u000A          } else {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t memcpy B_serializer_mem_channel_buffer Do nothing.\\n\";\u000A            #endif\u000A          }\u000A        }\u000A        kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A        // kernel_bLoader\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"// kernel kernel_bLoader\\n\";\u000A        #endif\u000A        B_serializer_mem_channel = (float*)(((device_handle*) B_serializer_mem_channel_buffer->device)->mem);\u000A        oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A          h.single_task<class kernel_bLoader_class>([=](){\u000A            int addr_temp;\u000A            addr_temp = 0;\u000A            for (int i = 0; i < (A_extent_1 + 31) / 16; i++) {\u000A              for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                for (int k = 0; k < (B_extent_1 + 15) / 16; k++) {\u000A                  for (int kk_jj_jjj = 0; kk_jj_jjj < 64; kk_jj_jjj++) {\u000A                    if (j == 0 && k == 0 || i < (A_extent_1 + 15) / 16) {\u000A                      auto _D3 = addr_temp % ((B_extent_0 + 15) / 16 * ((B_extent_1 + 15) / 16) * 64) * 4;\u000A                      bLoader_channel::write<>((kk_jj_jjj / 16 + k * 4) * 4 < B_extent_1 && j * 16 + (kk_jj_jjj % 16 / 4 * 4 + kk_jj_jjj % 4) < B_extent_0 && i < (A_extent_1 + 15) / 16 ? float4{\u000A                        B_serializer_mem_channel[_D3 + 0],\u000A                        B_serializer_mem_channel[_D3 + 1],\u000A                        B_serializer_mem_channel[_D3 + 2],\u000A                        B_serializer_mem_channel[_D3 + 3]\u000A                      } : float4{float_from_bits(0)});\u000A                    }\u000A                    addr_temp = addr_temp + 1;\u000A                  }\u000A                }\u000A              }\u000A            }\u000A          }); //  h.single_task kernel_bLoader_class\u000A        })); // q_device.submit\u000A        // kernel_bFeeder\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"// kernel kernel_bFeeder\\n\";\u000A        #endif\u000A        oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A          h.single_task<class kernel_bFeeder_class>([=](){\u000A            bFeeder_channel_array_t bFeeder_channel_array;\u000A            float4 bFeeder_value_shreg;\u000A            uint32_t bFeeder_time_stamp_shreg;\u000A            float4 bFeeder_in_v;\u000A            uint bFeeder_cycle;\u000A            // OpenCL's __attribute__((memory, numbanks(4), singlepump, numwriteports(1), numreadports(1)))DB[2][4][4][4]\u000A            [[intel::fpga_memory(), intel::numbanks(4), intel::singlepump, intel::simple_dual_port]]\u000A            float4 DB[2][4][4][4];\u000A            fpga_tools::UnrolledLoop<4>([&](auto iii_init) {\u000A              if (iii_init == 0) {\u000A                bFeeder_cycle = (uint)(ADD_UINT64_T_SUFFIX(0));\u000A              }\u000A            });\u000A            while(1) {\u000A              bFeeder_in_v = bLoader_channel::read<>();\u000A              fpga_tools::UnrolledLoop<4>([&](auto buf) {\u000A                if (buf == 0) {\u000A                  bFeeder_value_shreg = bFeeder_in_v;\u000A                  bFeeder_time_stamp_shreg = bFeeder_cycle;\u000A                } else {\u000A                  bFeeder_value_shreg = bFeeder_value_shreg;\u000A                  bFeeder_time_stamp_shreg = bFeeder_time_stamp_shreg;\u000A                }\u000A                bFeeder_value_shreg = float4{\u000A                sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[0])),\u000A                sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[1])),\u000A                sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[2])),\u000A                sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_value_shreg[3]))\u000A                };\u000A                bFeeder_time_stamp_shreg = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(bFeeder_time_stamp_shreg));\u000A                if (buf == (int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(4)))) {\u000A                  DB[(bool)(bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 4 % 4][buf] = bFeeder_value_shreg;\u000A                }\u000A                if ((uint)(ADD_UINT64_T_SUFFIX(0)) < bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                  bFeeder_channel_array.template get<buf>() = DB[!(bool)(bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64)) % (uint)(ADD_UINT64_T_SUFFIX(2)))][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) / 16][(int)(bFeeder_time_stamp_shreg % (uint)(ADD_UINT64_T_SUFFIX(64))) % 4][buf];\u000A                }\u000A              });\u000A              if ((uint)(ADD_UINT64_T_SUFFIX(0)) < bFeeder_time_stamp_shreg / (uint)(ADD_UINT64_T_SUFFIX(64))) {\u000A                bFeeder_channel::write<>(bFeeder_channel_array);\u000A              }\u000A              bFeeder_cycle = bFeeder_cycle + (uint)(ADD_UINT64_T_SUFFIX(1));\u000A            }\u000A          }); //  h.single_task kernel_bFeeder_class\u000A        })); // q_device.submit\u000A\u000A        // kernel_SignalGenerator\u000A        kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A        std::cout << \"kernel_SignalGenerator\" << std::endl;\u000A        oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h) {\u000A            h.single_task<class kernel_SignalGenerator>([=]() {\u000A                for (int i = 0; i < (A_extent_1 + 31) / 16; i++) {\u000A                  for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                    for (int k = 0; k < (B_extent_1 + 15) / 16; k++) {\u000A                      for (int kk_ii_jj = 0; kk_ii_jj < 64; kk_ii_jj++) {\u000A                        bool compute_not_done = (i < (A_extent_1 + 15) / 16);\u000A                        bool reduction_start = (k == 0 && kk_ii_jj / 16 == 0);\u000A                        bool reduction_end = (kk_ii_jj / 16 == 3 && k == (B_extent_1 + -1) / 16);\u000A                        bool draining_start = (kk_ii_jj % 4 == 0 && kk_ii_jj % 16 / 4 == 0 && k == (B_extent_1 + -1) / 16 && kk_ii_jj / 16 == 3 && i < (A_extent_1 + 15) / 16);\u000A                        signals_t signals = {compute_not_done, reduction_start, reduction_end, draining_start};\u000A                        SignalGenerator_channel::write(signals);\u000A                      }\u000A                    }\u000A                  }\u000A                }\u000A            });\u000A        }));\u000A\u000A        //kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A        // kernel_Product\u000A        #ifndef T2SP_NDEBUG\u000A        std::cout << \"// kernel kernel_Product\\n\";\u000A        #endif\u000A        /*oneapi_kernel_events.push_back(*/q_device.submit([&](sycl::handler &h){\u000A          h.single_task<class kernel_Product_class>([=](){\u000A            bFeeder_channel_array_t bFeeder_channel_array;\u000A            aFeeder_channel_array_t aFeeder_channel_array;\u000A            float Z_shreg[16][4][4];\u000A            float Z_pipe_shreg[4][49];\u000A            int Z_pipe_iter;\u000A            int Z_pipe_base;\u000A            Z_pipe_iter = 64;\u000A            Z_pipe_base = 0;\u000A            while (1) {\u000A                signals_t signals = SignalGenerator_channel::read();\u000A                bool compute_not_done = signals.s[0];\u000A                bool reduction_start = signals.s[1];\u000A                bool reduction_end = signals.s[2];\u000A                bool draining_start = signals.s[3];\u000A\u000A                    float4 Y_shreg[4];\u000A                    float4 X_shreg[4];\u000A                    float Z[4][4];\u000A                    fpga_tools::UnrolledLoop<4>([&](auto iii) {\u000A                      fpga_tools::UnrolledLoop<4>([&](auto jjj) {\u000A                        Z[jjj][iii] = Z_shreg[15][jjj][iii];\u000A                        fpga_tools::UnrolledLoop<15>([&](auto l1) {\u000A                          Z_shreg[15 - l1][jjj][iii] = Z_shreg[14 - l1][jjj][iii];\u000A                        });\u000A                        Z_shreg[0][jjj][iii] = Z[jjj][iii];\u000A                      });\u000A                    });\u000A                    if (compute_not_done) {\u000A                      bFeeder_channel_array = bFeeder_channel::read<>();\u000A                      aFeeder_channel_array = aFeeder_channel::read<>();\u000A                    }\u000A                    fpga_tools::UnrolledLoop<4>([&](auto iii) {\u000A                      fpga_tools::UnrolledLoop<4>([&](auto jjj) {\u000A                        X_shreg[iii] = jjj == 0 ? aFeeder_channel_array.template get<iii>() : X_shreg[iii];\u000A                        X_shreg[iii] = float4{\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][0])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][1])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][2])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(X_shreg[iii][3]))\u000A                        };\u000A                        Y_shreg[jjj] = iii == 0 ? bFeeder_channel_array.template get<jjj>() : Y_shreg[jjj];\u000A                        Y_shreg[jjj] = float4{\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][0])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][1])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][2])),\u000A                        sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Y_shreg[jjj][3]))\u000A                        };\u000A                        float Z_shreg_;\u000A                        Z_shreg_ = reduction_start ? float_from_bits(0) : sycl::ext::intel::fpga_reg(Z_shreg[0][jjj][iii]);\u000A                        fpga_tools::UnrolledLoop<4>([&](auto kkk) {\u000A                          Z_shreg_ = Z_shreg_ + X_shreg[iii][kkk] * Y_shreg[jjj][kkk];\u000A                          if (kkk == 3) {\u000A                            Z_shreg_ = sycl::ext::intel::fpga_reg(Z_shreg_);\u000A                          }\u000A                        });\u000A                        Z_shreg[0][jjj][iii] = Z_shreg_;\u000A                        fpga_tools::UnrolledLoop<4>([&](auto kkk) {\u000A                          if (kkk == 3 && reduction_end) {\u000A                            Z_pipe_shreg[jjj][iii * 16] = Z_shreg[0][jjj][iii];\u000A                          }\u000A                        });\u000A                      });\u000A                    });\u000A                    if (draining_start) {\u000A                      Z_pipe_base = Z_pipe_iter;\u000A                    }\u000A                    float4 Product_channel_;\u000A                    fpga_tools::UnrolledLoop<4>([&](auto b_62) {\u000A                      Product_channel_[b_62] = Z_pipe_shreg[b_62][0];\u000A                      fpga_tools::UnrolledLoop<4>([&](auto b_62_dummy) {\u000A                        Product_channel_[b_62_dummy] = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Product_channel_[b_62_dummy]));\u000A                      });\u000A                    });\u000A                    if (Z_pipe_iter < Z_pipe_base + 64) {\u000A                      Product_channel::write<>(Product_channel_);\u000A                    }\u000A                    fpga_tools::UnrolledLoop<4>([&](auto b_63) {\u000A                      fpga_tools::UnrolledLoop<3>([&](auto p_31) {\u000A                        fpga_tools::UnrolledLoop<15>([&](auto l_31) {\u000A                          Z_pipe_shreg[b_63][p_31 * 16 + l_31] = Z_pipe_shreg[b_63][p_31 * 16 + l_31 + 1];\u000A                        });\u000A                        Z_pipe_shreg[b_63][p_31 * 16 + 15] = sycl::ext::intel::fpga_reg(sycl::ext::intel::fpga_reg(Z_pipe_shreg[b_63][p_31 * 16 + 16]));\u000A                      });\u000A                    });\u000A                    Z_pipe_iter = Z_pipe_iter + 1;\u000A                  }\u000A          }); //  h.single_task kernel_Product_class\u000A        })/*)*/; // q_device.submit\u000A        halide_buffer_t b2;\u000A        struct halide_dimension_t s10[6] = {\u000A          {0, 4, 1, 0},\u000A          {0, 4, 4, 0},\u000A          {0, 4, 16, 0},\u000A          {0, 4, 64, 0},\u000A          {0, (B_extent_0 + 15) / 16, 256, 0},\u000A          {0, (A_extent_1 + 15) / 16, (B_extent_0 + 15) / 16 * 256, 0},\u000A        };\u000A        struct halide_dimension_t s11[6] = {\u000A          {0, 4, 1, 0},\u000A          {0, 4, 4, 0},\u000A          {0, 4, 16, 0},\u000A          {0, 4, 64, 0},\u000A          {0, (B_extent_0 + 15) / 16, 256, 0},\u000A          {0, (A_extent_1 + 15) / 16, (B_extent_0 + 15) / 16 * 256, 0},\u000A        };\u000A        struct halide_buffer_t * C_serializer_mem_channel_buffer = _halide_buffer_init(&b2, s10, (void *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), (uint64_t)(ADD_UINT64_T_SUFFIX(0)), (struct halide_device_interface_t *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), 2, 32, 6, s11, (uint64_t)(ADD_UINT64_T_SUFFIX(0)));\u000A        int32_t halide_device_and_host_malloc_result_1 = 0; // halide_device_and_host_malloc(C_serializer_mem_channel_buffer, NULL /* halide_oneapi_device_interface() replaced */) replaced with line(s) below \u000A        if (!C_serializer_mem_channel_buffer->device) { // device malloc\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\t device malloc C_serializer_mem_channel_buffer\\n\";\u000A          #endif\u000A          assert(C_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A          uint64_t lowest_index = 0;\u000A          uint64_t highest_index = 0;\u000A          for (int i = 0; i < C_serializer_mem_channel_buffer->dimensions; i++) {\u000A            if (C_serializer_mem_channel_buffer->dim[i].stride < 0) {\u000A              lowest_index += (uint64_t)(C_serializer_mem_channel_buffer->dim[i].stride) * (C_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A            }\u000A            if (C_serializer_mem_channel_buffer->dim[i].stride > 0) {\u000A              highest_index += (uint64_t)(C_serializer_mem_channel_buffer->dim[i].stride) * (C_serializer_mem_channel_buffer->dim[i].extent - 1);\u000A            }\u000A          }\u000A          device_handle *dev_handle = (device_handle *)std::malloc(sizeof(device_handle));\u000A          dev_handle->mem = (void*)sycl::malloc_device(C_serializer_mem_channel_buffer->size_in_bytes(), q_device);\u000A          dev_handle->offset = 0;\u000A          C_serializer_mem_channel_buffer->device = (uint64_t)dev_handle;\u000A        };\u000A        { // host malloc\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"//\\t host malloc C_serializer_mem_channel_buffer\\n\";\u000A          #endif\u000A          assert(C_serializer_mem_channel_buffer->size_in_bytes() != 0);\u000A          C_serializer_mem_channel_buffer->host = (uint8_t*)std::malloc(C_serializer_mem_channel_buffer->size_in_bytes());\u000A          assert(C_serializer_mem_channel_buffer->host != NULL);\u000A        };\u000A        struct s12 { void * const ucon; void * const arg; s12(void *ucon, void *a) : ucon(ucon), arg((void *)a) {} ~s12() { halide_device_and_host_free_as_destructor(ucon, arg); } } d2(_ucon, C_serializer_mem_channel_buffer);\u000A        {\u000A          float *C_serializer_mem_channel = (float *)(_halide_buffer_get_host(C_serializer_mem_channel_buffer));\u000A          if (!C_serializer_mem_channel)\u000A          {\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"Condition 'C_serializer_mem_channel' failed with error id_msg: None\\n\";\u000A            #endif\u000A            assert(false);\u000A          }\u000A          {\u000A            int32_t addr_temp;\u000A            addr_temp = 0;\u000A            int32_t halide_copy_to_host_result_3 = 0; // halide_copy_to_host(C_buffer) replaced with line(s) below \u000A            { // memcpy \u000A              bool from_host = (C_buffer->device == 0) || (C_buffer->host_dirty() && C_buffer->host != NULL);\u000A              bool to_host = 1;\u000A              if (!from_host && to_host) {\u000A                #ifndef T2SP_NDEBUG\u000A                std::cout << \"//\t memcpy device->host C_buffer\\n\";\u000A                #endif\u000A                q_device.submit([&](handler& h){ h.memcpy((void *)C_buffer->host, (void *)(((device_handle*)C_buffer->device)->mem), C_buffer->size_in_bytes()); }).wait();\u000A              } else if (from_host && !to_host) {\u000A                #ifndef T2SP_NDEBUG\u000A                std::cout << \"//\t memcpy host->device C_buffer\\n\";\u000A                #endif\u000A                q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)C_buffer->device)->mem), (void *)C_buffer->host, C_buffer->size_in_bytes()); }).wait();\u000A              } else if (!from_host && !to_host) {\u000A                #ifndef T2SP_NDEBUG\u000A                std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A                #endif\u000A                assert(false);\u000A              } else {\u000A                #ifndef T2SP_NDEBUG\u000A                std::cout << \"//\t memcpy C_buffer Do nothing.\\n\";\u000A                #endif\u000A              }\u000A            };\u000A            // kernel_C_serializer\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"// kernel kernel_C_serializer\\n\";\u000A            #endif\u000A            float *C = (float*)(C_buffer->host);\u000A            C_serializer_mem_channel = (float*)(C_serializer_mem_channel_buffer->host);\u000A            {\u000A              for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A                for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                  for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                    if (p3 != float_from_bits(0)) {\u000A                      auto _D4 = (j * 4 + iii_ii_jj % 4) * 4 + (i * 16 + (iii_ii_jj / 16 + iii_ii_jj % 16 / 4 * 4)) * C_stride_1 - (C_min_1 * C_stride_1 + C_min_0);\u000A                      auto _D5 = float4{\u000A                        C[_D4 + 0],\u000A                        C[_D4 + 1],\u000A                        C[_D4 + 2],\u000A                        C[_D4 + 3]\u000A                      };\u000A                      C_serializer_mem_channel[addr_temp * 4 + 0] = _D5[0];\u000A                      C_serializer_mem_channel[addr_temp * 4 + 1] = _D5[1];\u000A                      C_serializer_mem_channel[addr_temp * 4 + 2] = _D5[2];\u000A                      C_serializer_mem_channel[addr_temp * 4 + 3] = _D5[3];\u000A                    }\u000A                    addr_temp = addr_temp + 1;\u000A                  }\u000A                }\u000A              }\u000A            }\u000A            _halide_buffer_set_host_dirty(C_serializer_mem_channel_buffer, (bool)(ADD_UINT64_T_SUFFIX(1)));\u000A          }\u000A          { // memcpy \u000A            bool from_host = (C_serializer_mem_channel_buffer->device == 0) || (C_serializer_mem_channel_buffer->host_dirty() && C_serializer_mem_channel_buffer->host != NULL);\u000A            bool to_host = 0;\u000A            if (!from_host && to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy device->host C_serializer_mem_channel_buffer\\n\";\u000A              #endif\u000A              q_device.submit([&](handler& h){ h.memcpy((void *)C_serializer_mem_channel_buffer->host, (void *)(((device_handle*)C_serializer_mem_channel_buffer->device)->mem), C_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A            } else if (from_host && !to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy host->device C_serializer_mem_channel_buffer\\n\";\u000A              #endif\u000A              q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)C_serializer_mem_channel_buffer->device)->mem), (void *)C_serializer_mem_channel_buffer->host, C_serializer_mem_channel_buffer->size_in_bytes()); }).wait();\u000A            } else if (!from_host && !to_host) {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A              #endif\u000A              assert(false);\u000A            } else {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t memcpy C_serializer_mem_channel_buffer Do nothing.\\n\";\u000A              #endif\u000A            }\u000A          }\u000A          kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A          // kernel_cLoader\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"// kernel kernel_cLoader\\n\";\u000A          #endif\u000A          C_serializer_mem_channel = (float*)(((device_handle*) C_serializer_mem_channel_buffer->device)->mem);\u000A          oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A            h.single_task<class kernel_cLoader_class>([=](){\u000A              int addr_temp;\u000A              addr_temp = 0;\u000A              for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A                for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                  for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                    if (p3 != float_from_bits(0)) {\u000A                      cLoader_channel::write<>(float4{\u000A                        C_serializer_mem_channel[addr_temp * 4 + 0],\u000A                        C_serializer_mem_channel[addr_temp * 4 + 1],\u000A                        C_serializer_mem_channel[addr_temp * 4 + 2],\u000A                        C_serializer_mem_channel[addr_temp * 4 + 3]\u000A                      });\u000A                    }\u000A                    addr_temp = addr_temp + 1;\u000A                  }\u000A                }\u000A              }\u000A            }); //  h.single_task kernel_cLoader_class\u000A          })); // q_device.submit\u000A          kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A          // kernel_Out\u000A          #ifndef T2SP_NDEBUG\u000A          std::cout << \"// kernel kernel_Out\\n\";\u000A          #endif\u000A          oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A            h.single_task<class kernel_Out_class>([=](){\u000A              for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A                for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                  for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                    float4 Add_shreg;\u000A                    Add_shreg = (p3 == float_from_bits(0) ? float4{float_from_bits(0)} : cLoader_channel::read<>() * float4{p3}) + Product_channel::read<>() * float4{p2};\u000A                    Out_channel::write<>(Add_shreg);\u000A                  }\u000A                }\u000A              }\u000A            }); //  h.single_task kernel_Out_class\u000A          })); // q_device.submit\u000A          halide_buffer_t b3;\u000A          struct halide_dimension_t s13[6] = {\u000A            {0, 4, 1, 0},\u000A            {0, 4, 4, 0},\u000A            {0, 4, 16, 0},\u000A            {0, 4, 64, 0},\u000A            {0, (B_extent_0 + 15) / 16, 256, 0},\u000A            {0, (A_extent_1 + 15) / 16, (B_extent_0 + 15) / 16 * 256, 0},\u000A          };\u000A          struct halide_dimension_t s14[6] = {\u000A            {0, 4, 1, 0},\u000A            {0, 4, 4, 0},\u000A            {0, 4, 16, 0},\u000A            {0, 4, 64, 0},\u000A            {0, (B_extent_0 + 15) / 16, 256, 0},\u000A            {0, (A_extent_1 + 15) / 16, (B_extent_0 + 15) / 16 * 256, 0},\u000A          };\u000A          struct halide_buffer_t * unloader_mem_channel_buffer = _halide_buffer_init(&b3, s13, (void *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), (uint64_t)(ADD_UINT64_T_SUFFIX(0)), (struct halide_device_interface_t *)((uint64_t)(ADD_UINT64_T_SUFFIX(0))), 2, 32, 6, s14, (uint64_t)(ADD_UINT64_T_SUFFIX(0)));\u000A          int32_t halide_device_and_host_malloc_result = 0; // halide_device_and_host_malloc(unloader_mem_channel_buffer, NULL /* halide_oneapi_device_interface() replaced */) replaced with line(s) below \u000A          if (!unloader_mem_channel_buffer->device) { // device malloc\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\t device malloc unloader_mem_channel_buffer\\n\";\u000A            #endif\u000A            assert(unloader_mem_channel_buffer->size_in_bytes() != 0);\u000A            uint64_t lowest_index = 0;\u000A            uint64_t highest_index = 0;\u000A            for (int i = 0; i < unloader_mem_channel_buffer->dimensions; i++) {\u000A              if (unloader_mem_channel_buffer->dim[i].stride < 0) {\u000A                lowest_index += (uint64_t)(unloader_mem_channel_buffer->dim[i].stride) * (unloader_mem_channel_buffer->dim[i].extent - 1);\u000A              }\u000A              if (unloader_mem_channel_buffer->dim[i].stride > 0) {\u000A                highest_index += (uint64_t)(unloader_mem_channel_buffer->dim[i].stride) * (unloader_mem_channel_buffer->dim[i].extent - 1);\u000A              }\u000A            }\u000A            device_handle *dev_handle = (device_handle *)std::malloc(sizeof(device_handle));\u000A            dev_handle->mem = (void*)sycl::malloc_device(unloader_mem_channel_buffer->size_in_bytes(), q_device);\u000A            dev_handle->offset = 0;\u000A            unloader_mem_channel_buffer->device = (uint64_t)dev_handle;\u000A          };\u000A          { // host malloc\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"//\\t host malloc unloader_mem_channel_buffer\\n\";\u000A            #endif\u000A            assert(unloader_mem_channel_buffer->size_in_bytes() != 0);\u000A            unloader_mem_channel_buffer->host = (uint8_t*)std::malloc(unloader_mem_channel_buffer->size_in_bytes());\u000A            assert(unloader_mem_channel_buffer->host != NULL);\u000A          };\u000A          struct s15 { void * const ucon; void * const arg; s15(void *ucon, void *a) : ucon(ucon), arg((void *)a) {} ~s15() { halide_device_and_host_free_as_destructor(ucon, arg); } } d3(_ucon, unloader_mem_channel_buffer);\u000A          {\u000A            float *unloader_mem_channel = (float *)(_halide_buffer_get_host(unloader_mem_channel_buffer));\u000A            if (!unloader_mem_channel)\u000A            {\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"Condition 'unloader_mem_channel' failed with error id_msg: None\\n\";\u000A              #endif\u000A              assert(false);\u000A            }\u000A            if (!unloader_mem_channel_buffer->device) { // device malloc\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"//\t device malloc unloader_mem_channel_buffer\\n\";\u000A              #endif\u000A              assert(unloader_mem_channel_buffer->size_in_bytes() != 0);\u000A              uint64_t lowest_index = 0;\u000A              uint64_t highest_index = 0;\u000A              for (int i = 0; i < unloader_mem_channel_buffer->dimensions; i++) {\u000A                if (unloader_mem_channel_buffer->dim[i].stride < 0) {\u000A                  lowest_index += (uint64_t)(unloader_mem_channel_buffer->dim[i].stride) * (unloader_mem_channel_buffer->dim[i].extent - 1);\u000A                }\u000A                if (unloader_mem_channel_buffer->dim[i].stride > 0) {\u000A                  highest_index += (uint64_t)(unloader_mem_channel_buffer->dim[i].stride) * (unloader_mem_channel_buffer->dim[i].extent - 1);\u000A                }\u000A              }\u000A              device_handle *dev_handle = (device_handle *)std::malloc(sizeof(device_handle));\u000A              dev_handle->mem = (void*)sycl::malloc_device(unloader_mem_channel_buffer->size_in_bytes(), q_device);\u000A              dev_handle->offset = 0;\u000A              unloader_mem_channel_buffer->device = (uint64_t)dev_handle;\u000A            }\u000A            kernels_used_to_measure_time.push_back(oneapi_kernel_events.size());\u000A            // kernel_unloader\u000A            #ifndef T2SP_NDEBUG\u000A            std::cout << \"// kernel kernel_unloader\\n\";\u000A            #endif\u000A            unloader_mem_channel = (float*)(((device_handle*) unloader_mem_channel_buffer->device)->mem);\u000A            oneapi_kernel_events.push_back(q_device.submit([&](sycl::handler &h){\u000A              h.single_task<class kernel_unloader_class>([=](){\u000A                int addr_temp;\u000A                addr_temp = 0;\u000A                for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A                  for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                    for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                      auto _D6 = Out_channel::read<>();\u000A                      unloader_mem_channel[addr_temp * 4 + 0] = _D6[0];\u000A                      unloader_mem_channel[addr_temp * 4 + 1] = _D6[1];\u000A                      unloader_mem_channel[addr_temp * 4 + 2] = _D6[2];\u000A                      unloader_mem_channel[addr_temp * 4 + 3] = _D6[3];\u000A                      addr_temp = addr_temp + 1;\u000A                    }\u000A                  }\u000A                }\u000A              }); //  h.single_task kernel_unloader_class\u000A            })); // q_device.submit\u000A            oneapi_kernel_events.back().wait();\u000A            _halide_buffer_set_device_dirty(unloader_mem_channel_buffer, (bool)(ADD_UINT64_T_SUFFIX(1)));\u000A            {\u000A              int32_t addr_temp;\u000A              addr_temp = 0;\u000A              int32_t halide_copy_to_host_result = 0; // halide_copy_to_host(unloader_mem_channel_buffer) replaced with line(s) below \u000A              { // memcpy \u000A                bool from_host = (unloader_mem_channel_buffer->device == 0) || (unloader_mem_channel_buffer->host_dirty() && unloader_mem_channel_buffer->host != NULL);\u000A                bool to_host = 1;\u000A                if (!from_host && to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy device->host unloader_mem_channel_buffer\\n\";\u000A                  #endif\u000A                  q_device.submit([&](handler& h){ h.memcpy((void *)unloader_mem_channel_buffer->host, (void *)(((device_handle*)unloader_mem_channel_buffer->device)->mem), unloader_mem_channel_buffer->size_in_bytes()); }).wait();\u000A                } else if (from_host && !to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy host->device unloader_mem_channel_buffer\\n\";\u000A                  #endif\u000A                  q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)unloader_mem_channel_buffer->device)->mem), (void *)unloader_mem_channel_buffer->host, unloader_mem_channel_buffer->size_in_bytes()); }).wait();\u000A                } else if (!from_host && !to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A                  #endif\u000A                  assert(false);\u000A                } else {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy unloader_mem_channel_buffer Do nothing.\\n\";\u000A                  #endif\u000A                }\u000A              };\u000A              int32_t halide_copy_to_host_result_4 = 0; // halide_copy_to_host(Output_buffer) replaced with line(s) below \u000A              { // memcpy \u000A                bool from_host = (Output_buffer->device == 0) || (Output_buffer->host_dirty() && Output_buffer->host != NULL);\u000A                bool to_host = 1;\u000A                if (!from_host && to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy device->host Output_buffer\\n\";\u000A                  #endif\u000A                  q_device.submit([&](handler& h){ h.memcpy((void *)Output_buffer->host, (void *)(((device_handle*)Output_buffer->device)->mem), Output_buffer->size_in_bytes()); }).wait();\u000A                } else if (from_host && !to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy host->device Output_buffer\\n\";\u000A                  #endif\u000A                  q_device.submit([&](handler& h){ h.memcpy((void *)(((device_handle*)Output_buffer->device)->mem), (void *)Output_buffer->host, Output_buffer->size_in_bytes()); }).wait();\u000A                } else if (!from_host && !to_host) {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy device->device not implemented yet\\n\";\u000A                  #endif\u000A                  assert(false);\u000A                } else {\u000A                  #ifndef T2SP_NDEBUG\u000A                  std::cout << \"//\t memcpy Output_buffer Do nothing.\\n\";\u000A                  #endif\u000A                }\u000A              };\u000A              // kernel_Output\u000A              #ifndef T2SP_NDEBUG\u000A              std::cout << \"// kernel kernel_Output\\n\";\u000A              #endif\u000A              unloader_mem_channel = (float*)(unloader_mem_channel_buffer->host);\u000A              float *Output = (float*)(Output_buffer->host);\u000A              {\u000A                for (int i = 0; i < (A_extent_1 + 15) / 16; i++) {\u000A                  for (int j = 0; j < (B_extent_0 + 15) / 16; j++) {\u000A                    for (int iii_ii_jj = 0; iii_ii_jj < 64; iii_ii_jj++) {\u000A                      auto _D7 = float4{\u000A                        unloader_mem_channel[addr_temp * 4 + 0],\u000A                        unloader_mem_channel[addr_temp * 4 + 1],\u000A                        unloader_mem_channel[addr_temp * 4 + 2],\u000A                        unloader_mem_channel[addr_temp * 4 + 3]\u000A                      };\u000A                      auto _D8 = i * Output_stride_5 + (j * Output_stride_4 + (iii_ii_jj / 16 * Output_stride_3 + (iii_ii_jj % 4 * Output_stride_1 + iii_ii_jj % 16 / 4 * Output_stride_2))) - (Output_min_5 * Output_stride_5 + (Output_min_4 * Output_stride_4 + (Output_min_3 * Output_stride_3 + (Output_min_2 * Output_stride_2 + (Output_min_1 * Output_stride_1 + Output_min_0)))));\u000A                      Output[_D8 + 0] = _D7[0];\u000A                      Output[_D8 + 1] = _D7[1];\u000A                      Output[_D8 + 2] = _D7[2];\u000A                      Output[_D8 + 3] = _D7[3];\u000A                      addr_temp = addr_temp + 1;\u000A                    }\u000A                  }\u000A                }\u000A              }\u000A              _halide_buffer_set_host_dirty(Output_buffer, (bool)(ADD_UINT64_T_SUFFIX(1)));\u000A              int32_t halide_device_and_host_free_result = 0; // halide_device_and_host_free(unloader_mem_channel_buffer) replaced with line(s) below \u000A              if (unloader_mem_channel_buffer->device) { // device free\u000A               sycl::free(((device_handle*)unloader_mem_channel_buffer->device)->mem , q_device);\u000A               assert(((device_handle *)unloader_mem_channel_buffer->device)->offset == 0);\u000A               std::free((device_handle *)unloader_mem_channel_buffer->device);\u000A               unloader_mem_channel_buffer->set_device_dirty(false);\u000A              }\u000A              if (unloader_mem_channel_buffer->host) { // host free\u000A                std::free((void*)unloader_mem_channel_buffer->host);\u000A                unloader_mem_channel_buffer->host = NULL;\u000A                unloader_mem_channel_buffer->set_host_dirty(false);\u000A              };\u000A            }\u000A            unloader_mem_channel = NULL;\u000A          }\u000A          C_serializer_mem_channel = NULL;\u000A        }\u000A        B_serializer_mem_channel = NULL;\u000A      }\u000A      A_serializer_mem_channel = NULL;\u000A    }\u000A  }\u000A  oneapi_kernel_events.back().wait();\u000A  #ifndef T2SP_NDEBUG\u000A  std::cout << \"// return the kernel execution time in nanoseconds\\n\";\u000A  #endif\u000A  auto k_earliest_start_time = std::numeric_limits<\u000A    typename sycl::info::event_profiling::command_start::return_type>::max();\u000A  auto k_latest_end_time = std::numeric_limits<\u000A    typename sycl::info::event_profiling::command_end::return_type>::min();\u000A  for (auto i : kernels_used_to_measure_time) {\u000A    auto tmp_start = oneapi_kernel_events[i].get_profiling_info<sycl::info::event_profiling::command_start>();\u000A    auto tmp_end = oneapi_kernel_events[i].get_profiling_info<sycl::info::event_profiling::command_end>();\u000A    if (tmp_start < k_earliest_start_time) {\u000A      k_earliest_start_time = tmp_start;\u000A    }\u000A    if (tmp_end > k_latest_end_time) {\u000A      k_latest_end_time = tmp_end;\u000A    }\u000A  }\u000A  // Get time in ns\u000A  return kernels_used_to_measure_time.empty() ? decltype(k_latest_end_time){} : k_latest_end_time - k_earliest_start_time;\u000A}\u000A}\u000A\u000A"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/tuple.hpp", "name":"tuple.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/tuple.hpp", "content":"#ifndef __TUPLE_HPP__\u000A#define __TUPLE_HPP__\u000A\u000A#include <type_traits>\u000A\u000Anamespace fpga_tools {\u000A\u000A//\u000A// Generic tuple\u000A//\u000A// USAGE EXAMPLE:\u000A//    Tuple<char,short,int,long> my_tuple;\u000A//    char a = my_tuple.get<0>();\u000A//    short b = my_tuple.get<1>();\u000A//    int c = my_tuple.get<2>();\u000A//    long d = my_tuple.get<3>();\u000A//\u000Atemplate <typename... Tys>\u000Astruct Tuple {\u000A  Tuple(Tys... Args) : values(Args...) {}\u000A  Tuple() {}\u000A\u000A  //\u000A  // get the index'th item in the tuple of values\u000A  //\u000A  template <int index>\u000A  auto& get() {\u000A    static_assert(index < NumTys, \"index out of bounds\");\u000A    return get_impl<index, Tys...>(values);\u000A  }\u000A\u000A  //\u000A  // helper to get the first element in the tuple\u000A  //\u000A  auto& first() { return get<0>(); }\u000A\u000A  //\u000A  // helper to get the last element in the tuple\u000A  //\u000A  auto& last() { return get<NumTys - 1>(); }\u000A\u000A private:\u000A  //\u000A  // generic tuple implementation: recursive case\u000A  //\u000A  template <typename CurrentTy, typename... OtherTys>\u000A  struct tuple_impl {\u000A    tuple_impl(CurrentTy& current, OtherTys... others)\u000A        : value(current), other_values(others...) {}\u000A    tuple_impl() {}\u000A\u000A    using ValueTy = CurrentTy;\u000A    ValueTy value;\u000A    tuple_impl<OtherTys...> other_values;\u000A  };\u000A\u000A  //\u000A  // generic tuple implementation: base case\u000A  //\u000A  template <typename FinalTy>\u000A  struct tuple_impl<FinalTy> {\u000A    tuple_impl(FinalTy& current) : value(current) {}\u000A    tuple_impl() {}\u000A\u000A    using ValueTy = FinalTy;\u000A    ValueTy value;\u000A  };\u000A\u000A  // the tuple values\u000A  tuple_impl<Tys...> values;\u000A\u000A  // the number of tuple values\u000A  constexpr static auto NumTys = sizeof...(Tys);\u000A\u000A  //\u000A  // implementation of 'get' for general tuple\u000A  //\u000A  template <int index, typename HeadTy, typename... TailTys>\u000A  static auto& get_impl(tuple_impl<HeadTy, TailTys...>& sub_tuple) {\u000A    if constexpr (index == 0) {\u000A      // base case\u000A      return sub_tuple.value;\u000A    } else {\u000A      // recursive case\u000A      return get_impl<index - 1, TailTys...>(sub_tuple.other_values);\u000A    }\u000A  }\u000A};\u000A\u000A//\u000A// NTuple implementation\u000A// This is convenient way to have N elements of the same type\u000A// somewhat like an std::array\u000A//\u000Atemplate <int, typename Type>\u000Ausing NTupleElem = Type;\u000A\u000Atemplate <typename Type, std::size_t... Idx>\u000Astatic auto make_NTupleImpl(std::index_sequence<Idx...>)\u000A    -> Tuple<NTupleElem<Idx, Type>...>;\u000A\u000Atemplate <int N, typename Type>\u000Ausing make_NTuple =\u000A    decltype(make_NTupleImpl<Type>(std::make_index_sequence<N>()));\u000A\u000A//\u000A// convenience alias for a tuple of N elements of the same type\u000A// NOTE: for this alias, typename comes FIRST (to match std::array)\u000A//\u000A// USAGE EXAMPLE:\u000A//    NTuple<int, 10> elements;\u000A//    elements.get<3>() = 17;\u000A//\u000Atemplate <typename Type, int N>\u000Ausing NTuple = make_NTuple<N, Type>;\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __TUPLE_HPP__ */"}, {"path":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/unrolled_loop.hpp", "name":"unrolled_loop.hpp", "has_active_debug_locs":false, "absName":"/home/u89062/oneAPI-samples-ronghongbo/DirectProgramming/C++SYCL_FPGA/include/unrolled_loop.hpp", "content":"#ifndef __UNROLLEDLOOP_HPP__\u000A#define __UNROLLEDLOOP_HPP__\u000A\u000A#include <type_traits>\u000A#include <utility>\u000A\u000A#include \"metaprogramming_utils.hpp\"\u000A\u000Anamespace fpga_tools {\u000A///////////////////////////////////////////////////////////////////////////////\u000A//\u000A// Example usage for UnrolledLoop constexpr:\u000A//\u000A// Base\u000A//    UnrolledLoop(std::integer_sequence<int,5,2,7,8>{},[&](auto i) {\u000A//      /* i = 5,2,7,8 */\u000A//    });\u000A//\u000A// Case A\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case B\u000A//    UnrolledLoop<10>([&](auto i) {\u000A//      /* i = 0,1,...,9 */\u000A//    });\u000A//\u000A// Case C\u000A//    UnrolledLoop<char, 1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<char, 10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A// Case D\u000A//    UnrolledLoop<1, 10>([&](auto i) {\u000A//      /* i = 1,2,...,9 */\u000A//    });\u000A//    UnrolledLoop<10, 1>([&](auto i) {\u000A//      /* i = 10,9,...,2 */\u000A//    });\u000A//\u000A///////////////////////////////////////////////////////////////////////////////\u000A\u000A//\u000A// Base implementation\u000A// Templated on:\u000A//    ItType    - the type of the iterator (size_t, int, char, ...)\u000A//    ItType... - the indices to iterate on\u000A//    F         - the function to run for each index (i.e. the lambda)\u000A//\u000Atemplate <class ItType, ItType... inds, class F>\u000Aconstexpr void UnrolledLoop(std::integer_sequence<ItType, inds...>, F&& f) {\u000A  (f(std::integral_constant<ItType, inds>{}), ...);\u000A}\u000A\u000A//\u000A// Convience implementation (A)\u000A// performs UnrolledLoop in range [0,n) with iterator of type ItType\u000A//\u000Atemplate <class ItType, ItType n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_integer_sequence<ItType, n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (B)\u000A// performs UnrolledLoop in range [0,n) with an iterator of type std::size_t\u000A//\u000Atemplate <std::size_t n, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(std::make_index_sequence<n>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (C)\u000A// performs UnrolledLoop from start...end with an iterator of type ItType\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <class ItType, ItType start, ItType end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_integer_range<ItType, start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A//\u000A// Convenience implementation (D)\u000A// performs UnrolledLoop from start...end with an iterator of type size_t\u000A// NOTE:  start is INCLUSIVE, end is EXCLUSIVE\u000A// NOTE:  if start<=end, sequence is start,start+1,...,end-1\u000A//        if end<=start, sequence is start,start-1,...,end+1\u000A//\u000Atemplate <std::size_t start, std::size_t end, class F>\u000Aconstexpr void UnrolledLoop(F&& f) {\u000A  UnrolledLoop(make_index_range<start, end>{}, std::forward<F>(f));\u000A}\u000A\u000A}  // namespace fpga_tools\u000A\u000A#endif /* __UNROLLEDLOOP_HPP__ */"}];
var alpha_viewer=false;