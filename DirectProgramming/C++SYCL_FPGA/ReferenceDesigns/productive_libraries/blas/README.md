# `BLAS`

This directory contains FPGA reference designs for the standard BLAS kernels defined in [oneMKL](https://oneapi-src.github.io/oneMKL/domains/blas/blas.html). The row-major, USM-based SYCL interface is supported.

To reduce engineering efforts, kernels with similar computes are grouped so that a single systolic array can be built and reconfigured to cover each kernel in the group, without losing performance. Below are the kernels supported, with one table for one group:

## `Level 1 kernels`


| Kernel            | Formula                           | Data types of (inputs, output)       | Description                          |
| ----------------- | --------------------------------- | -------------------------------------|----------- |
| $\mathbf{dot}$    | $\vec{X}\cdot \vec{Y}$            | (s, s), (d, d), (s, d) | Dot product. For the mixed precision version (inputs are float while result is double), the dot product is computed with double precision. |
| $\mathbf{sdsdot}$ | $sb+\vec{X}\cdot \vec{Y}$         | (s, s)  | A dot product between two single-precision vectors , plus a single-precision float $sb$ |
| $\mathbf{dotc}$   | $\overline{\vec{X}}\cdot \vec{Y}$ | (c, c), (z, z)    | A dot product between two complex vectors, conjugating the first of them  |
| $\mathbf{dotu}$   | $\vec{X}\cdot \vec{Y}$            | (c, c), (z, z)    |  A dot product between two complex vectors  |
| $\mathbf{nrm2}$   | $\|\vec{X}\|$                     |  (s, s), (d, d), (c, s),(z, d)|   Euclidean norm of a vector |




## `Level 2 kernels`


## `Level 3 kernels`

 Kernel          | Formula             | Data types | Description       |
| --------------- | ------------------- | ----------|------- |
| $\mathbf{gemm}$ | $\alpha op(A)op(B)+\beta C$ | s, d, c, z  | Multiplication of general matrices. $op(X)$ is one of $X$, $X^T$, and $X^H$ |
| $\mathbf{symm}$ | $\alpha AB+\beta C$, or  $\alpha BA+\beta C$ |s, d, c, z | A is a symmetric matrix |
| $\mathbf{hemm}$ |$\alpha AB+\beta C$, or  $\alpha BA+\beta C$ |s, d, c, z | A is a Hermitian matrix |
| $\mathbf{syrk}$ | $C \leftarrow \alpha op(A)op(A)^T + \beta C$ | s, d, c, z |$op(X)=X$ or $op(X) = X^T$, C is a symmtric matrix. |
| $\mathbf{herk}$ | $C \leftarrow \alpha op(A)op(A)^H + \beta C$ | c/z for the matrices, with s/d for the scalars |$op(X)=X$ or $op(X) = X^H$, C is a Hermitian matrix. |
 

## `File structure`

All the kernels are put under the `blas` directory. Every kernel has the following files under it:

* `api.hpp` - The API to invoke the kernel in any SYCL application.
* `test.cpp` - Unit tests for correctness, adapted from [oneMKL's test suite](https://github.com/oneapi-src/oneMKL/blob/develop/tests/unit_tests/blas/), with slight changes to respect the row-major layout and the sizes of the reconfigurable systolic arrays.
* `demo.cpp` - Demonstrating how to invoke the kernel.
* `CMakeLists.txt` - A cmake script.
* `README.md` - A short description of the kernel.

The shared systolic arrays (named as `reconfigurable-*`) are also under the `blas` directory. Every systolic array has the following files under it:
* `api.hpp` - The API to invoke the systolic array.
* `spec.cpp`: A brief description of the systolic array and other optimizations for it in the [T2SP language](https://github.com/IntelLabs/t2sp). From this specification, SYCL files will be generated by the T2SP compiler. The SYCL files are then synthesized into a bitstream for an FPGA hardware.
* `parameters.h` : Sizes and data types of the systolic array.
* `CMakeLists.txt` - A cmake script.
* `README.md` - A short description of the systolic array.

## Build a kernel and run on Linux

1. Configure the build system.

    ```shell
    cd KERNEL # Replace this with the specific kernel's name, e.g. gemm
    mkdir -p build
    cd build
    ```
   
    For Intel Arria® 10 GX FPGA:
    ```shell  
    cmake ..
    ```

    For **Intel Stratix® 10 SX**:
    ```shell
    cmake .. -DFPGA_DEVICE=intel_s10sx_pac:pac_s10
    ```

2. Test correctness.

   ```shell
   make tests
   ../bin/test_* # Replace * with specific test ID like 0, 1, ...
   ```

    Each test builds a tiny-scale systolic array and runs on an FPGA emulator.

3. Test performance

    Each kernel usually has several variations, depending on the the precision. For example, `gemm` has 4 precisions supported,  `s` (single-precision), `d`(double-precision), `c`(complex single-precision), and `z`(complex double-precision), and correspondingly, 4 variations: `sgemm`, `dgemm`, `cgemm` and `zgemm`.

    ```shell
    # Replace the VARIATION below with a specific variation of the kernel
    make demo_VARIATION_(tiny|large)_(a10|s10)
    ../bin/demo_VARIATION_(tiny|large)_(a10|s10)
    ```

    Take `sgemm` for example:
    ```shell
    # Generate a demo application.
    make demo_sgemm_large_a10

    # Demo on the hardware
    ../bin/demo_sgemm_large_a10
    ``` 
    Note that `sgemm` actually involkes a reconfigurable systolic array. When building the demo for `sgemm` as shown above, that array will be automatically synthesized, if not yet.
